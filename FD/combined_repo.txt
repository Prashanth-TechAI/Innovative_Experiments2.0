# Repository dump: /home/username/Downloads/FD/mongodb-mcp-server

## File: .vscode/extensions.json

{
  // See https://go.microsoft.com/fwlink/?LinkId=827846 to learn about workspace recommendations.
  // Extension identifier format: ${publisher}.${name}. Example: vscode.csharp

  // List of extensions which should be recommended for users of this workspace.
  "recommendations": ["firsttris.vscode-jest-runner", "orta.vscode-jest"],
  // List of extensions recommended by VS Code that should not be recommended for users of this workspace.
  "unwantedRecommendations": []
}


## File: .vscode/launch.json

{
  // Use IntelliSense to learn about possible attributes.
  // Hover to view descriptions of existing attributes.
  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "Launch Program",
      "skipFiles": ["<node_internals>/**"],
      "program": "${workspaceFolder}/dist/index.js",
      "preLaunchTask": "tsc: build - tsconfig.build.json",
      "outFiles": ["${workspaceFolder}/dist/**/*.js"]
    }
  ]
}


## File: .vscode/settings.json

{
  "jestrunner.jestCommand": "npm test --",
  "jestrunner.debugOptions": {
    "runtimeExecutable": "node",
    "runtimeArgs": [
      "--experimental-vm-modules",
      "node_modules/jest/bin/jest.js",
      "--coverage"
    ]
  }
}


## File: scripts/apply.ts

import fs from "fs/promises";
import { OpenAPIV3_1 } from "openapi-types";
import argv from "yargs-parser";

function findObjectFromRef<T>(obj: T | OpenAPIV3_1.ReferenceObject, openapi: OpenAPIV3_1.Document): T {
    const ref = (obj as OpenAPIV3_1.ReferenceObject).$ref;
    if (ref === undefined) {
        return obj as T;
    }
    const paramParts = ref.split("/");
    paramParts.shift(); // Remove the first part which is always '#'

    let foundObj: Record<string, unknown> = openapi;
    while (true) {
        const part = paramParts.shift();
        if (!part) {
            break;
        }

        foundObj = foundObj[part] as Record<string, unknown>;
    }
    return foundObj as T;
}

async function main() {
    const { spec, file } = argv(process.argv.slice(2));

    if (!spec || !file) {
        console.error("Please provide both --spec and --file arguments.");
        process.exit(1);
    }

    const specFile = await fs.readFile(spec as string, "utf8");

    const operations: {
        path: string;
        method: string;
        operationId: string;
        requiredParams: boolean;
        tag: string;
        hasResponseBody: boolean;
    }[] = [];

    const openapi = JSON.parse(specFile) as OpenAPIV3_1.Document;
    for (const path in openapi.paths) {
        for (const method in openapi.paths[path]) {
            // @ts-expect-error This is a workaround for the OpenAPI types
            const operation = openapi.paths[path][method] as OpenAPIV3_1.OperationObject;

            if (!operation.operationId || !operation.tags?.length) {
                continue;
            }

            let requiredParams = !!operation.requestBody;
            let hasResponseBody = false;
            for (const code in operation.responses) {
                try {
                    const httpCode = parseInt(code, 10);
                    if (httpCode >= 200 && httpCode < 300) {
                        const response = operation.responses[code];
                        const responseObject = findObjectFromRef(response, openapi) as OpenAPIV3_1.ResponseObject;
                        if (responseObject && responseObject.content) {
                            for (const contentType in responseObject.content) {
                                const content = responseObject.content[contentType];
                                hasResponseBody = !!content?.schema;
                            }
                        }
                    }
                } catch {
                    continue;
                }
            }

            for (const param of operation.parameters || []) {
                const paramObject = findObjectFromRef(param, openapi);
                if (paramObject.in === "path") {
                    requiredParams = true;
                }
            }

            operations.push({
                path,
                method: method.toUpperCase(),
                operationId: operation.operationId || "",
                requiredParams,
                hasResponseBody,
                tag: operation.tags?.[0] ?? "",
            });
        }
    }

    const operationOutput = operations
        .map((operation) => {
            const { operationId, method, path, requiredParams, hasResponseBody } = operation;
            return `async ${operationId}(options${requiredParams ? "" : "?"}: FetchOptions<operations["${operationId}"]>) {
    const { ${hasResponseBody ? `data, ` : ``}error, response } = await this.client.${method}("${path}", options);
    if (error) {
        throw ApiClientError.fromError(response, error);
    }
    ${
        hasResponseBody
            ? `return data;
`
            : ``
    }}
`;
        })
        .join("\n");

    const templateFile = await fs.readFile(file as string, "utf8");
    const templateLines = templateFile.split("\n");
    const outputLines: string[] = [];
    let addLines = true;
    for (const line of templateLines) {
        if (line.includes("DO NOT EDIT. This is auto-generated code.")) {
            addLines = !addLines;
            outputLines.push(line);
            if (!addLines) {
                outputLines.push(operationOutput);
            }
            continue;
        }
        if (addLines) {
            outputLines.push(line);
        }
    }
    const output = outputLines.join("\n");

    await fs.writeFile(file as string, output, "utf8");
}

main().catch((error) => {
    console.error("Error:", error);
    process.exit(1);
});


## File: scripts/filter.ts

import { OpenAPIV3_1 } from "openapi-types";

async function readStdin() {
    return new Promise<string>((resolve, reject) => {
        let data = "";
        process.stdin.setEncoding("utf8");
        process.stdin.on("error", (err) => {
            reject(err);
        });
        process.stdin.on("data", (chunk) => {
            // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
            data += chunk;
        });
        process.stdin.on("end", () => {
            resolve(data);
        });
    });
}

function filterOpenapi(openapi: OpenAPIV3_1.Document): OpenAPIV3_1.Document {
    const allowedOperations = [
        "listProjects",
        "listOrganizations",
        "getProject",
        "createProject",
        "deleteProject",
        "listClusters",
        "listFlexClusters",
        "getCluster",
        "getFlexCluster",
        "createCluster",
        "createFlexCluster",
        "deleteCluster",
        "deleteFlexCluster",
        "listClustersForAllProjects",
        "createDatabaseUser",
        "deleteDatabaseUser",
        "listDatabaseUsers",
        "listProjectIpAccessLists",
        "createProjectIpAccessList",
        "deleteProjectIpAccessList",
        "listOrganizationProjects",
        "listAlerts",
    ];

    const filteredPaths = {};

    for (const path in openapi.paths) {
        const filteredMethods = {} as OpenAPIV3_1.PathItemObject;
        for (const method in openapi.paths[path]) {
            // @ts-expect-error This is a workaround for the OpenAPI types
            if (allowedOperations.includes((openapi.paths[path][method] as { operationId: string }).operationId)) {
                // @ts-expect-error This is a workaround for the OpenAPI types
                filteredMethods[method] = openapi.paths[path][method] as OpenAPIV3_1.OperationObject;
            }
        }
        if (Object.keys(filteredMethods).length > 0) {
            // @ts-expect-error This is a workaround for the OpenAPI types
            filteredPaths[path] = filteredMethods;
        }
    }

    return { ...openapi, paths: filteredPaths };
}

async function main() {
    const openapiText = await readStdin();
    const openapi = JSON.parse(openapiText) as OpenAPIV3_1.Document;
    const filteredOpenapi = filterOpenapi(openapi);
    console.log(JSON.stringify(filteredOpenapi));
}

main().catch((error) => {
    console.error("Error:", error);
    process.exit(1);
});


## File: src/config.ts

import path from "path";
import os from "os";
import argv from "yargs-parser";

import { ReadConcernLevel, ReadPreferenceMode, W } from "mongodb";

export interface ConnectOptions {
    readConcern: ReadConcernLevel;
    readPreference: ReadPreferenceMode;
    writeConcern: W;
    timeoutMS: number;
}

// If we decide to support non-string config options, we'll need to extend the mechanism for parsing
// env variables.
export interface UserConfig {
    apiBaseUrl: string;
    apiClientId?: string;
    apiClientSecret?: string;
    telemetry?: "enabled" | "disabled";
    logPath: string;
    connectionString?: string;
    connectOptions: ConnectOptions;
    disabledTools: Array<string>;
    readOnly?: boolean;
}

const defaults: UserConfig = {
    apiBaseUrl: "https://cloud.mongodb.com/",
    logPath: getLogPath(),
    connectOptions: {
        readConcern: "local",
        readPreference: "secondaryPreferred",
        writeConcern: "majority",
        timeoutMS: 30_000,
    },
    disabledTools: [],
    telemetry: "enabled",
    readOnly: false,
};

export const config = {
    ...defaults,
    ...getEnvConfig(),
    ...getCliConfig(),
};

function getLogPath(): string {
    const localDataPath =
        process.platform === "win32"
            ? path.join(process.env.LOCALAPPDATA || process.env.APPDATA || os.homedir(), "mongodb")
            : path.join(os.homedir(), ".mongodb");

    const logPath = path.join(localDataPath, "mongodb-mcp", ".app-logs");

    return logPath;
}

// Gets the config supplied by the user as environment variables. The variable names
// are prefixed with `MDB_MCP_` and the keys match the UserConfig keys, but are converted
// to SNAKE_UPPER_CASE.
function getEnvConfig(): Partial<UserConfig> {
    function setValue(obj: Record<string, unknown>, path: string[], value: string): void {
        const currentField = path.shift();
        if (!currentField) {
            return;
        }
        if (path.length === 0) {
            const numberValue = Number(value);
            if (!isNaN(numberValue)) {
                obj[currentField] = numberValue;
                return;
            }

            const booleanValue = value.toLocaleLowerCase();
            if (booleanValue === "true" || booleanValue === "false") {
                obj[currentField] = booleanValue === "true";
                return;
            }

            // Try to parse an array of values
            if (value.indexOf(",") !== -1) {
                obj[currentField] = value.split(",").map((v) => v.trim());
                return;
            }

            obj[currentField] = value;
            return;
        }

        if (!obj[currentField]) {
            obj[currentField] = {};
        }

        setValue(obj[currentField] as Record<string, unknown>, path, value);
    }

    const result: Record<string, unknown> = {};
    const mcpVariables = Object.entries(process.env).filter(
        ([key, value]) => value !== undefined && key.startsWith("MDB_MCP_")
    ) as [string, string][];
    for (const [key, value] of mcpVariables) {
        const fieldPath = key
            .replace("MDB_MCP_", "")
            .split(".")
            .map((part) => SNAKE_CASE_toCamelCase(part));

        setValue(result, fieldPath, value);
    }

    return result;
}

function SNAKE_CASE_toCamelCase(str: string): string {
    return str.toLowerCase().replace(/([-_][a-z])/g, (group) => group.toUpperCase().replace("_", ""));
}

// Reads the cli args and parses them into a UserConfig object.
function getCliConfig() {
    return argv(process.argv.slice(2), {
        array: ["disabledTools"],
    }) as unknown as Partial<UserConfig>;
}


## File: src/errors.ts

export enum ErrorCodes {
    NotConnectedToMongoDB = 1_000_000,
    MisconfiguredConnectionString = 1_000_001,
}

export class MongoDBError extends Error {
    constructor(
        public code: ErrorCodes,
        message: string
    ) {
        super(message);
    }
}


## File: src/index.ts

#!/usr/bin/env node

import logger, { LogId } from "./logger.js";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { config } from "./config.js";
import { Session } from "./session.js";
import { Server } from "./server.js";
import { packageInfo } from "./helpers/packageInfo.js";
import { Telemetry } from "./telemetry/telemetry.js";
import { createEJsonTransport } from "./helpers/EJsonTransport.js";

try {
    const session = new Session({
        apiBaseUrl: config.apiBaseUrl,
        apiClientId: config.apiClientId,
        apiClientSecret: config.apiClientSecret,
    });
    const mcpServer = new McpServer({
        name: packageInfo.mcpServerName,
        version: packageInfo.version,
    });

    const telemetry = Telemetry.create(session, config);

    const server = new Server({
        mcpServer,
        session,
        telemetry,
        userConfig: config,
    });

    const transport = createEJsonTransport();

    process.on("SIGINT", () => {
        logger.info(LogId.serverCloseRequested, "server", `Server close requested`);

        server
            .close()
            .then(() => {
                logger.info(LogId.serverClosed, "server", `Server closed successfully`);
                process.exit(0);
            })
            .catch((err: unknown) => {
                const error = err instanceof Error ? err : new Error(String(err));
                logger.error(LogId.serverCloseFailure, "server", `Error closing server: ${error.message}`);
                process.exit(1);
            });
    });

    await server.connect(transport);
} catch (error: unknown) {
    logger.emergency(LogId.serverStartFailure, "server", `Fatal error running server: ${error as string}`);
    process.exit(1);
}


## File: src/logger.ts

import fs from "fs/promises";
import { mongoLogId, MongoLogId, MongoLogManager, MongoLogWriter } from "mongodb-log-writer";
import redact from "mongodb-redact";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { LoggingMessageNotification } from "@modelcontextprotocol/sdk/types.js";

export type LogLevel = LoggingMessageNotification["params"]["level"];

export const LogId = {
    serverStartFailure: mongoLogId(1_000_001),
    serverInitialized: mongoLogId(1_000_002),
    serverCloseRequested: mongoLogId(1_000_003),
    serverClosed: mongoLogId(1_000_004),
    serverCloseFailure: mongoLogId(1_000_005),

    atlasCheckCredentials: mongoLogId(1_001_001),
    atlasDeleteDatabaseUserFailure: mongoLogId(1_001_002),
    atlasConnectFailure: mongoLogId(1_001_003),
    atlasInspectFailure: mongoLogId(1_001_004),

    telemetryDisabled: mongoLogId(1_002_001),
    telemetryEmitFailure: mongoLogId(1_002_002),
    telemetryEmitStart: mongoLogId(1_002_003),
    telemetryEmitSuccess: mongoLogId(1_002_004),
    telemetryMetadataError: mongoLogId(1_002_005),
    telemetryDeviceIdFailure: mongoLogId(1_002_006),
    telemetryDeviceIdTimeout: mongoLogId(1_002_007),

    toolExecute: mongoLogId(1_003_001),
    toolExecuteFailure: mongoLogId(1_003_002),
    toolDisabled: mongoLogId(1_003_003),

    mongodbConnectFailure: mongoLogId(1_004_001),
    mongodbDisconnectFailure: mongoLogId(1_004_002),

    toolUpdateFailure: mongoLogId(1_005_001),
} as const;

abstract class LoggerBase {
    abstract log(level: LogLevel, id: MongoLogId, context: string, message: string): void;

    info(id: MongoLogId, context: string, message: string): void {
        this.log("info", id, context, message);
    }

    error(id: MongoLogId, context: string, message: string): void {
        this.log("error", id, context, message);
    }
    debug(id: MongoLogId, context: string, message: string): void {
        this.log("debug", id, context, message);
    }

    notice(id: MongoLogId, context: string, message: string): void {
        this.log("notice", id, context, message);
    }

    warning(id: MongoLogId, context: string, message: string): void {
        this.log("warning", id, context, message);
    }

    critical(id: MongoLogId, context: string, message: string): void {
        this.log("critical", id, context, message);
    }

    alert(id: MongoLogId, context: string, message: string): void {
        this.log("alert", id, context, message);
    }

    emergency(id: MongoLogId, context: string, message: string): void {
        this.log("emergency", id, context, message);
    }
}

class ConsoleLogger extends LoggerBase {
    log(level: LogLevel, id: MongoLogId, context: string, message: string): void {
        message = redact(message);
        console.error(`[${level.toUpperCase()}] ${id.__value} - ${context}: ${message}`);
    }
}

class DiskLogger extends LoggerBase {
    private constructor(private logWriter: MongoLogWriter) {
        super();
    }

    static async fromPath(logPath: string): Promise<DiskLogger> {
        await fs.mkdir(logPath, { recursive: true });

        const manager = new MongoLogManager({
            directory: logPath,
            retentionDays: 30,
            onwarn: console.warn,
            onerror: console.error,
            gzip: false,
            retentionGB: 1,
        });

        await manager.cleanupOldLogFiles();

        const logWriter = await manager.createLogWriter();

        return new DiskLogger(logWriter);
    }

    log(level: LogLevel, id: MongoLogId, context: string, message: string): void {
        message = redact(message);
        const mongoDBLevel = this.mapToMongoDBLogLevel(level);

        this.logWriter[mongoDBLevel]("MONGODB-MCP", id, context, message);
    }

    private mapToMongoDBLogLevel(level: LogLevel): "info" | "warn" | "error" | "debug" | "fatal" {
        switch (level) {
            case "info":
                return "info";
            case "warning":
                return "warn";
            case "error":
                return "error";
            case "notice":
            case "debug":
                return "debug";
            case "critical":
            case "alert":
            case "emergency":
                return "fatal";
            default:
                return "info";
        }
    }
}

class McpLogger extends LoggerBase {
    constructor(private server: McpServer) {
        super();
    }

    log(level: LogLevel, _: MongoLogId, context: string, message: string): void {
        // Only log if the server is connected
        if (!this.server?.isConnected()) {
            return;
        }

        void this.server.server.sendLoggingMessage({
            level,
            data: `[${context}]: ${message}`,
        });
    }
}

class CompositeLogger extends LoggerBase {
    private loggers: LoggerBase[];

    constructor(...loggers: LoggerBase[]) {
        super();

        if (loggers.length === 0) {
            // default to ConsoleLogger
            this.loggers = [new ConsoleLogger()];
            return;
        }

        this.loggers = [...loggers];
    }

    setLoggers(...loggers: LoggerBase[]): void {
        if (loggers.length === 0) {
            throw new Error("At least one logger must be provided");
        }
        this.loggers = [...loggers];
    }

    log(level: LogLevel, id: MongoLogId, context: string, message: string): void {
        for (const logger of this.loggers) {
            logger.log(level, id, context, message);
        }
    }
}

const logger = new CompositeLogger();
export default logger;

export async function initializeLogger(server: McpServer, logPath: string): Promise<LoggerBase> {
    const diskLogger = await DiskLogger.fromPath(logPath);
    const mcpLogger = new McpLogger(server);

    logger.setLoggers(mcpLogger, diskLogger);

    return logger;
}


## File: src/server.ts

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { Session } from "./session.js";
import { Transport } from "@modelcontextprotocol/sdk/shared/transport.js";
import { AtlasTools } from "./tools/atlas/tools.js";
import { MongoDbTools } from "./tools/mongodb/tools.js";
import logger, { initializeLogger, LogId } from "./logger.js";
import { ObjectId } from "mongodb";
import { Telemetry } from "./telemetry/telemetry.js";
import { UserConfig } from "./config.js";
import { type ServerEvent } from "./telemetry/types.js";
import { type ServerCommand } from "./telemetry/types.js";
import { CallToolRequestSchema, CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import assert from "assert";

export interface ServerOptions {
    session: Session;
    userConfig: UserConfig;
    mcpServer: McpServer;
    telemetry: Telemetry;
}

export class Server {
    public readonly session: Session;
    private readonly mcpServer: McpServer;
    private readonly telemetry: Telemetry;
    public readonly userConfig: UserConfig;
    private readonly startTime: number;

    constructor({ session, mcpServer, userConfig, telemetry }: ServerOptions) {
        this.startTime = Date.now();
        this.session = session;
        this.telemetry = telemetry;
        this.mcpServer = mcpServer;
        this.userConfig = userConfig;
    }

    async connect(transport: Transport): Promise<void> {
        this.mcpServer.server.registerCapabilities({ logging: {} });

        this.registerTools();
        this.registerResources();

        // This is a workaround for an issue we've seen with some models, where they'll see that everything in the `arguments`
        // object is optional, and then not pass it at all. However, the MCP server expects the `arguments` object to be if
        // the tool accepts any arguments, even if they're all optional.
        //
        // see: https://github.com/modelcontextprotocol/typescript-sdk/blob/131776764536b5fdca642df51230a3746fb4ade0/src/server/mcp.ts#L705
        // Since paramsSchema here is not undefined, the server will create a non-optional z.object from it.
        const existingHandler = (
            this.mcpServer.server["_requestHandlers"] as Map<
                string,
                (request: unknown, extra: unknown) => Promise<CallToolResult>
            >
        ).get(CallToolRequestSchema.shape.method.value);

        assert(existingHandler, "No existing handler found for CallToolRequestSchema");

        this.mcpServer.server.setRequestHandler(CallToolRequestSchema, (request, extra): Promise<CallToolResult> => {
            if (!request.params.arguments) {
                request.params.arguments = {};
            }

            return existingHandler(request, extra);
        });

        await initializeLogger(this.mcpServer, this.userConfig.logPath);

        await this.mcpServer.connect(transport);

        this.mcpServer.server.oninitialized = () => {
            this.session.setAgentRunner(this.mcpServer.server.getClientVersion());
            this.session.sessionId = new ObjectId().toString();

            logger.info(
                LogId.serverInitialized,
                "server",
                `Server started with transport ${transport.constructor.name} and agent runner ${this.session.agentRunner?.name}`
            );

            this.emitServerEvent("start", Date.now() - this.startTime);
        };

        this.mcpServer.server.onclose = () => {
            const closeTime = Date.now();
            this.emitServerEvent("stop", Date.now() - closeTime);
        };

        this.mcpServer.server.onerror = (error: Error) => {
            const closeTime = Date.now();
            this.emitServerEvent("stop", Date.now() - closeTime, error);
        };

        await this.validateConfig();
    }

    async close(): Promise<void> {
        await this.telemetry.close();
        await this.session.close();
        await this.mcpServer.close();
    }

    /**
     * Emits a server event
     * @param command - The server command (e.g., "start", "stop", "register", "deregister")
     * @param additionalProperties - Additional properties specific to the event
     */
    private emitServerEvent(command: ServerCommand, commandDuration: number, error?: Error) {
        const event: ServerEvent = {
            timestamp: new Date().toISOString(),
            source: "mdbmcp",
            properties: {
                result: "success",
                duration_ms: commandDuration,
                component: "server",
                category: "other",
                command: command,
            },
        };

        if (command === "start") {
            event.properties.startup_time_ms = commandDuration;
            event.properties.read_only_mode = this.userConfig.readOnly || false;
            event.properties.disabled_tools = this.userConfig.disabledTools || [];
        }
        if (command === "stop") {
            event.properties.runtime_duration_ms = Date.now() - this.startTime;
            if (error) {
                event.properties.result = "failure";
                event.properties.reason = error.message;
            }
        }

        this.telemetry.emitEvents([event]).catch(() => {});
    }

    private registerTools() {
        for (const tool of [...AtlasTools, ...MongoDbTools]) {
            new tool(this.session, this.userConfig, this.telemetry).register(this.mcpServer);
        }
    }

    private registerResources() {
        this.mcpServer.resource(
            "config",
            "config://config",
            {
                description:
                    "Server configuration, supplied by the user either as environment variables or as startup arguments",
            },
            (uri) => {
                const result = {
                    telemetry: this.userConfig.telemetry,
                    logPath: this.userConfig.logPath,
                    connectionString: this.userConfig.connectionString
                        ? "set; access to MongoDB tools are currently available to use"
                        : "not set; before using any MongoDB tool, you need to configure a connection string, alternatively you can setup MongoDB Atlas access, more info at 'https://github.com/mongodb-js/mongodb-mcp-server'.",
                    connectOptions: this.userConfig.connectOptions,
                    atlas:
                        this.userConfig.apiClientId && this.userConfig.apiClientSecret
                            ? "set; MongoDB Atlas tools are currently available to use"
                            : "not set; MongoDB Atlas tools are currently unavailable, to have access to MongoDB Atlas tools like creating clusters or connecting to clusters make sure to setup credentials, more info at 'https://github.com/mongodb-js/mongodb-mcp-server'.",
                };
                return {
                    contents: [
                        {
                            text: JSON.stringify(result),
                            mimeType: "application/json",
                            uri: uri.href,
                        },
                    ],
                };
            }
        );
    }

    private async validateConfig(): Promise<void> {
        if (this.userConfig.connectionString) {
            try {
                await this.session.connectToMongoDB(this.userConfig.connectionString, this.userConfig.connectOptions);
            } catch (error) {
                console.error(
                    "Failed to connect to MongoDB instance using the connection string from the config: ",
                    error
                );
                throw new Error("Failed to connect to MongoDB instance using the connection string from the config");
            }
        }

        if (this.userConfig.apiClientId && this.userConfig.apiClientSecret) {
            try {
                await this.session.apiClient.validateAccessToken();
            } catch (error) {
                if (this.userConfig.connectionString === undefined) {
                    console.error("Failed to validate MongoDB Atlas the credentials from the config: ", error);

                    throw new Error(
                        "Failed to connect to MongoDB Atlas instance using the credentials from the config"
                    );
                }
                console.error(
                    "Failed to validate MongoDB Atlas the credentials from the config, but validated the connection string."
                );
            }
        }
    }
}


## File: src/session.ts

import { NodeDriverServiceProvider } from "@mongosh/service-provider-node-driver";
import { ApiClient, ApiClientCredentials } from "./common/atlas/apiClient.js";
import { Implementation } from "@modelcontextprotocol/sdk/types.js";
import logger, { LogId } from "./logger.js";
import EventEmitter from "events";
import { ConnectOptions } from "./config.js";
import { setAppNameParamIfMissing } from "./helpers/connectionOptions.js";
import { packageInfo } from "./helpers/packageInfo.js";

export interface SessionOptions {
    apiBaseUrl: string;
    apiClientId?: string;
    apiClientSecret?: string;
}

export class Session extends EventEmitter<{
    close: [];
    disconnect: [];
}> {
    sessionId?: string;
    serviceProvider?: NodeDriverServiceProvider;
    apiClient: ApiClient;
    agentRunner?: {
        name: string;
        version: string;
    };
    connectedAtlasCluster?: {
        username: string;
        projectId: string;
        clusterName: string;
        expiryDate: Date;
    };

    constructor({ apiBaseUrl, apiClientId, apiClientSecret }: SessionOptions) {
        super();

        const credentials: ApiClientCredentials | undefined =
            apiClientId && apiClientSecret
                ? {
                      clientId: apiClientId,
                      clientSecret: apiClientSecret,
                  }
                : undefined;

        this.apiClient = new ApiClient({
            baseUrl: apiBaseUrl,
            credentials,
        });
    }

    setAgentRunner(agentRunner: Implementation | undefined) {
        if (agentRunner?.name && agentRunner?.version) {
            this.agentRunner = {
                name: agentRunner.name,
                version: agentRunner.version,
            };
        }
    }

    async disconnect(): Promise<void> {
        if (this.serviceProvider) {
            try {
                await this.serviceProvider.close(true);
            } catch (err: unknown) {
                const error = err instanceof Error ? err : new Error(String(err));
                logger.error(LogId.mongodbDisconnectFailure, "Error closing service provider:", error.message);
            }
            this.serviceProvider = undefined;
        }
        if (!this.connectedAtlasCluster) {
            this.emit("disconnect");
            return;
        }
        void this.apiClient
            .deleteDatabaseUser({
                params: {
                    path: {
                        groupId: this.connectedAtlasCluster.projectId,
                        username: this.connectedAtlasCluster.username,
                        databaseName: "admin",
                    },
                },
            })
            .catch((err: unknown) => {
                const error = err instanceof Error ? err : new Error(String(err));
                logger.error(
                    LogId.atlasDeleteDatabaseUserFailure,
                    "atlas-connect-cluster",
                    `Error deleting previous database user: ${error.message}`
                );
            });
        this.connectedAtlasCluster = undefined;

        this.emit("disconnect");
    }

    async close(): Promise<void> {
        await this.disconnect();
        this.emit("close");
    }

    async connectToMongoDB(connectionString: string, connectOptions: ConnectOptions): Promise<void> {
        connectionString = setAppNameParamIfMissing({
            connectionString,
            defaultAppName: `${packageInfo.mcpServerName} ${packageInfo.version}`,
        });
        this.serviceProvider = await NodeDriverServiceProvider.connect(connectionString, {
            productDocsLink: "https://github.com/mongodb-js/mongodb-mcp-server/",
            productName: "MongoDB MCP",
            readConcern: {
                level: connectOptions.readConcern,
            },
            readPreference: connectOptions.readPreference,
            writeConcern: {
                w: connectOptions.writeConcern,
            },
            timeoutMS: connectOptions.timeoutMS,
        });
    }
}


## File: src/helpers/EJsonTransport.ts

import { JSONRPCMessage, JSONRPCMessageSchema } from "@modelcontextprotocol/sdk/types.js";
import { EJSON } from "bson";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";

// This is almost a copy of ReadBuffer from @modelcontextprotocol/sdk
// but it uses EJSON.parse instead of JSON.parse to handle BSON types
export class EJsonReadBuffer {
    private _buffer?: Buffer;

    append(chunk: Buffer): void {
        this._buffer = this._buffer ? Buffer.concat([this._buffer, chunk]) : chunk;
    }

    readMessage(): JSONRPCMessage | null {
        if (!this._buffer) {
            return null;
        }

        const index = this._buffer.indexOf("\n");
        if (index === -1) {
            return null;
        }

        const line = this._buffer.toString("utf8", 0, index).replace(/\r$/, "");
        this._buffer = this._buffer.subarray(index + 1);

        // This is using EJSON.parse instead of JSON.parse to handle BSON types
        return JSONRPCMessageSchema.parse(EJSON.parse(line));
    }

    clear(): void {
        this._buffer = undefined;
    }
}

// This is a hacky workaround for https://github.com/mongodb-js/mongodb-mcp-server/issues/211
// The underlying issue is that StdioServerTransport uses JSON.parse to deserialize
// messages, but that doesn't handle bson types, such as ObjectId when serialized as EJSON.
//
// This function creates a StdioServerTransport and replaces the internal readBuffer with EJsonReadBuffer
// that uses EJson.parse instead.
export function createEJsonTransport(): StdioServerTransport {
    const server = new StdioServerTransport();
    server["_readBuffer"] = new EJsonReadBuffer();

    return server;
}


## File: src/helpers/connectionOptions.ts

import { MongoClientOptions } from "mongodb";
import ConnectionString from "mongodb-connection-string-url";

export function setAppNameParamIfMissing({
    connectionString,
    defaultAppName,
}: {
    connectionString: string;
    defaultAppName?: string;
}): string {
    const connectionStringUrl = new ConnectionString(connectionString);

    const searchParams = connectionStringUrl.typedSearchParams<MongoClientOptions>();

    if (!searchParams.has("appName") && defaultAppName !== undefined) {
        searchParams.set("appName", defaultAppName);
    }

    return connectionStringUrl.toString();
}


## File: src/helpers/packageInfo.ts

import packageJson from "../../package.json" with { type: "json" };

export const packageInfo = {
    version: packageJson.version,
    mcpServerName: "MongoDB MCP Server",
};


## File: src/tools/tool.ts

import { z, type ZodRawShape, type ZodNever, AnyZodObject } from "zod";
import type { McpServer, RegisteredTool, ToolCallback } from "@modelcontextprotocol/sdk/server/mcp.js";
import type { CallToolResult, ToolAnnotations } from "@modelcontextprotocol/sdk/types.js";
import { Session } from "../session.js";
import logger, { LogId } from "../logger.js";
import { Telemetry } from "../telemetry/telemetry.js";
import { type ToolEvent } from "../telemetry/types.js";
import { UserConfig } from "../config.js";

export type ToolArgs<Args extends ZodRawShape> = z.objectOutputType<Args, ZodNever>;

export type OperationType = "metadata" | "read" | "create" | "delete" | "update";
export type ToolCategory = "mongodb" | "atlas";
export type TelemetryToolMetadata = {
    projectId?: string;
    orgId?: string;
};

export abstract class ToolBase {
    protected abstract name: string;

    protected abstract category: ToolCategory;

    protected abstract operationType: OperationType;

    protected abstract description: string;

    protected abstract argsShape: ZodRawShape;

    protected get annotations(): ToolAnnotations {
        const annotations: ToolAnnotations = {
            title: this.name,
            description: this.description,
        };

        switch (this.operationType) {
            case "read":
            case "metadata":
                annotations.readOnlyHint = true;
                annotations.destructiveHint = false;
                break;
            case "delete":
                annotations.readOnlyHint = false;
                annotations.destructiveHint = true;
                break;
            case "create":
            case "update":
                annotations.destructiveHint = false;
                annotations.readOnlyHint = false;
                break;
            default:
                break;
        }

        return annotations;
    }

    protected abstract execute(...args: Parameters<ToolCallback<typeof this.argsShape>>): Promise<CallToolResult>;

    constructor(
        protected readonly session: Session,
        protected readonly config: UserConfig,
        protected readonly telemetry: Telemetry
    ) {}

    public register(server: McpServer): void {
        if (!this.verifyAllowed()) {
            return;
        }

        const callback: ToolCallback<typeof this.argsShape> = async (...args) => {
            const startTime = Date.now();
            try {
                logger.debug(LogId.toolExecute, "tool", `Executing ${this.name} with args: ${JSON.stringify(args)}`);

                const result = await this.execute(...args);
                await this.emitToolEvent(startTime, result, ...args).catch(() => {});
                return result;
            } catch (error: unknown) {
                logger.error(LogId.toolExecuteFailure, "tool", `Error executing ${this.name}: ${error as string}`);
                const toolResult = await this.handleError(error, args[0] as ToolArgs<typeof this.argsShape>);
                await this.emitToolEvent(startTime, toolResult, ...args).catch(() => {});
                return toolResult;
            }
        };

        server.tool(this.name, this.description, this.argsShape, this.annotations, callback);

        // This is very similar to RegisteredTool.update, but without the bugs around the name.
        // In the upstream update method, the name is captured in the closure and not updated when
        // the tool name changes. This means that you only get one name update before things end up
        // in a broken state.
        this.update = (updates: { name?: string; description?: string; inputSchema?: AnyZodObject }) => {
            const tools = server["_registeredTools"] as { [toolName: string]: RegisteredTool };
            const existingTool = tools[this.name];

            if (!existingTool) {
                logger.warning(LogId.toolUpdateFailure, "tool", `Tool ${this.name} not found in update`);
                return;
            }

            existingTool.annotations = this.annotations;

            if (updates.name && updates.name !== this.name) {
                existingTool.annotations.title = updates.name;
                delete tools[this.name];
                this.name = updates.name;
                tools[this.name] = existingTool;
            }

            if (updates.description) {
                existingTool.annotations.description = updates.description;
                existingTool.description = updates.description;
                this.description = updates.description;
            }

            if (updates.inputSchema) {
                existingTool.inputSchema = updates.inputSchema;
            }

            server.sendToolListChanged();
        };
    }

    protected update?: (updates: { name?: string; description?: string; inputSchema?: AnyZodObject }) => void;

    // Checks if a tool is allowed to run based on the config
    protected verifyAllowed(): boolean {
        let errorClarification: string | undefined;

        // Check read-only mode first
        if (this.config.readOnly && !["read", "metadata"].includes(this.operationType)) {
            errorClarification = `read-only mode is enabled, its operation type, \`${this.operationType}\`,`;
        } else if (this.config.disabledTools.includes(this.category)) {
            errorClarification = `its category, \`${this.category}\`,`;
        } else if (this.config.disabledTools.includes(this.operationType)) {
            errorClarification = `its operation type, \`${this.operationType}\`,`;
        } else if (this.config.disabledTools.includes(this.name)) {
            errorClarification = `it`;
        }

        if (errorClarification) {
            logger.debug(
                LogId.toolDisabled,
                "tool",
                `Prevented registration of ${this.name} because ${errorClarification} is disabled in the config`
            );

            return false;
        }

        return true;
    }

    // This method is intended to be overridden by subclasses to handle errors
    protected handleError(
        error: unknown,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        args: ToolArgs<typeof this.argsShape>
    ): Promise<CallToolResult> | CallToolResult {
        return {
            content: [
                {
                    type: "text",
                    text: `Error running ${this.name}: ${error instanceof Error ? error.message : String(error)}`,
                },
            ],
            isError: true,
        };
    }

    protected abstract resolveTelemetryMetadata(
        ...args: Parameters<ToolCallback<typeof this.argsShape>>
    ): TelemetryToolMetadata;

    /**
     * Creates and emits a tool telemetry event
     * @param startTime - Start time in milliseconds
     * @param result - Whether the command succeeded or failed
     * @param args - The arguments passed to the tool
     */
    private async emitToolEvent(
        startTime: number,
        result: CallToolResult,
        ...args: Parameters<ToolCallback<typeof this.argsShape>>
    ): Promise<void> {
        if (!this.telemetry.isTelemetryEnabled()) {
            return;
        }
        const duration = Date.now() - startTime;
        const metadata = this.resolveTelemetryMetadata(...args);
        const event: ToolEvent = {
            timestamp: new Date().toISOString(),
            source: "mdbmcp",
            properties: {
                command: this.name,
                category: this.category,
                component: "tool",
                duration_ms: duration,
                result: result.isError ? "failure" : "success",
            },
        };

        if (metadata?.orgId) {
            event.properties.org_id = metadata.orgId;
        }

        if (metadata?.projectId) {
            event.properties.project_id = metadata.projectId;
        }

        await this.telemetry.emitEvents([event]);
    }
}


## File: src/tools/mongodb/mongodbTool.ts

import { z } from "zod";
import { ToolArgs, ToolBase, ToolCategory, TelemetryToolMetadata } from "../tool.js";
import { NodeDriverServiceProvider } from "@mongosh/service-provider-node-driver";
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { ErrorCodes, MongoDBError } from "../../errors.js";
import logger, { LogId } from "../../logger.js";

export const DbOperationArgs = {
    database: z.string().describe("Database name"),
    collection: z.string().describe("Collection name"),
};

export abstract class MongoDBToolBase extends ToolBase {
    protected category: ToolCategory = "mongodb";

    protected async ensureConnected(): Promise<NodeDriverServiceProvider> {
        if (!this.session.serviceProvider && this.config.connectionString) {
            try {
                await this.connectToMongoDB(this.config.connectionString);
            } catch (error) {
                logger.error(
                    LogId.mongodbConnectFailure,
                    "mongodbTool",
                    `Failed to connect to MongoDB instance using the connection string from the config: ${error as string}`
                );
                throw new MongoDBError(ErrorCodes.MisconfiguredConnectionString, "Not connected to MongoDB.");
            }
        }

        if (!this.session.serviceProvider) {
            throw new MongoDBError(ErrorCodes.NotConnectedToMongoDB, "Not connected to MongoDB");
        }

        return this.session.serviceProvider;
    }

    protected handleError(
        error: unknown,
        args: ToolArgs<typeof this.argsShape>
    ): Promise<CallToolResult> | CallToolResult {
        if (error instanceof MongoDBError) {
            switch (error.code) {
                case ErrorCodes.NotConnectedToMongoDB:
                    return {
                        content: [
                            {
                                type: "text",
                                text: "You need to connect to a MongoDB instance before you can access its data.",
                            },
                            {
                                type: "text",
                                text: "Please use the 'connect' or 'switch-connection' tool to connect to a MongoDB instance.",
                            },
                        ],
                        isError: true,
                    };
                case ErrorCodes.MisconfiguredConnectionString:
                    return {
                        content: [
                            {
                                type: "text",
                                text: "The configured connection string is not valid. Please check the connection string and confirm it points to a valid MongoDB instance. Alternatively, use the 'switch-connection' tool to connect to a different instance.",
                            },
                        ],
                        isError: true,
                    };
            }
        }

        return super.handleError(error, args);
    }

    protected connectToMongoDB(connectionString: string): Promise<void> {
        return this.session.connectToMongoDB(connectionString, this.config.connectOptions);
    }

    protected resolveTelemetryMetadata(
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        args: ToolArgs<typeof this.argsShape>
    ): TelemetryToolMetadata {
        const metadata: TelemetryToolMetadata = {};

        // Add projectId to the metadata if running a MongoDB operation to an Atlas cluster
        if (this.session.connectedAtlasCluster?.projectId) {
            metadata.projectId = this.session.connectedAtlasCluster.projectId;
        }

        return metadata;
    }
}


## File: src/tools/mongodb/tools.ts

import { ConnectTool } from "./metadata/connect.js";
import { ListCollectionsTool } from "./metadata/listCollections.js";
import { CollectionIndexesTool } from "./read/collectionIndexes.js";
import { ListDatabasesTool } from "./metadata/listDatabases.js";
import { CreateIndexTool } from "./create/createIndex.js";
import { CollectionSchemaTool } from "./metadata/collectionSchema.js";
import { FindTool } from "./read/find.js";
import { InsertManyTool } from "./create/insertMany.js";
import { DeleteManyTool } from "./delete/deleteMany.js";
import { CollectionStorageSizeTool } from "./metadata/collectionStorageSize.js";
import { CountTool } from "./read/count.js";
import { DbStatsTool } from "./metadata/dbStats.js";
import { AggregateTool } from "./read/aggregate.js";
import { UpdateManyTool } from "./update/updateMany.js";
import { RenameCollectionTool } from "./update/renameCollection.js";
import { DropDatabaseTool } from "./delete/dropDatabase.js";
import { DropCollectionTool } from "./delete/dropCollection.js";
import { ExplainTool } from "./metadata/explain.js";
import { CreateCollectionTool } from "./create/createCollection.js";
import { LogsTool } from "./metadata/logs.js";

export const MongoDbTools = [
    ConnectTool,
    ListCollectionsTool,
    ListDatabasesTool,
    CollectionIndexesTool,
    CreateIndexTool,
    CollectionSchemaTool,
    FindTool,
    InsertManyTool,
    DeleteManyTool,
    CollectionStorageSizeTool,
    CountTool,
    DbStatsTool,
    AggregateTool,
    UpdateManyTool,
    RenameCollectionTool,
    DropDatabaseTool,
    DropCollectionTool,
    ExplainTool,
    CreateCollectionTool,
    LogsTool,
];


## File: src/tools/mongodb/delete/deleteMany.ts

import { z } from "zod";
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { DbOperationArgs, MongoDBToolBase } from "../mongodbTool.js";
import { ToolArgs, OperationType } from "../../tool.js";

export class DeleteManyTool extends MongoDBToolBase {
    protected name = "delete-many";
    protected description = "Removes all documents that match the filter from a MongoDB collection";
    protected argsShape = {
        ...DbOperationArgs,
        filter: z
            .record(z.string(), z.unknown())
            .optional()
            .describe(
                "The query filter, specifying the deletion criteria. Matches the syntax of the filter argument of db.collection.deleteMany()"
            ),
    };
    protected operationType: OperationType = "delete";

    protected async execute({
        database,
        collection,
        filter,
    }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        const provider = await this.ensureConnected();
        const result = await provider.deleteMany(database, collection, filter);

        return {
            content: [
                {
                    text: `Deleted \`${result.deletedCount}\` document(s) from collection "${collection}"`,
                    type: "text",
                },
            ],
        };
    }
}


## File: src/tools/mongodb/delete/dropCollection.ts

import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { DbOperationArgs, MongoDBToolBase } from "../mongodbTool.js";
import { ToolArgs, OperationType } from "../../tool.js";

export class DropCollectionTool extends MongoDBToolBase {
    protected name = "drop-collection";
    protected description =
        "Removes a collection or view from the database. The method also removes any indexes associated with the dropped collection.";
    protected argsShape = {
        ...DbOperationArgs,
    };
    protected operationType: OperationType = "delete";

    protected async execute({ database, collection }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        const provider = await this.ensureConnected();
        const result = await provider.dropCollection(database, collection);

        return {
            content: [
                {
                    text: `${result ? "Successfully dropped" : "Failed to drop"} collection "${collection}" from database "${database}"`,
                    type: "text",
                },
            ],
        };
    }
}


## File: src/tools/mongodb/delete/dropDatabase.ts

import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { DbOperationArgs, MongoDBToolBase } from "../mongodbTool.js";
import { ToolArgs, OperationType } from "../../tool.js";

export class DropDatabaseTool extends MongoDBToolBase {
    protected name = "drop-database";
    protected description = "Removes the specified database, deleting the associated data files";
    protected argsShape = {
        database: DbOperationArgs.database,
    };
    protected operationType: OperationType = "delete";

    protected async execute({ database }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        const provider = await this.ensureConnected();
        const result = await provider.dropDatabase(database);

        return {
            content: [
                {
                    text: `${result.ok ? "Successfully dropped" : "Failed to drop"} database "${database}"`,
                    type: "text",
                },
            ],
        };
    }
}


## File: src/tools/mongodb/update/renameCollection.ts

import { z } from "zod";
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { DbOperationArgs, MongoDBToolBase } from "../mongodbTool.js";
import { ToolArgs, OperationType } from "../../tool.js";

export class RenameCollectionTool extends MongoDBToolBase {
    protected name = "rename-collection";
    protected description = "Renames a collection in a MongoDB database";
    protected argsShape = {
        ...DbOperationArgs,
        newName: z.string().describe("The new name for the collection"),
        dropTarget: z.boolean().optional().default(false).describe("If true, drops the target collection if it exists"),
    };
    protected operationType: OperationType = "update";

    protected async execute({
        database,
        collection,
        newName,
        dropTarget,
    }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        const provider = await this.ensureConnected();
        const result = await provider.renameCollection(database, collection, newName, {
            dropTarget,
        });

        return {
            content: [
                {
                    text: `Collection "${collection}" renamed to "${result.collectionName}" in database "${database}".`,
                    type: "text",
                },
            ],
        };
    }

    protected handleError(
        error: unknown,
        args: ToolArgs<typeof this.argsShape>
    ): Promise<CallToolResult> | CallToolResult {
        if (error instanceof Error && "codeName" in error) {
            switch (error.codeName) {
                case "NamespaceNotFound":
                    return {
                        content: [
                            {
                                text: `Cannot rename "${args.database}.${args.collection}" because it doesn't exist.`,
                                type: "text",
                            },
                        ],
                    };
                case "NamespaceExists":
                    return {
                        content: [
                            {
                                text: `Cannot rename "${args.database}.${args.collection}" to "${args.newName}" because the target collection already exists. If you want to overwrite it, set the "dropTarget" argument to true.`,
                                type: "text",
                            },
                        ],
                    };
            }
        }

        return super.handleError(error, args);
    }
}


## File: src/tools/mongodb/update/updateMany.ts

import { z } from "zod";
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { DbOperationArgs, MongoDBToolBase } from "../mongodbTool.js";
import { ToolArgs, OperationType } from "../../tool.js";

export class UpdateManyTool extends MongoDBToolBase {
    protected name = "update-many";
    protected description = "Updates all documents that match the specified filter for a collection";
    protected argsShape = {
        ...DbOperationArgs,
        filter: z
            .record(z.string(), z.unknown())
            .optional()
            .describe(
                "The selection criteria for the update, matching the syntax of the filter argument of db.collection.updateOne()"
            ),
        update: z
            .record(z.string(), z.unknown())
            .describe("An update document describing the modifications to apply using update operator expressions"),
        upsert: z
            .boolean()
            .optional()
            .describe("Controls whether to insert a new document if no documents match the filter"),
    };
    protected operationType: OperationType = "update";

    protected async execute({
        database,
        collection,
        filter,
        update,
        upsert,
    }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        const provider = await this.ensureConnected();
        const result = await provider.updateMany(database, collection, filter, update, {
            upsert,
        });

        let message = "";
        if (result.matchedCount === 0 && result.modifiedCount === 0 && result.upsertedCount === 0) {
            message = "No documents matched the filter.";
        } else {
            message = `Matched ${result.matchedCount} document(s).`;
            if (result.modifiedCount > 0) {
                message += ` Modified ${result.modifiedCount} document(s).`;
            }
            if (result.upsertedCount > 0) {
                message += ` Upserted ${result.upsertedCount} document with id: ${result.upsertedId?.toString()}.`;
            }
        }

        return {
            content: [
                {
                    text: message,
                    type: "text",
                },
            ],
        };
    }
}


## File: src/tools/mongodb/read/aggregate.ts

import { z } from "zod";
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { DbOperationArgs, MongoDBToolBase } from "../mongodbTool.js";
import { ToolArgs, OperationType } from "../../tool.js";
import { EJSON } from "bson";

export const AggregateArgs = {
    pipeline: z.array(z.record(z.string(), z.unknown())).describe("An array of aggregation stages to execute"),
};

export class AggregateTool extends MongoDBToolBase {
    protected name = "aggregate";
    protected description = "Run an aggregation against a MongoDB collection";
    protected argsShape = {
        ...DbOperationArgs,
        ...AggregateArgs,
    };
    protected operationType: OperationType = "read";

    protected async execute({
        database,
        collection,
        pipeline,
    }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        const provider = await this.ensureConnected();
        const documents = await provider.aggregate(database, collection, pipeline).toArray();

        const content: Array<{ text: string; type: "text" }> = [
            {
                text: `Found ${documents.length} documents in the collection "${collection}":`,
                type: "text",
            },
            ...documents.map((doc) => {
                return {
                    text: EJSON.stringify(doc),
                    type: "text",
                } as { text: string; type: "text" };
            }),
        ];

        return {
            content,
        };
    }
}


## File: src/tools/mongodb/read/collectionIndexes.ts

import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { DbOperationArgs, MongoDBToolBase } from "../mongodbTool.js";
import { ToolArgs, OperationType } from "../../tool.js";

export class CollectionIndexesTool extends MongoDBToolBase {
    protected name = "collection-indexes";
    protected description = "Describe the indexes for a collection";
    protected argsShape = DbOperationArgs;
    protected operationType: OperationType = "read";

    protected async execute({ database, collection }: ToolArgs<typeof DbOperationArgs>): Promise<CallToolResult> {
        const provider = await this.ensureConnected();
        const indexes = await provider.getIndexes(database, collection);

        return {
            content: [
                {
                    text: `Found ${indexes.length} indexes in the collection "${collection}":`,
                    type: "text",
                },
                ...(indexes.map((indexDefinition) => {
                    return {
                        text: `Name "${indexDefinition.name}", definition: ${JSON.stringify(indexDefinition.key)}`,
                        type: "text",
                    };
                }) as { text: string; type: "text" }[]),
            ],
        };
    }

    protected handleError(
        error: unknown,
        args: ToolArgs<typeof this.argsShape>
    ): Promise<CallToolResult> | CallToolResult {
        if (error instanceof Error && "codeName" in error && error.codeName === "NamespaceNotFound") {
            return {
                content: [
                    {
                        text: `The indexes for "${args.database}.${args.collection}" cannot be determined because the collection does not exist.`,
                        type: "text",
                    },
                ],
            };
        }

        return super.handleError(error, args);
    }
}


## File: src/tools/mongodb/read/count.ts

import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { DbOperationArgs, MongoDBToolBase } from "../mongodbTool.js";
import { ToolArgs, OperationType } from "../../tool.js";
import { z } from "zod";

export const CountArgs = {
    query: z
        .record(z.string(), z.unknown())
        .optional()
        .describe(
            "A filter/query parameter. Allows users to filter the documents to count. Matches the syntax of the filter argument of db.collection.count()."
        ),
};

export class CountTool extends MongoDBToolBase {
    protected name = "count";
    protected description =
        "Gets the number of documents in a MongoDB collection using db.collection.count() and query as an optional filter parameter";
    protected argsShape = {
        ...DbOperationArgs,
        ...CountArgs,
    };

    protected operationType: OperationType = "read";

    protected async execute({ database, collection, query }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        const provider = await this.ensureConnected();
        const count = await provider.count(database, collection, query);

        return {
            content: [
                {
                    text: `Found ${count} documents in the collection "${collection}"`,
                    type: "text",
                },
            ],
        };
    }
}


## File: src/tools/mongodb/read/find.ts

import { z } from "zod";
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { DbOperationArgs, MongoDBToolBase } from "../mongodbTool.js";
import { ToolArgs, OperationType } from "../../tool.js";
import { SortDirection } from "mongodb";
import { EJSON } from "bson";

export const FindArgs = {
    filter: z
        .record(z.string(), z.unknown())
        .optional()
        .describe("The query filter, matching the syntax of the query argument of db.collection.find()"),
    projection: z
        .record(z.string(), z.unknown())
        .optional()
        .describe("The projection, matching the syntax of the projection argument of db.collection.find()"),
    limit: z.number().optional().default(10).describe("The maximum number of documents to return"),
    sort: z
        .record(z.string(), z.custom<SortDirection>())
        .optional()
        .describe("A document, describing the sort order, matching the syntax of the sort argument of cursor.sort()"),
};

export class FindTool extends MongoDBToolBase {
    protected name = "find";
    protected description = "Run a find query against a MongoDB collection";
    protected argsShape = {
        ...DbOperationArgs,
        ...FindArgs,
    };
    protected operationType: OperationType = "read";

    protected async execute({
        database,
        collection,
        filter,
        projection,
        limit,
        sort,
    }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        const provider = await this.ensureConnected();
        const documents = await provider.find(database, collection, filter, { projection, limit, sort }).toArray();

        const content: Array<{ text: string; type: "text" }> = [
            {
                text: `Found ${documents.length} documents in the collection "${collection}":`,
                type: "text",
            },
            ...documents.map((doc) => {
                return {
                    text: EJSON.stringify(doc),
                    type: "text",
                } as { text: string; type: "text" };
            }),
        ];

        return {
            content,
        };
    }
}


## File: src/tools/mongodb/metadata/collectionSchema.ts

import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { DbOperationArgs, MongoDBToolBase } from "../mongodbTool.js";
import { ToolArgs, OperationType } from "../../tool.js";
import { getSimplifiedSchema } from "mongodb-schema";

export class CollectionSchemaTool extends MongoDBToolBase {
    protected name = "collection-schema";
    protected description = "Describe the schema for a collection";
    protected argsShape = DbOperationArgs;

    protected operationType: OperationType = "metadata";

    protected async execute({ database, collection }: ToolArgs<typeof DbOperationArgs>): Promise<CallToolResult> {
        const provider = await this.ensureConnected();
        const documents = await provider.find(database, collection, {}, { limit: 5 }).toArray();
        const schema = await getSimplifiedSchema(documents);

        const fieldsCount = Object.entries(schema).length;
        if (fieldsCount === 0) {
            return {
                content: [
                    {
                        text: `Could not deduce the schema for "${database}.${collection}". This may be because it doesn't exist or is empty.`,
                        type: "text",
                    },
                ],
            };
        }

        return {
            content: [
                {
                    text: `Found ${fieldsCount} fields in the schema for "${database}.${collection}"`,
                    type: "text",
                },
                {
                    text: JSON.stringify(schema),
                    type: "text",
                },
            ],
        };
    }
}


## File: src/tools/mongodb/metadata/collectionStorageSize.ts

import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { DbOperationArgs, MongoDBToolBase } from "../mongodbTool.js";
import { ToolArgs, OperationType } from "../../tool.js";

export class CollectionStorageSizeTool extends MongoDBToolBase {
    protected name = "collection-storage-size";
    protected description = "Gets the size of the collection";
    protected argsShape = DbOperationArgs;

    protected operationType: OperationType = "metadata";

    protected async execute({ database, collection }: ToolArgs<typeof DbOperationArgs>): Promise<CallToolResult> {
        const provider = await this.ensureConnected();
        const [{ value }] = (await provider
            .aggregate(database, collection, [
                { $collStats: { storageStats: {} } },
                { $group: { _id: null, value: { $sum: "$storageStats.size" } } },
            ])
            .toArray()) as [{ value: number }];

        const { units, value: scaledValue } = CollectionStorageSizeTool.getStats(value);

        return {
            content: [
                {
                    text: `The size of "${database}.${collection}" is \`${scaledValue.toFixed(2)} ${units}\``,
                    type: "text",
                },
            ],
        };
    }

    protected handleError(
        error: unknown,
        args: ToolArgs<typeof this.argsShape>
    ): Promise<CallToolResult> | CallToolResult {
        if (error instanceof Error && "codeName" in error && error.codeName === "NamespaceNotFound") {
            return {
                content: [
                    {
                        text: `The size of "${args.database}.${args.collection}" cannot be determined because the collection does not exist.`,
                        type: "text",
                    },
                ],
            };
        }

        return super.handleError(error, args);
    }

    private static getStats(value: number): { value: number; units: string } {
        const kb = 1024;
        const mb = kb * 1024;
        const gb = mb * 1024;

        if (value > gb) {
            return { value: value / gb, units: "GB" };
        }

        if (value > mb) {
            return { value: value / mb, units: "MB" };
        }
        if (value > kb) {
            return { value: value / kb, units: "KB" };
        }
        return { value, units: "bytes" };
    }
}


## File: src/tools/mongodb/metadata/connect.ts

import { z } from "zod";
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { MongoDBToolBase } from "../mongodbTool.js";
import { ToolArgs, OperationType } from "../../tool.js";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import assert from "assert";
import { UserConfig } from "../../../config.js";
import { Telemetry } from "../../../telemetry/telemetry.js";
import { Session } from "../../../session.js";

const disconnectedSchema = z
    .object({
        connectionString: z.string().describe("MongoDB connection string (in the mongodb:// or mongodb+srv:// format)"),
    })
    .describe("Options for connecting to MongoDB.");

const connectedSchema = z
    .object({
        connectionString: z
            .string()
            .optional()
            .describe("MongoDB connection string to switch to (in the mongodb:// or mongodb+srv:// format)"),
    })
    .describe(
        "Options for switching the current MongoDB connection. If a connection string is not provided, the connection string from the config will be used."
    );

const connectedName = "switch-connection" as const;
const disconnectedName = "connect" as const;

const connectedDescription =
    "Switch to a different MongoDB connection. If the user has configured a connection string or has previously called the connect tool, a connection is already established and there's no need to call this tool unless the user has explicitly requested to switch to a new instance.";
const disconnectedDescription = "Connect to a MongoDB instance";

export class ConnectTool extends MongoDBToolBase {
    protected name: typeof connectedName | typeof disconnectedName = disconnectedName;
    protected description: typeof connectedDescription | typeof disconnectedDescription = disconnectedDescription;

    // Here the default is empty just to trigger registration, but we're going to override it with the correct
    // schema in the register method.
    protected argsShape = {
        connectionString: z.string().optional(),
    };

    protected operationType: OperationType = "metadata";

    constructor(session: Session, config: UserConfig, telemetry: Telemetry) {
        super(session, config, telemetry);
        session.on("close", () => {
            this.updateMetadata();
        });
    }

    protected async execute({ connectionString }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        switch (this.name) {
            case disconnectedName:
                assert(connectionString, "Connection string is required");
                break;
            case connectedName:
                connectionString ??= this.config.connectionString;
                assert(
                    connectionString,
                    "Cannot switch to a new connection because no connection string was provided and no default connection string is configured."
                );
                break;
        }

        await this.connectToMongoDB(connectionString);
        this.updateMetadata();
        return {
            content: [{ type: "text", text: "Successfully connected to MongoDB." }],
        };
    }

    public register(server: McpServer): void {
        super.register(server);

        this.updateMetadata();
    }

    private updateMetadata(): void {
        if (this.config.connectionString || this.session.serviceProvider) {
            this.update?.({
                name: connectedName,
                description: connectedDescription,
                inputSchema: connectedSchema,
            });
        } else {
            this.update?.({
                name: disconnectedName,
                description: disconnectedDescription,
                inputSchema: disconnectedSchema,
            });
        }
    }
}


## File: src/tools/mongodb/metadata/dbStats.ts

import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { DbOperationArgs, MongoDBToolBase } from "../mongodbTool.js";
import { ToolArgs, OperationType } from "../../tool.js";
import { EJSON } from "bson";

export class DbStatsTool extends MongoDBToolBase {
    protected name = "db-stats";
    protected description = "Returns statistics that reflect the use state of a single database";
    protected argsShape = {
        database: DbOperationArgs.database,
    };

    protected operationType: OperationType = "metadata";

    protected async execute({ database }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        const provider = await this.ensureConnected();
        const result = await provider.runCommandWithCheck(database, {
            dbStats: 1,
            scale: 1,
        });

        return {
            content: [
                {
                    text: `Statistics for database ${database}`,
                    type: "text",
                },
                {
                    text: EJSON.stringify(result),
                    type: "text",
                },
            ],
        };
    }
}


## File: src/tools/mongodb/metadata/explain.ts

import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { DbOperationArgs, MongoDBToolBase } from "../mongodbTool.js";
import { ToolArgs, OperationType } from "../../tool.js";
import { z } from "zod";
import { ExplainVerbosity, Document } from "mongodb";
import { AggregateArgs } from "../read/aggregate.js";
import { FindArgs } from "../read/find.js";
import { CountArgs } from "../read/count.js";

export class ExplainTool extends MongoDBToolBase {
    protected name = "explain";
    protected description =
        "Returns statistics describing the execution of the winning plan chosen by the query optimizer for the evaluated method";

    protected argsShape = {
        ...DbOperationArgs,
        method: z
            .array(
                z.union([
                    z.object({
                        name: z.literal("aggregate"),
                        arguments: z.object(AggregateArgs),
                    }),
                    z.object({
                        name: z.literal("find"),
                        arguments: z.object(FindArgs),
                    }),
                    z.object({
                        name: z.literal("count"),
                        arguments: z.object(CountArgs),
                    }),
                ])
            )
            .describe("The method and its arguments to run"),
    };

    protected operationType: OperationType = "metadata";

    static readonly defaultVerbosity = ExplainVerbosity.queryPlanner;

    protected async execute({
        database,
        collection,
        method: methods,
    }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        const provider = await this.ensureConnected();
        const method = methods[0];

        if (!method) {
            throw new Error("No method provided. Expected one of the following: `aggregate`, `find`, or `count`");
        }

        let result: Document;
        switch (method.name) {
            case "aggregate": {
                const { pipeline } = method.arguments;
                result = await provider
                    .aggregate(
                        database,
                        collection,
                        pipeline,
                        {},
                        {
                            writeConcern: undefined,
                        }
                    )
                    .explain(ExplainTool.defaultVerbosity);
                break;
            }
            case "find": {
                const { filter, ...rest } = method.arguments;
                result = await provider
                    .find(database, collection, filter as Document, { ...rest })
                    .explain(ExplainTool.defaultVerbosity);
                break;
            }
            case "count": {
                const { query } = method.arguments;
                result = await provider.mongoClient.db(database).command({
                    explain: {
                        count: collection,
                        query,
                    },
                    verbosity: ExplainTool.defaultVerbosity,
                });
                break;
            }
        }

        return {
            content: [
                {
                    text: `Here is some information about the winning plan chosen by the query optimizer for running the given \`${method.name}\` operation in "${database}.${collection}". This information can be used to understand how the query was executed and to optimize the query performance.`,
                    type: "text",
                },
                {
                    text: JSON.stringify(result),
                    type: "text",
                },
            ],
        };
    }
}


## File: src/tools/mongodb/metadata/listCollections.ts

import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { DbOperationArgs, MongoDBToolBase } from "../mongodbTool.js";
import { ToolArgs, OperationType } from "../../tool.js";

export class ListCollectionsTool extends MongoDBToolBase {
    protected name = "list-collections";
    protected description = "List all collections for a given database";
    protected argsShape = {
        database: DbOperationArgs.database,
    };

    protected operationType: OperationType = "metadata";

    protected async execute({ database }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        const provider = await this.ensureConnected();
        const collections = await provider.listCollections(database);

        if (collections.length === 0) {
            return {
                content: [
                    {
                        type: "text",
                        text: `No collections found for database "${database}". To create a collection, use the "create-collection" tool.`,
                    },
                ],
            };
        }

        return {
            content: collections.map((collection) => {
                return {
                    text: `Name: "${collection.name}"`,
                    type: "text",
                };
            }),
        };
    }
}


## File: src/tools/mongodb/metadata/listDatabases.ts

import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { MongoDBToolBase } from "../mongodbTool.js";
import * as bson from "bson";
import { OperationType } from "../../tool.js";

export class ListDatabasesTool extends MongoDBToolBase {
    protected name = "list-databases";
    protected description = "List all databases for a MongoDB connection";
    protected argsShape = {};
    protected operationType: OperationType = "metadata";

    protected async execute(): Promise<CallToolResult> {
        const provider = await this.ensureConnected();
        const dbs = (await provider.listDatabases("")).databases as { name: string; sizeOnDisk: bson.Long }[];

        return {
            content: dbs.map((db) => {
                return {
                    text: `Name: ${db.name}, Size: ${db.sizeOnDisk.toString()} bytes`,
                    type: "text",
                };
            }),
        };
    }
}


## File: src/tools/mongodb/metadata/logs.ts

import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { MongoDBToolBase } from "../mongodbTool.js";
import { ToolArgs, OperationType } from "../../tool.js";
import { z } from "zod";

export class LogsTool extends MongoDBToolBase {
    protected name = "mongodb-logs";
    protected description = "Returns the most recent logged mongod events";
    protected argsShape = {
        type: z
            .enum(["global", "startupWarnings"])
            .optional()
            .default("global")
            .describe(
                "The type of logs to return. Global returns all recent log entries, while startupWarnings returns only warnings and errors from when the process started."
            ),
        limit: z
            .number()
            .int()
            .max(1024)
            .min(1)
            .optional()
            .default(50)
            .describe("The maximum number of log entries to return."),
    };

    protected operationType: OperationType = "metadata";

    protected async execute({ type, limit }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        const provider = await this.ensureConnected();

        const result = await provider.runCommandWithCheck("admin", {
            getLog: type,
        });

        const logs = (result.log as string[]).slice(0, limit);

        return {
            content: [
                {
                    text: `Found: ${result.totalLinesWritten} messages`,
                    type: "text",
                },

                ...logs.map(
                    (log) =>
                        ({
                            text: log,
                            type: "text",
                        }) as const
                ),
            ],
        };
    }
}


## File: src/tools/mongodb/create/createCollection.ts

import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { DbOperationArgs, MongoDBToolBase } from "../mongodbTool.js";
import { OperationType, ToolArgs } from "../../tool.js";

export class CreateCollectionTool extends MongoDBToolBase {
    protected name = "create-collection";
    protected description =
        "Creates a new collection in a database. If the database doesn't exist, it will be created automatically.";
    protected argsShape = DbOperationArgs;

    protected operationType: OperationType = "create";

    protected async execute({ collection, database }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        const provider = await this.ensureConnected();
        await provider.createCollection(database, collection);

        return {
            content: [
                {
                    type: "text",
                    text: `Collection "${collection}" created in database "${database}".`,
                },
            ],
        };
    }
}


## File: src/tools/mongodb/create/createIndex.ts

import { z } from "zod";
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { DbOperationArgs, MongoDBToolBase } from "../mongodbTool.js";
import { ToolArgs, OperationType } from "../../tool.js";
import { IndexDirection } from "mongodb";

export class CreateIndexTool extends MongoDBToolBase {
    protected name = "create-index";
    protected description = "Create an index for a collection";
    protected argsShape = {
        ...DbOperationArgs,
        keys: z.record(z.string(), z.custom<IndexDirection>()).describe("The index definition"),
        name: z.string().optional().describe("The name of the index"),
    };

    protected operationType: OperationType = "create";

    protected async execute({
        database,
        collection,
        keys,
        name,
    }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        const provider = await this.ensureConnected();
        const indexes = await provider.createIndexes(database, collection, [
            {
                key: keys,
                name,
            },
        ]);

        return {
            content: [
                {
                    text: `Created the index "${indexes[0]}" on collection "${collection}" in database "${database}"`,
                    type: "text",
                },
            ],
        };
    }
}


## File: src/tools/mongodb/create/insertMany.ts

import { z } from "zod";
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { DbOperationArgs, MongoDBToolBase } from "../mongodbTool.js";
import { ToolArgs, OperationType } from "../../tool.js";

export class InsertManyTool extends MongoDBToolBase {
    protected name = "insert-many";
    protected description = "Insert an array of documents into a MongoDB collection";
    protected argsShape = {
        ...DbOperationArgs,
        documents: z
            .array(z.record(z.string(), z.unknown()).describe("An individual MongoDB document"))
            .describe(
                "The array of documents to insert, matching the syntax of the document argument of db.collection.insertMany()"
            ),
    };
    protected operationType: OperationType = "create";

    protected async execute({
        database,
        collection,
        documents,
    }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        const provider = await this.ensureConnected();
        const result = await provider.insertMany(database, collection, documents);

        return {
            content: [
                {
                    text: `Inserted \`${result.insertedCount}\` document(s) into collection "${collection}"`,
                    type: "text",
                },
                {
                    text: `Inserted IDs: ${Object.values(result.insertedIds).join(", ")}`,
                    type: "text",
                },
            ],
        };
    }
}


## File: src/tools/atlas/atlasTool.ts

import { ToolBase, ToolCategory, TelemetryToolMetadata, ToolArgs } from "../tool.js";
import { ToolCallback } from "@modelcontextprotocol/sdk/server/mcp.js";
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import logger, { LogId } from "../../logger.js";
import { z } from "zod";
import { ApiClientError } from "../../common/atlas/apiClientError.js";

export abstract class AtlasToolBase extends ToolBase {
    protected category: ToolCategory = "atlas";

    protected verifyAllowed(): boolean {
        if (!this.config.apiClientId || !this.config.apiClientSecret) {
            return false;
        }
        return super.verifyAllowed();
    }

    protected handleError(
        error: unknown,
        args: ToolArgs<typeof this.argsShape>
    ): Promise<CallToolResult> | CallToolResult {
        if (error instanceof ApiClientError) {
            const statusCode = error.response.status;

            if (statusCode === 401) {
                return {
                    content: [
                        {
                            type: "text",
                            text: `Unable to authenticate with MongoDB Atlas, API error: ${error.message}

Hint: Your API credentials may be invalid, expired or lack permissions. 
Please check your Atlas API credentials and ensure they have the appropriate permissions.
For more information on setting up API keys, visit: https://www.mongodb.com/docs/atlas/configure-api-access/`,
                        },
                    ],
                    isError: true,
                };
            }

            if (statusCode === 403) {
                return {
                    content: [
                        {
                            type: "text",
                            text: `Received a Forbidden API Error: ${error.message}
                            
You don't have sufficient permissions to perform this action in MongoDB Atlas
Please ensure your API key has the necessary roles assigned.
For more information on Atlas API access roles, visit: https://www.mongodb.com/docs/atlas/api/service-accounts-overview/`,
                        },
                    ],
                    isError: true,
                };
            }
        }

        // For other types of errors, use the default error handling from the base class
        return super.handleError(error, args);
    }

    /**
     *
     * Resolves the tool metadata from the arguments passed to the tool
     *
     * @param args - The arguments passed to the tool
     * @returns The tool metadata
     */
    protected resolveTelemetryMetadata(
        ...args: Parameters<ToolCallback<typeof this.argsShape>>
    ): TelemetryToolMetadata {
        const toolMetadata: TelemetryToolMetadata = {};
        if (!args.length) {
            return toolMetadata;
        }

        // Create a typed parser for the exact shape we expect
        const argsShape = z.object(this.argsShape);
        const parsedResult = argsShape.safeParse(args[0]);

        if (!parsedResult.success) {
            logger.debug(
                LogId.telemetryMetadataError,
                "tool",
                `Error parsing tool arguments: ${parsedResult.error.message}`
            );
            return toolMetadata;
        }

        const data = parsedResult.data;

        // Extract projectId using type guard
        if ("projectId" in data && typeof data.projectId === "string" && data.projectId.trim() !== "") {
            toolMetadata.projectId = data.projectId;
        }

        // Extract orgId using type guard
        if ("orgId" in data && typeof data.orgId === "string" && data.orgId.trim() !== "") {
            toolMetadata.orgId = data.orgId;
        }
        return toolMetadata;
    }
}


## File: src/tools/atlas/tools.ts

import { ListClustersTool } from "./read/listClusters.js";
import { ListProjectsTool } from "./read/listProjects.js";
import { InspectClusterTool } from "./read/inspectCluster.js";
import { CreateFreeClusterTool } from "./create/createFreeCluster.js";
import { CreateAccessListTool } from "./create/createAccessList.js";
import { InspectAccessListTool } from "./read/inspectAccessList.js";
import { ListDBUsersTool } from "./read/listDBUsers.js";
import { CreateDBUserTool } from "./create/createDBUser.js";
import { CreateProjectTool } from "./create/createProject.js";
import { ListOrganizationsTool } from "./read/listOrgs.js";
import { ConnectClusterTool } from "./metadata/connectCluster.js";
import { ListAlertsTool } from "./read/listAlerts.js";

export const AtlasTools = [
    ListClustersTool,
    ListProjectsTool,
    InspectClusterTool,
    CreateFreeClusterTool,
    CreateAccessListTool,
    InspectAccessListTool,
    ListDBUsersTool,
    CreateDBUserTool,
    CreateProjectTool,
    ListOrganizationsTool,
    ConnectClusterTool,
    ListAlertsTool,
];


## File: src/tools/atlas/read/inspectAccessList.ts

import { z } from "zod";
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { AtlasToolBase } from "../atlasTool.js";
import { ToolArgs, OperationType } from "../../tool.js";

export class InspectAccessListTool extends AtlasToolBase {
    protected name = "atlas-inspect-access-list";
    protected description = "Inspect Ip/CIDR ranges with access to your MongoDB Atlas clusters.";
    protected operationType: OperationType = "read";
    protected argsShape = {
        projectId: z.string().describe("Atlas project ID"),
    };

    protected async execute({ projectId }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        const accessList = await this.session.apiClient.listProjectIpAccessLists({
            params: {
                path: {
                    groupId: projectId,
                },
            },
        });

        if (!accessList?.results?.length) {
            throw new Error("No access list entries found.");
        }

        return {
            content: [
                {
                    type: "text",
                    text: `IP ADDRESS | CIDR | COMMENT
------|------|------
${(accessList.results || [])
    .map((entry) => {
        return `${entry.ipAddress} | ${entry.cidrBlock} | ${entry.comment}`;
    })
    .join("\n")}`,
                },
            ],
        };
    }
}


## File: src/tools/atlas/read/inspectCluster.ts

import { z } from "zod";
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { AtlasToolBase } from "../atlasTool.js";
import { ToolArgs, OperationType } from "../../tool.js";
import { Cluster, inspectCluster } from "../../../common/atlas/cluster.js";

export class InspectClusterTool extends AtlasToolBase {
    protected name = "atlas-inspect-cluster";
    protected description = "Inspect MongoDB Atlas cluster";
    protected operationType: OperationType = "read";
    protected argsShape = {
        projectId: z.string().describe("Atlas project ID"),
        clusterName: z.string().describe("Atlas cluster name"),
    };

    protected async execute({ projectId, clusterName }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        const cluster = await inspectCluster(this.session.apiClient, projectId, clusterName);

        return this.formatOutput(cluster);
    }

    private formatOutput(formattedCluster: Cluster): CallToolResult {
        return {
            content: [
                {
                    type: "text",
                    text: `Cluster Name | Cluster Type | Tier | State | MongoDB Version | Connection String
----------------|----------------|----------------|----------------|----------------|----------------
${formattedCluster.name || "Unknown"} | ${formattedCluster.instanceType} | ${formattedCluster.instanceSize || "N/A"} | ${formattedCluster.state || "UNKNOWN"} | ${formattedCluster.mongoDBVersion || "N/A"} | ${formattedCluster.connectionString || "N/A"}`,
                },
            ],
        };
    }
}


## File: src/tools/atlas/read/listAlerts.ts

import { z } from "zod";
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { AtlasToolBase } from "../atlasTool.js";
import { ToolArgs, OperationType } from "../../tool.js";

export class ListAlertsTool extends AtlasToolBase {
    protected name = "atlas-list-alerts";
    protected description = "List MongoDB Atlas alerts";
    protected operationType: OperationType = "read";
    protected argsShape = {
        projectId: z.string().describe("Atlas project ID to list alerts for"),
    };

    protected async execute({ projectId }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        const data = await this.session.apiClient.listAlerts({
            params: {
                path: {
                    groupId: projectId,
                },
            },
        });

        if (!data?.results?.length) {
            return { content: [{ type: "text", text: "No alerts found in your MongoDB Atlas project." }] };
        }

        // Format alerts as a table
        const output =
            `Alert ID | Status | Created | Updated | Type | Comment
----------|---------|----------|----------|------|--------
` +
            data.results
                .map((alert) => {
                    const created = alert.created ? new Date(alert.created).toLocaleString() : "N/A";
                    const updated = alert.updated ? new Date(alert.updated).toLocaleString() : "N/A";
                    const comment = alert.acknowledgementComment ?? "N/A";
                    return `${alert.id} | ${alert.status} | ${created} | ${updated} | ${alert.eventTypeName} | ${comment}`;
                })
                .join("\n");

        return {
            content: [{ type: "text", text: output }],
        };
    }
}


## File: src/tools/atlas/read/listClusters.ts

import { z } from "zod";
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { AtlasToolBase } from "../atlasTool.js";
import { ToolArgs, OperationType } from "../../tool.js";
import {
    PaginatedClusterDescription20240805,
    PaginatedOrgGroupView,
    Group,
    PaginatedFlexClusters20241113,
} from "../../../common/atlas/openapi.js";
import { formatCluster, formatFlexCluster } from "../../../common/atlas/cluster.js";

export class ListClustersTool extends AtlasToolBase {
    protected name = "atlas-list-clusters";
    protected description = "List MongoDB Atlas clusters";
    protected operationType: OperationType = "read";
    protected argsShape = {
        projectId: z.string().describe("Atlas project ID to filter clusters").optional(),
    };

    protected async execute({ projectId }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        if (!projectId) {
            const data = await this.session.apiClient.listClustersForAllProjects();

            return this.formatAllClustersTable(data);
        } else {
            const project = await this.session.apiClient.getProject({
                params: {
                    path: {
                        groupId: projectId,
                    },
                },
            });

            if (!project?.id) {
                throw new Error(`Project with ID "${projectId}" not found.`);
            }

            const data = await this.session.apiClient.listClusters({
                params: {
                    path: {
                        groupId: project.id || "",
                    },
                },
            });

            return this.formatClustersTable(project, data);
        }
    }

    private formatAllClustersTable(clusters?: PaginatedOrgGroupView): CallToolResult {
        if (!clusters?.results?.length) {
            throw new Error("No clusters found.");
        }
        const formattedClusters = clusters.results
            .map((result) => {
                return (result.clusters || []).map((cluster) => {
                    return { ...result, ...cluster, clusters: undefined };
                });
            })
            .flat();
        if (!formattedClusters.length) {
            throw new Error("No clusters found.");
        }
        const rows = formattedClusters
            .map((cluster) => {
                return `${cluster.groupName} (${cluster.groupId}) | ${cluster.name}`;
            })
            .join("\n");
        return {
            content: [
                {
                    type: "text",
                    text: `Project | Cluster Name
----------------|----------------
${rows}`,
                },
            ],
        };
    }

    private formatClustersTable(
        project: Group,
        clusters?: PaginatedClusterDescription20240805,
        flexClusters?: PaginatedFlexClusters20241113
    ): CallToolResult {
        // Check if both traditional clusters and flex clusters are absent
        if (!clusters?.results?.length && !flexClusters?.results?.length) {
            throw new Error("No clusters found.");
        }
        const formattedClusters = clusters?.results?.map((cluster) => formatCluster(cluster)) || [];
        const formattedFlexClusters = flexClusters?.results?.map((cluster) => formatFlexCluster(cluster)) || [];
        const rows = [...formattedClusters, ...formattedFlexClusters]
            .map((formattedCluster) => {
                return `${formattedCluster.name || "Unknown"} | ${formattedCluster.instanceType} | ${formattedCluster.instanceSize || "N/A"} | ${formattedCluster.state || "UNKNOWN"} | ${formattedCluster.mongoDBVersion || "N/A"} | ${formattedCluster.connectionString || "N/A"}`;
            })
            .join("\n");
        return {
            content: [
                {
                    type: "text",
                    text: `Here are your MongoDB Atlas clusters in project "${project.name}" (${project.id}):`,
                },
                {
                    type: "text",
                    text: `Cluster Name | Cluster Type | Tier | State | MongoDB Version | Connection String
----------------|----------------|----------------|----------------|----------------|----------------
${rows}`,
                },
            ],
        };
    }
}


## File: src/tools/atlas/read/listDBUsers.ts

import { z } from "zod";
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { AtlasToolBase } from "../atlasTool.js";
import { ToolArgs, OperationType } from "../../tool.js";
import { DatabaseUserRole, UserScope } from "../../../common/atlas/openapi.js";

export class ListDBUsersTool extends AtlasToolBase {
    protected name = "atlas-list-db-users";
    protected description = "List MongoDB Atlas database users";
    protected operationType: OperationType = "read";
    protected argsShape = {
        projectId: z.string().describe("Atlas project ID to filter DB users"),
    };

    protected async execute({ projectId }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        const data = await this.session.apiClient.listDatabaseUsers({
            params: {
                path: {
                    groupId: projectId,
                },
            },
        });

        if (!data?.results?.length) {
            throw new Error("No database users found.");
        }

        const output =
            `Username | Roles | Scopes
----------------|----------------|----------------
` +
            data.results
                .map((user) => {
                    return `${user.username} | ${formatRoles(user.roles)} | ${formatScopes(user.scopes)}`;
                })
                .join("\n");
        return {
            content: [{ type: "text", text: output }],
        };
    }
}

function formatRoles(roles?: DatabaseUserRole[]) {
    if (!roles?.length) {
        return "N/A";
    }
    return roles
        .map(
            (role) =>
                `${role.roleName}${role.databaseName ? `@${role.databaseName}${role.collectionName ? `:${role.collectionName}` : ""}` : ""}`
        )
        .join(", ");
}

function formatScopes(scopes?: UserScope[]) {
    if (!scopes?.length) {
        return "All";
    }
    return scopes.map((scope) => `${scope.type}:${scope.name}`).join(", ");
}


## File: src/tools/atlas/read/listOrgs.ts

import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { AtlasToolBase } from "../atlasTool.js";
import { OperationType } from "../../tool.js";

export class ListOrganizationsTool extends AtlasToolBase {
    protected name = "atlas-list-orgs";
    protected description = "List MongoDB Atlas organizations";
    protected operationType: OperationType = "read";
    protected argsShape = {};

    protected async execute(): Promise<CallToolResult> {
        const data = await this.session.apiClient.listOrganizations();

        if (!data?.results?.length) {
            throw new Error("No projects found in your MongoDB Atlas account.");
        }

        // Format projects as a table
        const output =
            `Organization Name | Organization ID
----------------| ----------------
` +
            data.results
                .map((org) => {
                    return `${org.name} | ${org.id}`;
                })
                .join("\n");
        return {
            content: [{ type: "text", text: output }],
        };
    }
}


## File: src/tools/atlas/read/listProjects.ts

import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { AtlasToolBase } from "../atlasTool.js";
import { OperationType } from "../../tool.js";
import { z } from "zod";
import { ToolArgs } from "../../tool.js";

export class ListProjectsTool extends AtlasToolBase {
    protected name = "atlas-list-projects";
    protected description = "List MongoDB Atlas projects";
    protected operationType: OperationType = "read";
    protected argsShape = {
        orgId: z.string().describe("Atlas organization ID to filter projects").optional(),
    };

    protected async execute({ orgId }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        const orgData = await this.session.apiClient.listOrganizations();

        if (!orgData?.results?.length) {
            throw new Error("No organizations found in your MongoDB Atlas account.");
        }

        const orgs: Record<string, string> = orgData.results
            .map((org) => [org.id || "", org.name])
            .filter(([id]) => id)
            .reduce((acc, [id, name]) => ({ ...acc, [id as string]: name }), {});

        const data = orgId
            ? await this.session.apiClient.listOrganizationProjects({
                  params: {
                      path: {
                          orgId,
                      },
                  },
              })
            : await this.session.apiClient.listProjects();

        if (!data?.results?.length) {
            throw new Error("No projects found in your MongoDB Atlas account.");
        }

        // Format projects as a table
        const rows = data.results
            .map((project) => {
                const createdAt = project.created ? new Date(project.created).toLocaleString() : "N/A";
                const orgName = orgs[project.orgId] ?? "N/A";
                return `${project.name} | ${project.id} | ${orgName} | ${project.orgId} | ${createdAt}`;
            })
            .join("\n");
        const formattedProjects = `Project Name | Project ID | Organization Name | Organization ID | Created At
----------------| ----------------| ----------------| ----------------| ----------------
${rows}`;
        return {
            content: [{ type: "text", text: formattedProjects }],
        };
    }
}


## File: src/tools/atlas/metadata/connectCluster.ts

import { z } from "zod";
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { AtlasToolBase } from "../atlasTool.js";
import { ToolArgs, OperationType } from "../../tool.js";
import { generateSecurePassword } from "../../../common/atlas/generatePassword.js";
import logger, { LogId } from "../../../logger.js";
import { inspectCluster } from "../../../common/atlas/cluster.js";

const EXPIRY_MS = 1000 * 60 * 60 * 12; // 12 hours

function sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
export class ConnectClusterTool extends AtlasToolBase {
    protected name = "atlas-connect-cluster";
    protected description = "Connect to MongoDB Atlas cluster";
    protected operationType: OperationType = "metadata";
    protected argsShape = {
        projectId: z.string().describe("Atlas project ID"),
        clusterName: z.string().describe("Atlas cluster name"),
    };

    protected async execute({ projectId, clusterName }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        await this.session.disconnect();

        const cluster = await inspectCluster(this.session.apiClient, projectId, clusterName);

        if (!cluster.connectionString) {
            throw new Error("Connection string not available");
        }

        const username = `mcpUser${Math.floor(Math.random() * 100000)}`;
        const password = await generateSecurePassword();

        const expiryDate = new Date(Date.now() + EXPIRY_MS);

        const readOnly =
            this.config.readOnly ||
            (this.config.disabledTools?.includes("create") &&
                this.config.disabledTools?.includes("update") &&
                this.config.disabledTools?.includes("delete") &&
                !this.config.disabledTools?.includes("read") &&
                !this.config.disabledTools?.includes("metadata"));

        const roleName = readOnly ? "readAnyDatabase" : "readWriteAnyDatabase";

        await this.session.apiClient.createDatabaseUser({
            params: {
                path: {
                    groupId: projectId,
                },
            },
            body: {
                databaseName: "admin",
                groupId: projectId,
                roles: [
                    {
                        roleName,
                        databaseName: "admin",
                    },
                ],
                scopes: [{ type: "CLUSTER", name: clusterName }],
                username,
                password,
                awsIAMType: "NONE",
                ldapAuthType: "NONE",
                oidcAuthType: "NONE",
                x509Type: "NONE",
                deleteAfterDate: expiryDate.toISOString(),
            },
        });

        this.session.connectedAtlasCluster = {
            username,
            projectId,
            clusterName,
            expiryDate,
        };

        const cn = new URL(cluster.connectionString);
        cn.username = username;
        cn.password = password;
        cn.searchParams.set("authSource", "admin");
        const connectionString = cn.toString();

        let lastError: Error | undefined = undefined;

        for (let i = 0; i < 20; i++) {
            try {
                await this.session.connectToMongoDB(connectionString, this.config.connectOptions);
                lastError = undefined;
                break;
            } catch (err: unknown) {
                const error = err instanceof Error ? err : new Error(String(err));

                lastError = error;

                logger.debug(
                    LogId.atlasConnectFailure,
                    "atlas-connect-cluster",
                    `error connecting to cluster: ${error.message}`
                );

                await sleep(500); // wait for 500ms before retrying
            }
        }

        if (lastError) {
            throw lastError;
        }

        return {
            content: [
                {
                    type: "text",
                    text: `Connected to cluster "${clusterName}"`,
                },
            ],
        };
    }
}


## File: src/tools/atlas/create/createAccessList.ts

import { z } from "zod";
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { AtlasToolBase } from "../atlasTool.js";
import { ToolArgs, OperationType } from "../../tool.js";

const DEFAULT_COMMENT = "Added by Atlas MCP";

export class CreateAccessListTool extends AtlasToolBase {
    protected name = "atlas-create-access-list";
    protected description = "Allow Ip/CIDR ranges to access your MongoDB Atlas clusters.";
    protected operationType: OperationType = "create";
    protected argsShape = {
        projectId: z.string().describe("Atlas project ID"),
        ipAddresses: z
            .array(z.string().ip({ version: "v4" }))
            .describe("IP addresses to allow access from")
            .optional(),
        cidrBlocks: z.array(z.string().cidr()).describe("CIDR blocks to allow access from").optional(),
        currentIpAddress: z.boolean().describe("Add the current IP address").default(false),
        comment: z.string().describe("Comment for the access list entries").default(DEFAULT_COMMENT).optional(),
    };

    protected async execute({
        projectId,
        ipAddresses,
        cidrBlocks,
        comment,
        currentIpAddress,
    }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        if (!ipAddresses?.length && !cidrBlocks?.length && !currentIpAddress) {
            throw new Error("One of  ipAddresses, cidrBlocks, currentIpAddress must be provided.");
        }

        const ipInputs = (ipAddresses || []).map((ipAddress) => ({
            groupId: projectId,
            ipAddress,
            comment: comment || DEFAULT_COMMENT,
        }));

        if (currentIpAddress) {
            const currentIp = await this.session.apiClient.getIpInfo();
            const input = {
                groupId: projectId,
                ipAddress: currentIp.currentIpv4Address,
                comment: comment || DEFAULT_COMMENT,
            };
            ipInputs.push(input);
        }

        const cidrInputs = (cidrBlocks || []).map((cidrBlock) => ({
            groupId: projectId,
            cidrBlock,
            comment: comment || DEFAULT_COMMENT,
        }));

        const inputs = [...ipInputs, ...cidrInputs];

        await this.session.apiClient.createProjectIpAccessList({
            params: {
                path: {
                    groupId: projectId,
                },
            },
            body: inputs,
        });

        return {
            content: [
                {
                    type: "text",
                    text: `IP/CIDR ranges added to access list for project ${projectId}.`,
                },
            ],
        };
    }
}


## File: src/tools/atlas/create/createDBUser.ts

import { z } from "zod";
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { AtlasToolBase } from "../atlasTool.js";
import { ToolArgs, OperationType } from "../../tool.js";
import { CloudDatabaseUser, DatabaseUserRole } from "../../../common/atlas/openapi.js";
import { generateSecurePassword } from "../../../common/atlas/generatePassword.js";

export class CreateDBUserTool extends AtlasToolBase {
    protected name = "atlas-create-db-user";
    protected description = "Create an MongoDB Atlas database user";
    protected operationType: OperationType = "create";
    protected argsShape = {
        projectId: z.string().describe("Atlas project ID"),
        username: z.string().describe("Username for the new user"),
        // Models will generate overly simplistic passwords like SecurePassword123 or
        // AtlasPassword123, which are easily guessable and exploitable. We're instructing
        // the model not to try and generate anything and instead leave the field unset.
        password: z
            .string()
            .optional()
            .nullable()
            .describe(
                "Password for the new user. If the user hasn't supplied an explicit password, leave it unset and under no circumstances try to generate a random one. A secure password will be generated by the MCP server if necessary."
            ),
        roles: z
            .array(
                z.object({
                    roleName: z.string().describe("Role name"),
                    databaseName: z.string().describe("Database name").default("admin"),
                    collectionName: z.string().describe("Collection name").optional(),
                })
            )
            .describe("Roles for the new user"),
        clusters: z
            .array(z.string())
            .describe("Clusters to assign the user to, leave empty for access to all clusters")
            .optional(),
    };

    protected async execute({
        projectId,
        username,
        password,
        roles,
        clusters,
    }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        const shouldGeneratePassword = !password;
        if (shouldGeneratePassword) {
            password = await generateSecurePassword();
        }

        const input = {
            groupId: projectId,
            awsIAMType: "NONE",
            databaseName: "admin",
            ldapAuthType: "NONE",
            oidcAuthType: "NONE",
            x509Type: "NONE",
            username,
            password,
            roles: roles as unknown as DatabaseUserRole[],
            scopes: clusters?.length
                ? clusters.map((cluster) => ({
                      type: "CLUSTER",
                      name: cluster,
                  }))
                : undefined,
        } as CloudDatabaseUser;

        await this.session.apiClient.createDatabaseUser({
            params: {
                path: {
                    groupId: projectId,
                },
            },
            body: input,
        });

        return {
            content: [
                {
                    type: "text",
                    text: `User "${username}" created successfully${shouldGeneratePassword ? ` with password: \`${password}\`` : ""}.`,
                },
            ],
        };
    }
}


## File: src/tools/atlas/create/createFreeCluster.ts

import { z } from "zod";
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { AtlasToolBase } from "../atlasTool.js";
import { ToolArgs, OperationType } from "../../tool.js";
import { ClusterDescription20240805 } from "../../../common/atlas/openapi.js";

export class CreateFreeClusterTool extends AtlasToolBase {
    protected name = "atlas-create-free-cluster";
    protected description = "Create a free MongoDB Atlas cluster";
    protected operationType: OperationType = "create";
    protected argsShape = {
        projectId: z.string().describe("Atlas project ID to create the cluster in"),
        name: z.string().describe("Name of the cluster"),
        region: z.string().describe("Region of the cluster").default("US_EAST_1"),
    };

    protected async execute({ projectId, name, region }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        const input = {
            groupId: projectId,
            name,
            clusterType: "REPLICASET",
            replicationSpecs: [
                {
                    zoneName: "Zone 1",
                    regionConfigs: [
                        {
                            providerName: "TENANT",
                            backingProviderName: "AWS",
                            regionName: region,
                            electableSpecs: {
                                instanceSize: "M0",
                            },
                        },
                    ],
                },
            ],
            terminationProtectionEnabled: false,
        } as unknown as ClusterDescription20240805;

        await this.session.apiClient.createCluster({
            params: {
                path: {
                    groupId: projectId,
                },
            },
            body: input,
        });

        return {
            content: [
                { type: "text", text: `Cluster "${name}" has been created in region "${region}".` },
                { type: "text", text: `Double check your access lists to enable your current IP.` },
            ],
        };
    }
}


## File: src/tools/atlas/create/createProject.ts

import { z } from "zod";
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { AtlasToolBase } from "../atlasTool.js";
import { ToolArgs, OperationType } from "../../tool.js";
import { Group } from "../../../common/atlas/openapi.js";

export class CreateProjectTool extends AtlasToolBase {
    protected name = "atlas-create-project";
    protected description = "Create a MongoDB Atlas project";
    protected operationType: OperationType = "create";
    protected argsShape = {
        projectName: z.string().optional().describe("Name for the new project"),
        organizationId: z.string().optional().describe("Organization ID for the new project"),
    };

    protected async execute({ projectName, organizationId }: ToolArgs<typeof this.argsShape>): Promise<CallToolResult> {
        let assumedOrg = false;

        if (!projectName) {
            projectName = "Atlas Project";
        }

        if (!organizationId) {
            try {
                const organizations = await this.session.apiClient.listOrganizations();
                if (!organizations?.results?.length) {
                    throw new Error(
                        "No organizations were found in your MongoDB Atlas account. Please create an organization first."
                    );
                }
                const firstOrg = organizations.results[0];
                if (!firstOrg?.id) {
                    throw new Error(
                        "The first organization found does not have an ID. Please check your Atlas account."
                    );
                }
                organizationId = firstOrg.id;
                assumedOrg = true;
            } catch {
                throw new Error(
                    "Could not search for organizations in your MongoDB Atlas account, please provide an organization ID or create one first."
                );
            }
        }

        const input = {
            name: projectName,
            orgId: organizationId,
        } as Group;

        const group = await this.session.apiClient.createProject({
            body: input,
        });

        if (!group?.id) {
            throw new Error("Failed to create project");
        }

        return {
            content: [
                {
                    type: "text",
                    text: `Project "${projectName}" created successfully${assumedOrg ? ` (using organizationId ${organizationId}).` : ""}.`,
                },
            ],
        };
    }
}


## File: src/common/atlas/apiClient.ts

import createClient, { Client, Middleware } from "openapi-fetch";
import type { FetchOptions } from "openapi-fetch";
import { AccessToken, ClientCredentials } from "simple-oauth2";
import { ApiClientError } from "./apiClientError.js";
import { paths, operations } from "./openapi.js";
import { CommonProperties, TelemetryEvent } from "../../telemetry/types.js";
import { packageInfo } from "../../helpers/packageInfo.js";

const ATLAS_API_VERSION = "2025-03-12";

export interface ApiClientCredentials {
    clientId: string;
    clientSecret: string;
}

export interface ApiClientOptions {
    credentials?: ApiClientCredentials;
    baseUrl: string;
    userAgent?: string;
}

export class ApiClient {
    private options: {
        baseUrl: string;
        userAgent: string;
        credentials?: {
            clientId: string;
            clientSecret: string;
        };
    };
    private client: Client<paths>;
    private oauth2Client?: ClientCredentials;
    private accessToken?: AccessToken;

    private getAccessToken = async () => {
        if (this.oauth2Client && (!this.accessToken || this.accessToken.expired())) {
            this.accessToken = await this.oauth2Client.getToken({
                agent: this.options.userAgent,
            });
        }
        return this.accessToken?.token.access_token as string | undefined;
    };

    private authMiddleware: Middleware = {
        onRequest: async ({ request, schemaPath }) => {
            if (schemaPath.startsWith("/api/private/unauth") || schemaPath.startsWith("/api/oauth")) {
                return undefined;
            }

            try {
                const accessToken = await this.getAccessToken();
                request.headers.set("Authorization", `Bearer ${accessToken}`);
                return request;
            } catch {
                // ignore not availble tokens, API will return 401
            }
        },
    };

    constructor(options: ApiClientOptions) {
        this.options = {
            ...options,
            userAgent:
                options.userAgent ||
                `AtlasMCP/${packageInfo.version} (${process.platform}; ${process.arch}; ${process.env.HOSTNAME || "unknown"})`,
        };

        this.client = createClient<paths>({
            baseUrl: this.options.baseUrl,
            headers: {
                "User-Agent": this.options.userAgent,
                Accept: `application/vnd.atlas.${ATLAS_API_VERSION}+json`,
            },
        });
        if (this.options.credentials?.clientId && this.options.credentials?.clientSecret) {
            this.oauth2Client = new ClientCredentials({
                client: {
                    id: this.options.credentials.clientId,
                    secret: this.options.credentials.clientSecret,
                },
                auth: {
                    tokenHost: this.options.baseUrl,
                    tokenPath: "/api/oauth/token",
                },
            });
            this.client.use(this.authMiddleware);
        }
    }

    public hasCredentials(): boolean {
        return !!(this.oauth2Client && this.accessToken);
    }

    public async validateAccessToken(): Promise<void> {
        await this.getAccessToken();
    }

    public async getIpInfo(): Promise<{
        currentIpv4Address: string;
    }> {
        const accessToken = await this.getAccessToken();

        const endpoint = "api/private/ipinfo";
        const url = new URL(endpoint, this.options.baseUrl);
        const response = await fetch(url, {
            method: "GET",
            headers: {
                Accept: "application/json",
                Authorization: `Bearer ${accessToken}`,
                "User-Agent": this.options.userAgent,
            },
        });

        if (!response.ok) {
            throw await ApiClientError.fromResponse(response);
        }

        return (await response.json()) as Promise<{
            currentIpv4Address: string;
        }>;
    }

    public async sendEvents(events: TelemetryEvent<CommonProperties>[]): Promise<void> {
        if (!this.options.credentials) {
            await this.sendUnauthEvents(events);
            return;
        }

        try {
            await this.sendAuthEvents(events);
        } catch (error) {
            if (error instanceof ApiClientError) {
                if (error.response.status !== 401) {
                    throw error;
                }
            }

            // send unauth events if any of the following are true:
            // 1: the token is not valid (not ApiClientError)
            // 2: if the api responded with 401 (ApiClientError with status 401)
            await this.sendUnauthEvents(events);
        }
    }

    private async sendAuthEvents(events: TelemetryEvent<CommonProperties>[]): Promise<void> {
        const accessToken = await this.getAccessToken();
        if (!accessToken) {
            throw new Error("No access token available");
        }
        const authUrl = new URL("api/private/v1.0/telemetry/events", this.options.baseUrl);
        const response = await fetch(authUrl, {
            method: "POST",
            headers: {
                Accept: "application/json",
                "Content-Type": "application/json",
                "User-Agent": this.options.userAgent,
                Authorization: `Bearer ${accessToken}`,
            },
            body: JSON.stringify(events),
        });

        if (!response.ok) {
            throw await ApiClientError.fromResponse(response);
        }
    }

    private async sendUnauthEvents(events: TelemetryEvent<CommonProperties>[]): Promise<void> {
        const headers: Record<string, string> = {
            Accept: "application/json",
            "Content-Type": "application/json",
            "User-Agent": this.options.userAgent,
        };

        const unauthUrl = new URL("api/private/unauth/telemetry/events", this.options.baseUrl);
        const response = await fetch(unauthUrl, {
            method: "POST",
            headers,
            body: JSON.stringify(events),
        });

        if (!response.ok) {
            throw await ApiClientError.fromResponse(response);
        }
    }

    // DO NOT EDIT. This is auto-generated code.
    async listClustersForAllProjects(options?: FetchOptions<operations["listClustersForAllProjects"]>) {
        const { data, error, response } = await this.client.GET("/api/atlas/v2/clusters", options);
        if (error) {
            throw ApiClientError.fromError(response, error);
        }
        return data;
    }

    async listProjects(options?: FetchOptions<operations["listProjects"]>) {
        const { data, error, response } = await this.client.GET("/api/atlas/v2/groups", options);
        if (error) {
            throw ApiClientError.fromError(response, error);
        }
        return data;
    }

    async createProject(options: FetchOptions<operations["createProject"]>) {
        const { data, error, response } = await this.client.POST("/api/atlas/v2/groups", options);
        if (error) {
            throw ApiClientError.fromError(response, error);
        }
        return data;
    }

    async deleteProject(options: FetchOptions<operations["deleteProject"]>) {
        const { error, response } = await this.client.DELETE("/api/atlas/v2/groups/{groupId}", options);
        if (error) {
            throw ApiClientError.fromError(response, error);
        }
    }

    async getProject(options: FetchOptions<operations["getProject"]>) {
        const { data, error, response } = await this.client.GET("/api/atlas/v2/groups/{groupId}", options);
        if (error) {
            throw ApiClientError.fromError(response, error);
        }
        return data;
    }

    async listProjectIpAccessLists(options: FetchOptions<operations["listProjectIpAccessLists"]>) {
        const { data, error, response } = await this.client.GET("/api/atlas/v2/groups/{groupId}/accessList", options);
        if (error) {
            throw ApiClientError.fromError(response, error);
        }
        return data;
    }

    async createProjectIpAccessList(options: FetchOptions<operations["createProjectIpAccessList"]>) {
        const { data, error, response } = await this.client.POST("/api/atlas/v2/groups/{groupId}/accessList", options);
        if (error) {
            throw ApiClientError.fromError(response, error);
        }
        return data;
    }

    async deleteProjectIpAccessList(options: FetchOptions<operations["deleteProjectIpAccessList"]>) {
        const { error, response } = await this.client.DELETE(
            "/api/atlas/v2/groups/{groupId}/accessList/{entryValue}",
            options
        );
        if (error) {
            throw ApiClientError.fromError(response, error);
        }
    }

    async listAlerts(options: FetchOptions<operations["listAlerts"]>) {
        const { data, error, response } = await this.client.GET("/api/atlas/v2/groups/{groupId}/alerts", options);
        if (error) {
            throw ApiClientError.fromError(response, error);
        }
        return data;
    }

    async listClusters(options: FetchOptions<operations["listClusters"]>) {
        const { data, error, response } = await this.client.GET("/api/atlas/v2/groups/{groupId}/clusters", options);
        if (error) {
            throw ApiClientError.fromError(response, error);
        }
        return data;
    }

    async createCluster(options: FetchOptions<operations["createCluster"]>) {
        const { data, error, response } = await this.client.POST("/api/atlas/v2/groups/{groupId}/clusters", options);
        if (error) {
            throw ApiClientError.fromError(response, error);
        }
        return data;
    }

    async deleteCluster(options: FetchOptions<operations["deleteCluster"]>) {
        const { error, response } = await this.client.DELETE(
            "/api/atlas/v2/groups/{groupId}/clusters/{clusterName}",
            options
        );
        if (error) {
            throw ApiClientError.fromError(response, error);
        }
    }

    async getCluster(options: FetchOptions<operations["getCluster"]>) {
        const { data, error, response } = await this.client.GET(
            "/api/atlas/v2/groups/{groupId}/clusters/{clusterName}",
            options
        );

        if (error) {
            throw ApiClientError.fromError(response, error);
        }
        return data;
    }

    async listDatabaseUsers(options: FetchOptions<operations["listDatabaseUsers"]>) {
        const { data, error, response } = await this.client.GET(
            "/api/atlas/v2/groups/{groupId}/databaseUsers",
            options
        );
        if (error) {
            throw ApiClientError.fromError(response, error);
        }
        return data;
    }

    async createDatabaseUser(options: FetchOptions<operations["createDatabaseUser"]>) {
        const { data, error, response } = await this.client.POST(
            "/api/atlas/v2/groups/{groupId}/databaseUsers",
            options
        );
        if (error) {
            throw ApiClientError.fromError(response, error);
        }
        return data;
    }

    async deleteDatabaseUser(options: FetchOptions<operations["deleteDatabaseUser"]>) {
        const { error, response } = await this.client.DELETE(
            "/api/atlas/v2/groups/{groupId}/databaseUsers/{databaseName}/{username}",
            options
        );
        if (error) {
            throw ApiClientError.fromError(response, error);
        }
    }

    async listFlexClusters(options: FetchOptions<operations["listFlexClusters"]>) {
        const { data, error, response } = await this.client.GET("/api/atlas/v2/groups/{groupId}/flexClusters", options);
        if (error) {
            throw ApiClientError.fromError(response, error);
        }
        return data;
    }

    async createFlexCluster(options: FetchOptions<operations["createFlexCluster"]>) {
        const { data, error, response } = await this.client.POST(
            "/api/atlas/v2/groups/{groupId}/flexClusters",
            options
        );
        if (error) {
            throw ApiClientError.fromError(response, error);
        }
        return data;
    }

    async deleteFlexCluster(options: FetchOptions<operations["deleteFlexCluster"]>) {
        const { error, response } = await this.client.DELETE(
            "/api/atlas/v2/groups/{groupId}/flexClusters/{name}",
            options
        );
        if (error) {
            throw ApiClientError.fromError(response, error);
        }
    }

    async getFlexCluster(options: FetchOptions<operations["getFlexCluster"]>) {
        const { data, error, response } = await this.client.GET(
            "/api/atlas/v2/groups/{groupId}/flexClusters/{name}",
            options
        );
        if (error) {
            throw ApiClientError.fromError(response, error);
        }
        return data;
    }

    async listOrganizations(options?: FetchOptions<operations["listOrganizations"]>) {
        const { data, error, response } = await this.client.GET("/api/atlas/v2/orgs", options);
        if (error) {
            throw ApiClientError.fromError(response, error);
        }
        return data;
    }

    async listOrganizationProjects(options: FetchOptions<operations["listOrganizationProjects"]>) {
        const { data, error, response } = await this.client.GET("/api/atlas/v2/orgs/{orgId}/groups", options);
        if (error) {
            throw ApiClientError.fromError(response, error);
        }
        return data;
    }

    // DO NOT EDIT. This is auto-generated code.
}


## File: src/common/atlas/apiClientError.ts

import { ApiError } from "./openapi.js";

export class ApiClientError extends Error {
    private constructor(
        message: string,
        public readonly response: Response,
        public readonly apiError?: ApiError
    ) {
        super(message);
        this.name = "ApiClientError";
    }

    static async fromResponse(
        response: Response,
        message: string = `error calling Atlas API`
    ): Promise<ApiClientError> {
        const err = await this.extractError(response);

        return this.fromError(response, err, message);
    }

    static fromError(
        response: Response,
        error?: ApiError | string | Error,
        message: string = `error calling Atlas API`
    ): ApiClientError {
        const errorMessage = this.buildErrorMessage(error);

        const apiError = typeof error === "object" && !(error instanceof Error) ? error : undefined;

        return new ApiClientError(
            `[${response.status} ${response.statusText}] ${message}: ${errorMessage}`,
            response,
            apiError
        );
    }

    private static async extractError(response: Response): Promise<ApiError | string | undefined> {
        try {
            return (await response.json()) as ApiError;
        } catch {
            try {
                return await response.text();
            } catch {
                return undefined;
            }
        }
    }

    private static buildErrorMessage(error?: string | ApiError | Error): string {
        let errorMessage: string = "unknown error";

        if (error instanceof Error) {
            return error.message;
        }

        //eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check
        switch (typeof error) {
            case "object":
                errorMessage = error.reason || "unknown error";
                if (error.detail && error.detail.length > 0) {
                    errorMessage = `${errorMessage}; ${error.detail}`;
                }
                break;
            case "string":
                errorMessage = error;
                break;
        }

        return errorMessage.trim();
    }
}


## File: src/common/atlas/cluster.ts

import { ClusterDescription20240805, FlexClusterDescription20241113 } from "./openapi.js";
import { ApiClient } from "./apiClient.js";
import logger, { LogId } from "../../logger.js";

export interface Cluster {
    name?: string;
    instanceType: "FREE" | "DEDICATED" | "FLEX";
    instanceSize?: string;
    state?: "IDLE" | "CREATING" | "UPDATING" | "DELETING" | "REPAIRING";
    mongoDBVersion?: string;
    connectionString?: string;
}

export function formatFlexCluster(cluster: FlexClusterDescription20241113): Cluster {
    return {
        name: cluster.name,
        instanceType: "FLEX",
        instanceSize: undefined,
        state: cluster.stateName,
        mongoDBVersion: cluster.mongoDBVersion,
        connectionString: cluster.connectionStrings?.standardSrv || cluster.connectionStrings?.standard,
    };
}

export function formatCluster(cluster: ClusterDescription20240805): Cluster {
    const regionConfigs = (cluster.replicationSpecs || [])
        .map(
            (replicationSpec) =>
                (replicationSpec.regionConfigs || []) as {
                    providerName: string;
                    electableSpecs?: {
                        instanceSize: string;
                    };
                    readOnlySpecs?: {
                        instanceSize: string;
                    };
                    analyticsSpecs?: {
                        instanceSize: string;
                    };
                }[]
        )
        .flat()
        .map((regionConfig) => {
            return {
                providerName: regionConfig.providerName,
                instanceSize:
                    regionConfig.electableSpecs?.instanceSize ||
                    regionConfig.readOnlySpecs?.instanceSize ||
                    regionConfig.analyticsSpecs?.instanceSize,
            };
        });

    const instanceSize = regionConfigs[0]?.instanceSize ?? "UNKNOWN";
    const clusterInstanceType = instanceSize == "M0" ? "FREE" : "DEDICATED";

    return {
        name: cluster.name,
        instanceType: clusterInstanceType,
        instanceSize: clusterInstanceType == "DEDICATED" ? instanceSize : undefined,
        state: cluster.stateName,
        mongoDBVersion: cluster.mongoDBVersion,
        connectionString: cluster.connectionStrings?.standardSrv || cluster.connectionStrings?.standard,
    };
}

export async function inspectCluster(apiClient: ApiClient, projectId: string, clusterName: string): Promise<Cluster> {
    try {
        const cluster = await apiClient.getCluster({
            params: {
                path: {
                    groupId: projectId,
                    clusterName,
                },
            },
        });
        return formatCluster(cluster);
    } catch (error) {
        try {
            const cluster = await apiClient.getFlexCluster({
                params: {
                    path: {
                        groupId: projectId,
                        name: clusterName,
                    },
                },
            });
            return formatFlexCluster(cluster);
        } catch (flexError) {
            const err = flexError instanceof Error ? flexError : new Error(String(flexError));
            logger.error(LogId.atlasInspectFailure, "inspect-cluster", `error inspecting cluster: ${err.message}`);
            throw error;
        }
    }
}


## File: src/common/atlas/generatePassword.ts

import { randomBytes } from "crypto";
import { promisify } from "util";

const randomBytesAsync = promisify(randomBytes);

export async function generateSecurePassword(): Promise<string> {
    const buf = await randomBytesAsync(16);
    const pass = buf.toString("base64url");
    return pass;
}


## File: src/common/atlas/openapi.d.ts

/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/api/atlas/v2/clusters": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Return All Authorized Clusters in All Projects
         * @description Returns the details for all clusters in all projects to which you have access. Clusters contain a group of hosts that maintain the same data set. The response does not include multi-cloud clusters. To use this resource, the requesting Service Account or API Key can have any cluster-level role.
         */
        get: operations["listClustersForAllProjects"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/atlas/v2/groups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Return All Projects
         * @description Returns details about all projects. Projects group clusters into logical collections that support an application environment, workload, or both. Each project can have its own users, teams, security, tags, and alert settings. To use this resource, the requesting Service Account or API Key must have the Organization Read Only role or higher.
         */
        get: operations["listProjects"];
        put?: never;
        /**
         * Create One Project
         * @description Creates one project. Projects group clusters into logical collections that support an application environment, workload, or both. Each project can have its own users, teams, security, tags, and alert settings. To use this resource, the requesting Service Account or API Key must have the Read Write role.
         */
        post: operations["createProject"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/atlas/v2/groups/{groupId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Return One Project
         * @description Returns details about the specified project. Projects group clusters into logical collections that support an application environment, workload, or both. Each project can have its own users, teams, security, tags, and alert settings. To use this resource, the requesting Service Account or API Key must have the Project Read Only role.
         */
        get: operations["getProject"];
        put?: never;
        post?: never;
        /**
         * Remove One Project
         * @description Removes the specified project. Projects group clusters into logical collections that support an application environment, workload, or both. Each project can have its own users, teams, security, tags, and alert settings. You can delete a project only if there are no Online Archives for the clusters in the project. To use this resource, the requesting Service Account or API Key must have the Project Owner role.
         */
        delete: operations["deleteProject"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/atlas/v2/groups/{groupId}/accessList": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Return Project IP Access List
         * @description Returns all access list entries from the specified project's IP access list. Each entry in the project's IP access list contains either one IP address or one CIDR-notated block of IP addresses. MongoDB Cloud only allows client connections to the cluster from entries in the project's IP access list. To use this resource, the requesting Service Account or API Key must have the Project Read Only or Project Charts Admin roles. This resource replaces the whitelist resource. MongoDB Cloud removed whitelists in July 2021. Update your applications to use this new resource. The `/groups/{GROUP-ID}/accessList` endpoint manages the database IP access list. This endpoint is distinct from the `orgs/{ORG-ID}/apiKeys/{API-KEY-ID}/accesslist` endpoint, which manages the access list for MongoDB Cloud organizations.
         */
        get: operations["listProjectIpAccessLists"];
        put?: never;
        /**
         * Add Entries to Project IP Access List
         * @description Adds one or more access list entries to the specified project. MongoDB Cloud only allows client connections to the cluster from entries in the project's IP access list. Write each entry as either one IP address or one CIDR-notated block of IP addresses. To use this resource, the requesting Service Account or API Key must have the Project Owner or Project Charts Admin roles. This resource replaces the whitelist resource. MongoDB Cloud removed whitelists in July 2021. Update your applications to use this new resource. The `/groups/{GROUP-ID}/accessList` endpoint manages the database IP access list. This endpoint is distinct from the `orgs/{ORG-ID}/apiKeys/{API-KEY-ID}/accesslist` endpoint, which manages the access list for MongoDB Cloud organizations. This endpoint doesn't support concurrent `POST` requests. You must submit multiple `POST` requests synchronously.
         */
        post: operations["createProjectIpAccessList"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/atlas/v2/groups/{groupId}/accessList/{entryValue}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Remove One Entry from One Project IP Access List
         * @description Removes one access list entry from the specified project's IP access list. Each entry in the project's IP access list contains one IP address, one CIDR-notated block of IP addresses, or one AWS Security Group ID. MongoDB Cloud only allows client connections to the cluster from entries in the project's IP access list. To use this resource, the requesting Service Account or API Key must have the Project Owner role. This resource replaces the whitelist resource. MongoDB Cloud removed whitelists in July 2021. Update your applications to use this new resource. The `/groups/{GROUP-ID}/accessList` endpoint manages the database IP access list. This endpoint is distinct from the `orgs/{ORG-ID}/apiKeys/{API-KEY-ID}/accesslist` endpoint, which manages the access list for MongoDB Cloud organizations.
         */
        delete: operations["deleteProjectIpAccessList"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/atlas/v2/groups/{groupId}/alerts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Return All Alerts from One Project
         * @description Returns all alerts. These alerts apply to all components in one project. You receive an alert when a monitored component meets or exceeds a value you set. To use this resource, the requesting Service Account or API Key must have the Project Read Only role.
         *
         *     This resource remains under revision and may change.
         */
        get: operations["listAlerts"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/atlas/v2/groups/{groupId}/clusters": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Return All Clusters in One Project
         * @description Returns the details for all clusters in the specific project to which you have access. Clusters contain a group of hosts that maintain the same data set. The response includes clusters with asymmetrically-sized shards. To use this resource, the requesting Service Account or API Key must have the Project Read Only role. This feature is not  available for serverless clusters.
         *
         *     This endpoint can also be used on Flex clusters that were created using the [createCluster](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Clusters/operation/createCluster) endpoint or former M2/M5 clusters that have been migrated to Flex clusters until January 2026. Please use the listFlexClusters endpoint for Flex clusters instead. Deprecated versions: v2-{2023-02-01}, v2-{2023-01-01}
         */
        get: operations["listClusters"];
        put?: never;
        /**
         * Create One Cluster from One Project
         * @description Creates one cluster in the specified project. Clusters contain a group of hosts that maintain the same data set. This resource can create clusters with asymmetrically-sized shards. Each project supports up to 25 database deployments. To use this resource, the requesting Service Account or API Key must have the Project Owner role. This feature is not available for serverless clusters.
         *
         *     Please note that using an instanceSize of M2 or M5 will create a Flex cluster instead. Support for the instanceSize of M2 or M5 will be discontinued in January 2026. We recommend using the createFlexCluster API for such configurations moving forward. Deprecated versions: v2-{2024-08-05}, v2-{2023-02-01}, v2-{2023-01-01}
         */
        post: operations["createCluster"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/atlas/v2/groups/{groupId}/clusters/{clusterName}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Return One Cluster from One Project
         * @description Returns the details for one cluster in the specified project. Clusters contain a group of hosts that maintain the same data set. The response includes clusters with asymmetrically-sized shards. To use this resource, the requesting Service Account or API Key must have the Project Read Only role. This feature is not available for serverless clusters.
         *
         *     This endpoint can also be used on Flex clusters that were created using the [createCluster](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Clusters/operation/createCluster) endpoint or former M2/M5 clusters that have been migrated to Flex clusters until January 2026. Please use the getFlexCluster endpoint for Flex clusters instead. Deprecated versions: v2-{2023-02-01}, v2-{2023-01-01}
         */
        get: operations["getCluster"];
        put?: never;
        post?: never;
        /**
         * Remove One Cluster from One Project
         * @description Removes one cluster from the specified project. The cluster must have termination protection disabled in order to be deleted. To use this resource, the requesting Service Account or API Key must have the Project Owner role. This feature is not available for serverless clusters.
         *
         *     This endpoint can also be used on Flex clusters that were created using the [createCluster](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Clusters/operation/createCluster) endpoint or former M2/M5 clusters that have been migrated to Flex clusters until January 2026. Please use the deleteFlexCluster endpoint for Flex clusters instead. Deprecated versions: v2-{2023-01-01}
         */
        delete: operations["deleteCluster"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/atlas/v2/groups/{groupId}/databaseUsers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Return All Database Users from One Project
         * @description Returns all database users that belong to the specified project. To use this resource, the requesting Service Account or API Key must have the Project Read Only role.
         */
        get: operations["listDatabaseUsers"];
        put?: never;
        /**
         * Create One Database User in One Project
         * @description Creates one database user in the specified project. This MongoDB Cloud supports a maximum of 100 database users per project. If you require more than 100 database users on a project, contact Support. To use this resource, the requesting Service Account or API Key must have the Project Owner role, the Project Charts Admin role, Project Stream Processing Owner role, or the Project Database Access Admin role.
         */
        post: operations["createDatabaseUser"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/atlas/v2/groups/{groupId}/databaseUsers/{databaseName}/{username}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Remove One Database User from One Project
         * @description Removes one database user from the specified project. To use this resource, the requesting Service Account or API Key must have the Project Owner role, the Project Stream Processing Owner role, or the Project Database Access Admin role.
         */
        delete: operations["deleteDatabaseUser"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/atlas/v2/groups/{groupId}/flexClusters": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Return All Flex Clusters from One Project
         * @description Returns details for all flex clusters in the specified project. To use this resource, the requesting Service Account or API Key must have the Project Read Only role.
         */
        get: operations["listFlexClusters"];
        put?: never;
        /**
         * Create One Flex Cluster in One Project
         * @description Creates one flex cluster in the specified project. To use this resource, the requesting Service Account or API Key must have the Project Owner role.
         */
        post: operations["createFlexCluster"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/atlas/v2/groups/{groupId}/flexClusters/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Return One Flex Cluster from One Project
         * @description Returns details for one flex cluster in the specified project. To use this resource, the requesting Service Account or API Key must have the Project Read Only role.
         */
        get: operations["getFlexCluster"];
        put?: never;
        post?: never;
        /**
         * Remove One Flex Cluster from One Project
         * @description Removes one flex cluster from the specified project. The flex cluster must have termination protection disabled in order to be deleted. To use this resource, the requesting Service Account or API Key must have the Project Owner role.
         */
        delete: operations["deleteFlexCluster"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/atlas/v2/orgs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Return All Organizations
         * @description Returns all organizations to which the requesting Service Account or API Key has access. To use this resource, the requesting Service Account or API Key must have the Organization Member role.
         */
        get: operations["listOrganizations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/atlas/v2/orgs/{orgId}/groups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Return One or More Projects in One Organization
         * @description Returns multiple projects in the specified organization. Each organization can have multiple projects. Use projects to:
         *
         *     - Isolate different environments, such as development, test, or production environments, from each other.
         *     - Associate different MongoDB Cloud users or teams with different environments, or give different permission to MongoDB Cloud users in different environments.
         *     - Maintain separate cluster security configurations.
         *     - Create different alert settings.
         *
         *     To use this resource, the requesting Service Account or API Key must have the Organization Member role.
         */
        get: operations["listOrganizationProjects"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * AWS
         * @description Collection of settings that configures the network container for a virtual private connection on Amazon Web Services.
         */
        AWSCloudProviderContainer: Omit<components["schemas"]["CloudProviderContainer"], "providerName"> & {
            /** @description IP addresses expressed in Classless Inter-Domain Routing (CIDR) notation that MongoDB Cloud uses for the network peering containers in your project. MongoDB Cloud assigns all of the project's clusters deployed to this cloud provider an IP address from this range. MongoDB Cloud locks this value if an M10 or greater cluster or a network peering connection exists in this project.
             *
             *     These CIDR blocks must fall within the ranges reserved per RFC 1918. AWS and Azure further limit the block to between the `/24` and  `/21` ranges.
             *
             *     To modify the CIDR block, the target project cannot have:
             *
             *     - Any M10 or greater clusters
             *     - Any other VPC peering connections
             *
             *      You can also create a new project and create a network peering connection to set the desired MongoDB Cloud network peering container CIDR block for that project. MongoDB Cloud limits the number of MongoDB nodes per network peering connection based on the CIDR block and the region selected for the project.
             *
             *      **Example:** A project in an Amazon Web Services (AWS) region supporting three availability zones and an MongoDB CIDR network peering container block of limit of `/24` equals 27 three-node replica sets. */
            atlasCidrBlock?: string;
            /**
             * @description Geographic area that Amazon Web Services (AWS) defines to which MongoDB Cloud deployed this network peering container.
             * @enum {string}
             */
            regionName: "US_EAST_1" | "US_EAST_2" | "US_WEST_1" | "US_WEST_2" | "CA_CENTRAL_1" | "EU_NORTH_1" | "EU_WEST_1" | "EU_WEST_2" | "EU_WEST_3" | "EU_CENTRAL_1" | "EU_CENTRAL_2" | "SA_EAST_1" | "AP_EAST_1" | "AP_SOUTHEAST_2" | "AP_SOUTHEAST_3" | "AP_SOUTHEAST_4" | "AP_NORTHEAST_1" | "AP_NORTHEAST_2" | "AP_NORTHEAST_3" | "AP_SOUTHEAST_1" | "AP_SOUTH_1" | "AP_SOUTH_2" | "CN_NORTH_1" | "CN_NORTHWEST_1" | "ME_CENTRAL_1" | "ME_SOUTH_1" | "AF_SOUTH_1" | "EU_SOUTH_1" | "EU_SOUTH_2" | "IL_CENTRAL_1" | "CA_WEST_1" | "AP_SOUTHEAST_5" | "AP_SOUTHEAST_7" | "MX_CENTRAL_1" | "GLOBAL" | "US_GOV_WEST_1" | "US_GOV_EAST_1";
            /**
             * @description Unique string that identifies the MongoDB Cloud VPC on AWS.
             * @example vpc-b555d3b0d9cb783b0
             */
            readonly vpcId?: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "AWS";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "AWS";
        };
        AWSCloudProviderSettings: Omit<components["schemas"]["ClusterProviderSettings"], "providerName"> & {
            autoScaling?: components["schemas"]["CloudProviderAWSAutoScaling"];
            /**
             * Format: int32
             * @description Maximum Disk Input/Output Operations per Second (IOPS) that the database host can perform.
             */
            diskIOPS?: number;
            /**
             * @deprecated
             * @description Flag that indicates whether the Amazon Elastic Block Store (EBS) encryption feature encrypts the host's root volume for both data at rest within the volume and for data moving between the volume and the cluster. Clusters always have this setting enabled.
             * @default true
             */
            encryptEBSVolume: boolean;
            /**
             * AWS Instance Sizes
             * @description Cluster tier, with a default storage and memory capacity, that applies to all the data-bearing hosts in your cluster.
             * @enum {string}
             */
            instanceSizeName?: "M10" | "M20" | "M30" | "M40" | "M50" | "M60" | "M80" | "M100" | "M140" | "M200" | "M300" | "R40" | "R50" | "R60" | "R80" | "R200" | "R300" | "R400" | "R700" | "M40_NVME" | "M50_NVME" | "M60_NVME" | "M80_NVME" | "M200_NVME" | "M400_NVME";
            /**
             * AWS Regions
             * @description Physical location where MongoDB Cloud deploys your AWS-hosted MongoDB cluster nodes. The region you choose can affect network latency for clients accessing your databases. When MongoDB Cloud deploys a dedicated cluster, it checks if a VPC or VPC connection exists for that provider and region. If not, MongoDB Cloud creates them as part of the deployment. MongoDB Cloud assigns the VPC a CIDR block. To limit a new VPC peering connection to one CIDR block and region, create the connection first. Deploy the cluster after the connection starts.
             * @enum {string}
             */
            regionName?: "US_GOV_WEST_1" | "US_GOV_EAST_1" | "US_EAST_1" | "US_EAST_2" | "US_WEST_1" | "US_WEST_2" | "CA_CENTRAL_1" | "EU_NORTH_1" | "EU_WEST_1" | "EU_WEST_2" | "EU_WEST_3" | "EU_CENTRAL_1" | "EU_CENTRAL_2" | "AP_EAST_1" | "AP_NORTHEAST_1" | "AP_NORTHEAST_2" | "AP_NORTHEAST_3" | "AP_SOUTHEAST_1" | "AP_SOUTHEAST_2" | "AP_SOUTHEAST_3" | "AP_SOUTHEAST_4" | "AP_SOUTH_1" | "AP_SOUTH_2" | "SA_EAST_1" | "CN_NORTH_1" | "CN_NORTHWEST_1" | "ME_SOUTH_1" | "ME_CENTRAL_1" | "AF_SOUTH_1" | "EU_SOUTH_1" | "EU_SOUTH_2" | "IL_CENTRAL_1" | "CA_WEST_1" | "AP_SOUTHEAST_5" | "AP_SOUTHEAST_7" | "MX_CENTRAL_1" | "GLOBAL";
            /**
             * @description Disk Input/Output Operations per Second (IOPS) setting for Amazon Web Services (AWS) storage that you configure only for abbr title="Amazon Web Services">AWS</abbr>. Specify whether Disk Input/Output Operations per Second (IOPS) must not exceed the default Input/Output Operations per Second (IOPS) rate for the selected volume size (`STANDARD`), or must fall within the allowable Input/Output Operations per Second (IOPS) range for the selected volume size (`PROVISIONED`). You must set this value to (`PROVISIONED`) for NVMe clusters.
             * @enum {string}
             */
            volumeType?: "STANDARD" | "PROVISIONED";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "AWS";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "AWS";
        };
        /**
         * AWS
         * @description Collection of settings that configures how a cluster might scale its cluster tier and whether the cluster can scale down. Cluster tier auto-scaling is unavailable for clusters using Low CPU or NVME storage classes.
         */
        AWSComputeAutoScaling: {
            /**
             * AWS Instance Sizes
             * @description Maximum instance size to which your cluster can automatically scale.
             * @enum {string}
             */
            maxInstanceSize?: "M10" | "M20" | "M30" | "M40" | "M50" | "M60" | "M80" | "M100" | "M140" | "M200" | "M300" | "R40" | "R50" | "R60" | "R80" | "R200" | "R300" | "R400" | "R700" | "M40_NVME" | "M50_NVME" | "M60_NVME" | "M80_NVME" | "M200_NVME" | "M400_NVME";
            /**
             * AWS Instance Sizes
             * @description Minimum instance size to which your cluster can automatically scale.
             * @enum {string}
             */
            minInstanceSize?: "M10" | "M20" | "M30" | "M40" | "M50" | "M60" | "M80" | "M100" | "M140" | "M200" | "M300" | "R40" | "R50" | "R60" | "R80" | "R200" | "R300" | "R400" | "R700" | "M40_NVME" | "M50_NVME" | "M60_NVME" | "M80_NVME" | "M200_NVME" | "M400_NVME";
        };
        AWSCreateDataProcessRegionView: Omit<components["schemas"]["CreateDataProcessRegionView"], "cloudProvider"> & {
            /**
             * @description Human-readable label that identifies the geographic location of the region where you wish to store your archived data.
             * @enum {string}
             */
            region?: "US_EAST_1" | "US_WEST_2" | "SA_EAST_1" | "EU_WEST_1" | "EU_WEST_2" | "EU_CENTRAL_1" | "AP_SOUTH_1" | "AP_SOUTHEAST_1" | "AP_SOUTHEAST_2";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            cloudProvider: "AWS";
        };
        AWSDataProcessRegionView: Omit<components["schemas"]["DataProcessRegionView"], "cloudProvider"> & {
            /**
             * @description Human-readable label that identifies the geographic location of the region where you store your archived data.
             * @enum {string}
             */
            readonly region?: "US_EAST_1" | "US_WEST_2" | "SA_EAST_1" | "EU_WEST_1" | "EU_WEST_2" | "EU_CENTRAL_1" | "AP_SOUTH_1" | "AP_SOUTHEAST_1" | "AP_SOUTHEAST_2";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            cloudProvider: "AWS";
        };
        /**
         * AWS Cluster Hardware Settings
         * @description Hardware specifications for nodes deployed in the region.
         */
        AWSHardwareSpec: {
            /**
             * Format: int32
             * @description Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware.
             *
             *      Change this parameter if you:
             *
             *     - set `"replicationSpecs[n].regionConfigs[m].providerName" to "AWS"`.
             *     - set `"replicationSpecs[n].regionConfigs[m].electableSpecs.instanceSize" to "M30"` or greater (not including `Mxx_NVME` tiers).
             *
             *     - set `"replicationSpecs[n].regionConfigs[m].electableSpecs.ebsVolumeType" to "PROVISIONED"`.
             *
             *     The maximum input/output operations per second (IOPS) depend on the selected **.instanceSize** and **.diskSizeGB**.
             *     This parameter defaults to the cluster tier's standard IOPS value.
             *     Changing this value impacts cluster cost.
             *     MongoDB Cloud enforces minimum ratios of storage capacity to system memory for given cluster tiers. This keeps cluster performance consistent with large datasets.
             *
             *     - Instance sizes `M10` to `M40` have a ratio of disk capacity to system memory of 60:1.
             *     - Instance sizes greater than `M40` have a ratio of 120:1.
             */
            diskIOPS?: number;
            /**
             * @description Type of storage you want to attach to your AWS-provisioned cluster.
             *
             *     - `STANDARD` volume types can't exceed the default input/output operations per second (IOPS) rate for the selected volume size.
             *
             *     - `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size. You must set this value to (`PROVISIONED`) for NVMe clusters.
             * @default STANDARD
             * @enum {string}
             */
            ebsVolumeType: "STANDARD" | "PROVISIONED";
            /**
             * AWS Instance Sizes
             * @description Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts of the node type.
             * @enum {string}
             */
            instanceSize?: "M10" | "M20" | "M30" | "M40" | "M50" | "M60" | "M80" | "M100" | "M140" | "M200" | "M300" | "R40" | "R50" | "R60" | "R80" | "R200" | "R300" | "R400" | "R700" | "M40_NVME" | "M50_NVME" | "M60_NVME" | "M80_NVME" | "M200_NVME" | "M400_NVME";
            /**
             * Format: int32
             * @description Number of nodes of the given type for MongoDB Cloud to deploy to the region.
             */
            nodeCount?: number;
        };
        /**
         * AWS Cluster Hardware Settings
         * @description Hardware specifications for nodes deployed in the region.
         */
        AWSHardwareSpec20240805: {
            /**
             * Format: int32
             * @description Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware.
             *
             *      You can set different IOPS values on different shards when provisioned IOPS are supported.
             *
             *      Change this parameter if you:
             *
             *     - set `"replicationSpecs[n].regionConfigs[m].providerName" to "AWS"`.
             *     - set `"replicationSpecs[n].regionConfigs[m].electableSpecs.instanceSize" to "M30"` or greater (not including `Mxx_NVME` tiers).
             *
             *     - set `"replicationSpecs[n].regionConfigs[m].electableSpecs.ebsVolumeType" to "PROVISIONED"`.
             *
             *     The maximum input/output operations per second (IOPS) depend on the selected **.instanceSize** and **.diskSizeGB**.
             *     This parameter defaults to the cluster tier's standard IOPS value.
             *     Changing this value impacts cluster cost.
             *     MongoDB Cloud enforces minimum ratios of storage capacity to system memory for given cluster tiers. This keeps cluster performance consistent with large datasets.
             *
             *     - Instance sizes `M10` to `M40` have a ratio of disk capacity to system memory of 60:1.
             *     - Instance sizes greater than `M40` have a ratio of 120:1.
             */
            diskIOPS?: number;
            /**
             * Format: double
             * @description Storage capacity of instance data volumes expressed in gigabytes. Increase this number to add capacity.
             *
             *      This value must be equal for all shards and node types.
             *
             *      This value is not configurable on M0/M2/M5 clusters.
             *
             *      MongoDB Cloud requires this parameter if you set **replicationSpecs**.
             *
             *      If you specify a disk size below the minimum (10 GB), this parameter defaults to the minimum disk size value.
             *
             *      Storage charge calculations depend on whether you choose the default value or a custom value.
             *
             *      The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
             */
            diskSizeGB?: number;
            /**
             * @description Type of storage you want to attach to your AWS-provisioned cluster.
             *
             *     - `STANDARD` volume types can't exceed the default input/output operations per second (IOPS) rate for the selected volume size.
             *
             *     - `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size. You must set this value to (`PROVISIONED`) for NVMe clusters.
             * @default STANDARD
             * @enum {string}
             */
            ebsVolumeType: "STANDARD" | "PROVISIONED";
            /**
             * AWS Instance Sizes
             * @description Hardware specification for the instance sizes in this region in this shard. Each instance size has a default storage and memory capacity. Electable nodes and read-only nodes (known as "base nodes") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.
             * @enum {string}
             */
            instanceSize?: "M10" | "M20" | "M30" | "M40" | "M50" | "M60" | "M80" | "M100" | "M140" | "M200" | "M300" | "R40" | "R50" | "R60" | "R80" | "R200" | "R300" | "R400" | "R700" | "M40_NVME" | "M50_NVME" | "M60_NVME" | "M80_NVME" | "M200_NVME" | "M400_NVME";
            /**
             * Format: int32
             * @description Number of nodes of the given type for MongoDB Cloud to deploy to the region.
             */
            nodeCount?: number;
        };
        /**
         * AWS Regional Replication Specifications
         * @description Details that explain how MongoDB Cloud replicates data in one region on the specified MongoDB database.
         */
        AWSRegionConfig: Omit<components["schemas"]["CloudRegionConfig"], "providerName"> & {
            analyticsAutoScaling?: components["schemas"]["AdvancedAutoScalingSettings"];
            analyticsSpecs?: components["schemas"]["DedicatedHardwareSpec"];
            autoScaling?: components["schemas"]["AdvancedAutoScalingSettings"];
            readOnlySpecs?: components["schemas"]["DedicatedHardwareSpec"];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "AWS";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "AWS";
        };
        /**
         * AWS Regional Replication Specifications
         * @description Details that explain how MongoDB Cloud replicates data in one region on the specified MongoDB database.
         */
        AWSRegionConfig20240805: Omit<components["schemas"]["CloudRegionConfig20240805"], "providerName"> & {
            analyticsAutoScaling?: components["schemas"]["AdvancedAutoScalingSettings"];
            analyticsSpecs?: components["schemas"]["DedicatedHardwareSpec20240805"];
            autoScaling?: components["schemas"]["AdvancedAutoScalingSettings"];
            readOnlySpecs?: components["schemas"]["DedicatedHardwareSpec20240805"];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "AWS";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "AWS";
        };
        /**
         * Automatic Scaling Settings
         * @description Options that determine how this cluster handles resource scaling.
         */
        AdvancedAutoScalingSettings: {
            compute?: components["schemas"]["AdvancedComputeAutoScaling"];
            diskGB?: components["schemas"]["DiskGBAutoScaling"];
        };
        /**
         * Automatic Compute Scaling Settings
         * @description Options that determine how this cluster handles CPU scaling.
         */
        AdvancedComputeAutoScaling: {
            /** @description Flag that indicates whether instance size reactive auto-scaling is enabled.
             *
             *     - Set to `true` to enable instance size reactive auto-scaling. If enabled, you must specify a value for **replicationSpecs[n].regionConfigs[m].autoScaling.compute.maxInstanceSize**.
             *     - Set to `false` to disable instance size reactive auto-scaling. */
            enabled?: boolean;
            maxInstanceSize?: components["schemas"]["BaseCloudProviderInstanceSize"];
            minInstanceSize?: components["schemas"]["BaseCloudProviderInstanceSize"];
            /** @description Flag that indicates whether predictive instance size auto-scaling is enabled.
             *
             *     - Set to `true` to enable predictive instance size auto-scaling. MongoDB Cloud requires **replicationSpecs[n].regionConfigs[m].autoScaling.compute.enabled** to be `true` in order to enable this feature.
             *     - Set to `false` to disable predictive instance size auto-scaling. */
            predictiveEnabled?: boolean;
            /** @description Flag that indicates whether the instance size may scale down via reactive auto-scaling. MongoDB Cloud requires this parameter if **replicationSpecs[n].regionConfigs[m].autoScaling.compute.enabled** is `true`. If you enable this option, specify a value for **replicationSpecs[n].regionConfigs[m].autoScaling.compute.minInstanceSize**. */
            scaleDownEnabled?: boolean;
        };
        AlertViewForNdsGroup: components["schemas"]["AppServiceAlertView"] | components["schemas"]["ClusterAlertView"] | components["schemas"]["HostAlertViewForNdsGroup"] | components["schemas"]["HostMetricAlert"] | components["schemas"]["ReplicaSetAlertViewForNdsGroup"] | components["schemas"]["StreamProcessorAlertViewForNdsGroup"] | components["schemas"]["DefaultAlertViewForNdsGroup"];
        /** @description Object that contains the identifying characteristics of the Amazon Web Services (AWS) Key Management Service (KMS). This field always returns a null value. */
        ApiAtlasCloudProviderAccessFeatureUsageFeatureIdView: Record<string, never> | null;
        /** @description Group of settings that configures a subset of the advanced configuration details. */
        ApiAtlasClusterAdvancedConfigurationView: {
            /** @description The custom OpenSSL cipher suite list for TLS 1.2. This field is only valid when `tlsCipherConfigMode` is set to `CUSTOM`. */
            customOpensslCipherConfigTls12?: ("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384" | "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256")[];
            /**
             * @description Minimum Transport Layer Security (TLS) version that the cluster accepts for incoming connections. Clusters using TLS 1.0 or 1.1 should consider setting TLS 1.2 as the minimum TLS protocol version.
             * @enum {string}
             */
            minimumEnabledTlsProtocol?: "TLS1_0" | "TLS1_1" | "TLS1_2";
            /**
             * @description The TLS cipher suite configuration mode. The default mode uses the default cipher suites. The custom mode allows you to specify custom cipher suites for both TLS 1.2 and TLS 1.3.
             * @enum {string}
             */
            tlsCipherConfigMode?: "CUSTOM" | "DEFAULT";
        };
        /**
         * analyzers
         * @description Settings that describe one Atlas Search custom analyzer.
         */
        ApiAtlasFTSAnalyzersViewManual: {
            /** @description Filters that examine text one character at a time and perform filtering operations. */
            charFilters?: (components["schemas"]["charFilterhtmlStrip"] | components["schemas"]["charFiltericuNormalize"] | components["schemas"]["charFiltermapping"] | components["schemas"]["charFilterpersian"])[];
            /** @description Human-readable name that identifies the custom analyzer. Names must be unique within an index, and must not start with any of the following strings:
             *     - `lucene.`
             *     - `builtin.`
             *     - `mongodb.` */
            name: string;
            /** @description Filter that performs operations such as:
             *
             *     - Stemming, which reduces related words, such as "talking", "talked", and "talks" to their root word "talk".
             *
             *     - Redaction, the removal of sensitive information from public documents. */
            tokenFilters?: (components["schemas"]["tokenFilterasciiFolding"] | components["schemas"]["tokenFilterdaitchMokotoffSoundex"] | components["schemas"]["tokenFilteredgeGram"] | components["schemas"]["TokenFilterEnglishPossessive"] | components["schemas"]["TokenFilterFlattenGraph"] | components["schemas"]["tokenFiltericuFolding"] | components["schemas"]["tokenFiltericuNormalizer"] | components["schemas"]["TokenFilterkStemming"] | components["schemas"]["tokenFilterlength"] | components["schemas"]["tokenFilterlowercase"] | components["schemas"]["tokenFilternGram"] | components["schemas"]["TokenFilterPorterStemming"] | components["schemas"]["tokenFilterregex"] | components["schemas"]["tokenFilterreverse"] | components["schemas"]["tokenFiltershingle"] | components["schemas"]["tokenFiltersnowballStemming"] | components["schemas"]["TokenFilterSpanishPluralStemming"] | components["schemas"]["TokenFilterStempel"] | components["schemas"]["tokenFilterstopword"] | components["schemas"]["tokenFiltertrim"] | components["schemas"]["TokenFilterWordDelimiterGraph"])[];
            /** @description Tokenizer that you want to use to create tokens. Tokens determine how Atlas Search splits up text into discrete chunks for indexing. */
            tokenizer: components["schemas"]["tokenizeredgeGram"] | components["schemas"]["tokenizerkeyword"] | components["schemas"]["tokenizernGram"] | components["schemas"]["tokenizerregexCaptureGroup"] | components["schemas"]["tokenizerregexSplit"] | components["schemas"]["tokenizerstandard"] | components["schemas"]["tokenizeruaxUrlEmail"] | components["schemas"]["tokenizerwhitespace"];
        };
        /**
         * mappings
         * @description Index specifications for the collection's fields.
         */
        ApiAtlasFTSMappingsViewManual: {
            /**
             * @description Flag that indicates whether the index uses dynamic or static mappings. Required if **mappings.fields** is omitted.
             * @default false
             */
            dynamic: boolean;
            /** @description One or more field specifications for the Atlas Search index. Required if **mappings.dynamic** is omitted or set to **false**. */
            fields?: {
                [key: string]: Record<string, never>;
            };
        };
        ApiError: {
            badRequestDetail?: components["schemas"]["BadRequestDetail"];
            /** @description Describes the specific conditions or reasons that cause each type of error. */
            detail?: string;
            /**
             * Format: int32
             * @description HTTP status code returned with this error.
             */
            readonly error: number;
            /** @description Application error code returned with this error. */
            readonly errorCode: string;
            /** @description Parameters used to give more information about the error. */
            readonly parameters?: Record<string, never>[];
            /** @description Application error message returned with this error. */
            readonly reason?: string;
        };
        /**
         * App Services Alerts
         * @description App Services alert notifies different activities about a BAAS application.
         */
        AppServiceAlertView: {
            /**
             * Format: date-time
             * @description Date and time until which this alert has been acknowledged. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter if a MongoDB User previously acknowledged this alert.
             *
             *     - To acknowledge this alert forever, set the parameter value to 100 years in the future.
             *
             *     - To unacknowledge a previously acknowledged alert, do not set this parameter value.
             */
            acknowledgedUntil?: string;
            /**
             * @description Comment that a MongoDB Cloud user submitted when acknowledging the alert.
             * @example Expiration on 3/19.  Silencing for 7days.
             */
            acknowledgementComment?: string;
            /**
             * Format: email
             * @description MongoDB Cloud username of the person who acknowledged the alert. The response returns this parameter if a MongoDB Cloud user previously acknowledged this alert.
             */
            readonly acknowledgingUsername?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies the alert configuration that sets this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly alertConfigId: string;
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud created this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly created: string;
            eventTypeName: components["schemas"]["AppServiceEventTypeViewAlertable"];
            /**
             * @description Unique 24-hexadecimal digit string that identifies the project that owns this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly groupId?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly id: string;
            /**
             * Format: date-time
             * @description Date and time that any notifications were last sent for this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter if MongoDB Cloud has sent notifications for this alert.
             */
            readonly lastNotified?: string;
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /**
             * @description Unique 24-hexadecimal character string that identifies the organization that owns the project to which this alert applies.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly orgId?: string;
            /**
             * Format: date-time
             * @description Date and time that this alert changed to `"status" : "CLOSED"`. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter once `"status" : "CLOSED"`.
             */
            readonly resolved?: string;
            /**
             * @description State of this alert at the time you requested its details.
             * @example OPEN
             * @enum {string}
             */
            readonly status: "CANCELLED" | "CLOSED" | "OPEN" | "TRACKING";
            /**
             * Format: date-time
             * @description Date and time when someone last updated this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly updated: string;
        };
        /**
         * App Services Event Types
         * @description Incident that triggered this alert.
         * @example DEPLOYMENT_FAILURE
         * @enum {string}
         */
        AppServiceEventTypeViewAlertable: "URL_CONFIRMATION" | "SUCCESSFUL_DEPLOY" | "DEPLOYMENT_FAILURE" | "DEPLOYMENT_MODEL_CHANGE_SUCCESS" | "DEPLOYMENT_MODEL_CHANGE_FAILURE" | "REQUEST_RATE_LIMIT" | "LOG_FORWARDER_FAILURE" | "OUTSIDE_REALM_METRIC_THRESHOLD" | "SYNC_FAILURE" | "TRIGGER_FAILURE" | "TRIGGER_AUTO_RESUMED";
        /** @description Details that describe the organization. */
        AtlasOrganization: {
            /**
             * @description Unique 24-hexadecimal digit string that identifies the organization.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly id?: string;
            /** @description Flag that indicates whether this organization has been deleted. */
            readonly isDeleted?: boolean;
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /** @description Human-readable label that identifies the organization. */
            name: string;
            /**
             * @description Disables automatic alert creation. When set to true, no organization level alerts will be created automatically.
             * @default false
             */
            skipDefaultAlertsSettings: boolean;
        };
        /** Atlas Search Analyzer */
        AtlasSearchAnalyzer: {
            /** @description Filters that examine text one character at a time and perform filtering operations. */
            charFilters?: components["schemas"]["BasicDBObject"][];
            /** @description Name that identifies the custom analyzer. Names must be unique within an index, and must not start with any of the following strings:
             *     - `lucene.`
             *     - `builtin.`
             *     - `mongodb.` */
            name: string;
            /** @description Filter that performs operations such as:
             *
             *     - Stemming, which reduces related words, such as "talking", "talked", and "talks" to their root word "talk".
             *
             *     - Redaction, which is the removal of sensitive information from public documents. */
            tokenFilters?: components["schemas"]["BasicDBObject"][];
            /** @description Tokenizer that you want to use to create tokens. Tokens determine how Atlas Search splits up text into discrete chunks for indexing. */
            tokenizer: {
                [key: string]: Record<string, never>;
            };
        };
        /**
         * AZURE
         * @description Collection of settings that configures the network container for a virtual private connection on Amazon Web Services.
         */
        AzureCloudProviderContainer: Omit<components["schemas"]["CloudProviderContainer"], "providerName"> & {
            /** @description IP addresses expressed in Classless Inter-Domain Routing (CIDR) notation that MongoDB Cloud uses for the network peering containers in your project. MongoDB Cloud assigns all of the project's clusters deployed to this cloud provider an IP address from this range. MongoDB Cloud locks this value if an M10 or greater cluster or a network peering connection exists in this project.
             *
             *     These CIDR blocks must fall within the ranges reserved per RFC 1918. AWS and Azure further limit the block to between the `/24` and  `/21` ranges.
             *
             *     To modify the CIDR block, the target project cannot have:
             *
             *     - Any M10 or greater clusters
             *     - Any other VPC peering connections
             *
             *      You can also create a new project and create a network peering connection to set the desired MongoDB Cloud network peering container CIDR block for that project. MongoDB Cloud limits the number of MongoDB nodes per network peering connection based on the CIDR block and the region selected for the project.
             *
             *      **Example:** A project in an Amazon Web Services (AWS) region supporting three availability zones and an MongoDB CIDR network peering container block of limit of `/24` equals 27 three-node replica sets. */
            atlasCidrBlock: string;
            /**
             * @description Unique string that identifies the Azure subscription in which the MongoDB Cloud VNet resides.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly azureSubscriptionId?: string;
            /**
             * @description Azure region to which MongoDB Cloud deployed this network peering container.
             * @enum {string}
             */
            region: "US_CENTRAL" | "US_EAST" | "US_EAST_2" | "US_EAST_2_EUAP" | "US_NORTH_CENTRAL" | "US_WEST" | "US_SOUTH_CENTRAL" | "EUROPE_NORTH" | "EUROPE_WEST" | "US_WEST_CENTRAL" | "US_WEST_2" | "US_WEST_3" | "CANADA_EAST" | "CANADA_CENTRAL" | "BRAZIL_SOUTH" | "BRAZIL_SOUTHEAST" | "AUSTRALIA_EAST" | "AUSTRALIA_SOUTH_EAST" | "AUSTRALIA_CENTRAL" | "AUSTRALIA_CENTRAL_2" | "UAE_NORTH" | "GERMANY_WEST_CENTRAL" | "GERMANY_NORTH" | "SWITZERLAND_NORTH" | "SWITZERLAND_WEST" | "SWEDEN_CENTRAL" | "SWEDEN_SOUTH" | "UK_SOUTH" | "UK_WEST" | "INDIA_CENTRAL" | "INDIA_WEST" | "INDIA_SOUTH" | "CHINA_EAST" | "CHINA_NORTH" | "ASIA_EAST" | "JAPAN_EAST" | "JAPAN_WEST" | "ASIA_SOUTH_EAST" | "KOREA_CENTRAL" | "KOREA_SOUTH" | "FRANCE_CENTRAL" | "FRANCE_SOUTH" | "SOUTH_AFRICA_NORTH" | "SOUTH_AFRICA_WEST" | "NORWAY_EAST" | "NORWAY_WEST" | "UAE_CENTRAL" | "QATAR_CENTRAL" | "POLAND_CENTRAL" | "ISRAEL_CENTRAL" | "ITALY_NORTH" | "SPAIN_CENTRAL" | "MEXICO_CENTRAL" | "NEW_ZEALAND_NORTH";
            /** @description Unique string that identifies the Azure VNet in which MongoDB Cloud clusters in this network peering container exist. The response returns **null** if no clusters exist in this network peering container. */
            readonly vnetName?: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "AZURE";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "AZURE";
        };
        AzureCloudProviderSettings: Omit<components["schemas"]["ClusterProviderSettings"], "providerName"> & {
            autoScaling?: components["schemas"]["CloudProviderAzureAutoScaling"];
            /**
             * @description Disk type that corresponds to the host's root volume for Azure instances. If omitted, the default disk type for the selected **providerSettings.instanceSizeName** applies.
             * @enum {string}
             */
            diskTypeName?: "P2" | "P3" | "P4" | "P6" | "P10" | "P15" | "P20" | "P30" | "P40" | "P50";
            /**
             * Azure Instance Sizes
             * @description Cluster tier, with a default storage and memory capacity, that applies to all the data-bearing hosts in your cluster.
             * @enum {string}
             */
            instanceSizeName?: "M10" | "M20" | "M30" | "M40" | "M50" | "M60" | "M80" | "M90" | "M200" | "R40" | "R50" | "R60" | "R80" | "R200" | "R300" | "R400" | "M60_NVME" | "M80_NVME" | "M200_NVME" | "M300_NVME" | "M400_NVME" | "M600_NVME";
            /**
             * Azure Regions
             * @description Microsoft Azure Regions.
             * @enum {string}
             */
            regionName?: "US_CENTRAL" | "US_EAST" | "US_EAST_2" | "US_NORTH_CENTRAL" | "US_WEST" | "US_SOUTH_CENTRAL" | "EUROPE_NORTH" | "EUROPE_WEST" | "US_WEST_CENTRAL" | "US_WEST_2" | "US_WEST_3" | "CANADA_EAST" | "CANADA_CENTRAL" | "BRAZIL_SOUTH" | "BRAZIL_SOUTHEAST" | "AUSTRALIA_CENTRAL" | "AUSTRALIA_CENTRAL_2" | "AUSTRALIA_EAST" | "AUSTRALIA_SOUTH_EAST" | "GERMANY_WEST_CENTRAL" | "GERMANY_NORTH" | "SWEDEN_CENTRAL" | "SWEDEN_SOUTH" | "SWITZERLAND_NORTH" | "SWITZERLAND_WEST" | "UK_SOUTH" | "UK_WEST" | "NORWAY_EAST" | "NORWAY_WEST" | "INDIA_CENTRAL" | "INDIA_SOUTH" | "INDIA_WEST" | "CHINA_EAST" | "CHINA_NORTH" | "ASIA_EAST" | "JAPAN_EAST" | "JAPAN_WEST" | "ASIA_SOUTH_EAST" | "KOREA_CENTRAL" | "KOREA_SOUTH" | "FRANCE_CENTRAL" | "FRANCE_SOUTH" | "SOUTH_AFRICA_NORTH" | "SOUTH_AFRICA_WEST" | "UAE_CENTRAL" | "UAE_NORTH" | "QATAR_CENTRAL";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "AZURE";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "AZURE";
        };
        /**
         * Azure
         * @description Collection of settings that configures how a cluster might scale its cluster tier and whether the cluster can scale down. Cluster tier auto-scaling is unavailable for clusters using Low CPU or NVME storage classes.
         */
        AzureComputeAutoScalingRules: {
            /**
             * Azure Instance Sizes
             * @description Maximum instance size to which your cluster can automatically scale.
             * @enum {string}
             */
            maxInstanceSize?: "M10" | "M20" | "M30" | "M40" | "M50" | "M60" | "M80" | "M90" | "M200" | "R40" | "R50" | "R60" | "R80" | "R200" | "R300" | "R400" | "M60_NVME" | "M80_NVME" | "M200_NVME" | "M300_NVME" | "M400_NVME" | "M600_NVME";
            /**
             * Azure Instance Sizes
             * @description Minimum instance size to which your cluster can automatically scale.
             * @enum {string}
             */
            minInstanceSize?: "M10" | "M20" | "M30" | "M40" | "M50" | "M60" | "M80" | "M90" | "M200" | "R40" | "R50" | "R60" | "R80" | "R200" | "R300" | "R400" | "M60_NVME" | "M80_NVME" | "M200_NVME" | "M300_NVME" | "M400_NVME" | "M600_NVME";
        };
        AzureCreateDataProcessRegionView: Omit<components["schemas"]["CreateDataProcessRegionView"], "cloudProvider"> & {
            /**
             * @description Human-readable label that identifies the geographic location of the region where you wish to store your archived data.
             * @enum {string}
             */
            region?: "US_EAST_2" | "EUROPE_WEST";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            cloudProvider: "AZURE";
        };
        AzureDataProcessRegionView: Omit<components["schemas"]["DataProcessRegionView"], "cloudProvider"> & {
            /**
             * @description Human-readable label that identifies the geographic location of the region where you store your archived data.
             * @enum {string}
             */
            readonly region?: "US_EAST_2" | "EUROPE_WEST";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            cloudProvider: "AZURE";
        };
        AzureHardwareSpec: {
            /**
             * Format: int32
             * @description Target throughput desired for storage attached to your Azure-provisioned cluster. Change this parameter if you:
             *
             *     - set `"replicationSpecs[n].regionConfigs[m].providerName" : "Azure"`.
             *     - set `"replicationSpecs[n].regionConfigs[m].electableSpecs.instanceSize" : "M40"` or greater not including `Mxx_NVME` tiers.
             *
             *     The maximum input/output operations per second (IOPS) depend on the selected **.instanceSize** and **.diskSizeGB**.
             *     This parameter defaults to the cluster tier's standard IOPS value.
             *     Changing this value impacts cluster cost.
             */
            diskIOPS?: number;
            /**
             * Azure Instance Sizes
             * @description Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts of the node type.
             * @enum {string}
             */
            instanceSize?: "M10" | "M20" | "M30" | "M40" | "M50" | "M60" | "M80" | "M90" | "M200" | "R40" | "R50" | "R60" | "R80" | "R200" | "R300" | "R400" | "M60_NVME" | "M80_NVME" | "M200_NVME" | "M300_NVME" | "M400_NVME" | "M600_NVME";
            /**
             * Format: int32
             * @description Number of nodes of the given type for MongoDB Cloud to deploy to the region.
             */
            nodeCount?: number;
        };
        AzureHardwareSpec20240805: {
            /**
             * Format: int32
             * @description Target throughput desired for storage attached to your Azure-provisioned cluster. Change this parameter if you:
             *
             *     - set `"replicationSpecs[n].regionConfigs[m].providerName" : "Azure"`.
             *     - set `"replicationSpecs[n].regionConfigs[m].electableSpecs.instanceSize" : "M40"` or greater not including `Mxx_NVME` tiers.
             *
             *     The maximum input/output operations per second (IOPS) depend on the selected **.instanceSize** and **.diskSizeGB**.
             *     This parameter defaults to the cluster tier's standard IOPS value.
             *     Changing this value impacts cluster cost.
             */
            diskIOPS?: number;
            /**
             * Format: double
             * @description Storage capacity of instance data volumes expressed in gigabytes. Increase this number to add capacity.
             *
             *      This value must be equal for all shards and node types.
             *
             *      This value is not configurable on M0/M2/M5 clusters.
             *
             *      MongoDB Cloud requires this parameter if you set **replicationSpecs**.
             *
             *      If you specify a disk size below the minimum (10 GB), this parameter defaults to the minimum disk size value.
             *
             *      Storage charge calculations depend on whether you choose the default value or a custom value.
             *
             *      The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
             */
            diskSizeGB?: number;
            /**
             * Azure Instance Sizes
             * @description Hardware specification for the instance sizes in this region in this shard. Each instance size has a default storage and memory capacity. Electable nodes and read-only nodes (known as "base nodes") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.
             * @enum {string}
             */
            instanceSize?: "M10" | "M20" | "M30" | "M40" | "M50" | "M60" | "M80" | "M90" | "M200" | "R40" | "R50" | "R60" | "R80" | "R200" | "R300" | "R400" | "M60_NVME" | "M80_NVME" | "M200_NVME" | "M300_NVME" | "M400_NVME" | "M600_NVME";
            /**
             * Format: int32
             * @description Number of nodes of the given type for MongoDB Cloud to deploy to the region.
             */
            nodeCount?: number;
        };
        /**
         * Azure Regional Replication Specifications
         * @description Details that explain how MongoDB Cloud replicates data in one region on the specified MongoDB database.
         */
        AzureRegionConfig: Omit<components["schemas"]["CloudRegionConfig"], "providerName"> & {
            analyticsAutoScaling?: components["schemas"]["AdvancedAutoScalingSettings"];
            analyticsSpecs?: components["schemas"]["DedicatedHardwareSpec"];
            autoScaling?: components["schemas"]["AdvancedAutoScalingSettings"];
            readOnlySpecs?: components["schemas"]["DedicatedHardwareSpec"];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "AZURE";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "AZURE";
        };
        /**
         * Azure Regional Replication Specifications
         * @description Details that explain how MongoDB Cloud replicates data in one region on the specified MongoDB database.
         */
        AzureRegionConfig20240805: Omit<components["schemas"]["CloudRegionConfig20240805"], "providerName"> & {
            analyticsAutoScaling?: components["schemas"]["AdvancedAutoScalingSettings"];
            analyticsSpecs?: components["schemas"]["DedicatedHardwareSpec20240805"];
            autoScaling?: components["schemas"]["AdvancedAutoScalingSettings"];
            readOnlySpecs?: components["schemas"]["DedicatedHardwareSpec20240805"];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "AZURE";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "AZURE";
        };
        /** @description Bad request detail. */
        BadRequestDetail: {
            /** @description Describes all violations in a client request. */
            fields?: components["schemas"]["FieldViolation"][];
        };
        /** @description Instance size boundary to which your cluster can automatically scale. */
        BaseCloudProviderInstanceSize: ("M10" | "M20" | "M30" | "M40" | "M50" | "M60" | "M80" | "M100" | "M140" | "M200" | "M300" | "R40" | "R50" | "R60" | "R80" | "R200" | "R300" | "R400" | "R700" | "M40_NVME" | "M50_NVME" | "M60_NVME" | "M80_NVME" | "M200_NVME" | "M400_NVME") | ("M10" | "M20" | "M30" | "M40" | "M50" | "M60" | "M80" | "M90" | "M200" | "R40" | "R50" | "R60" | "R80" | "R200" | "R300" | "R400" | "M60_NVME" | "M80_NVME" | "M200_NVME" | "M300_NVME" | "M400_NVME" | "M600_NVME") | ("M10" | "M20" | "M30" | "M40" | "M50" | "M60" | "M80" | "M140" | "M200" | "M250" | "M300" | "M400" | "R40" | "R50" | "R60" | "R80" | "R200" | "R300" | "R400" | "R600");
        BasicDBObject: {
            [key: string]: Record<string, never>;
        };
        /**
         * MongoDB Connector for Business Intelligence Settings
         * @description Settings needed to configure the MongoDB Connector for Business Intelligence for this cluster.
         */
        BiConnector: {
            /** @description Flag that indicates whether MongoDB Connector for Business Intelligence is enabled on the specified cluster. */
            enabled?: boolean;
            /**
             * @description Data source node designated for the MongoDB Connector for Business Intelligence on MongoDB Cloud. The MongoDB Connector for Business Intelligence on MongoDB Cloud reads data from the primary, secondary, or analytics node based on your read preferences. Defaults to `ANALYTICS` node, or `SECONDARY` if there are no `ANALYTICS` nodes.
             * @enum {string}
             */
            readPreference?: "PRIMARY" | "SECONDARY" | "ANALYTICS";
        };
        BillingInvoice: {
            /**
             * Format: int64
             * @description Sum of services that the specified organization consumed in the period covered in this invoice. This parameter expresses its value in cents (100ths of one US Dollar).
             */
            readonly amountBilledCents?: number;
            /**
             * Format: int64
             * @description Sum that the specified organization paid toward this invoice. This parameter expresses its value in cents (100ths of one US Dollar).
             */
            readonly amountPaidCents?: number;
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud created this invoice. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly created?: string;
            /**
             * Format: int64
             * @description Sum that MongoDB credited the specified organization toward this invoice. This parameter expresses its value in cents (100ths of one US Dollar).
             */
            readonly creditsCents?: number;
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud finished the billing period that this invoice covers. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly endDate?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies the invoice submitted to the specified organization. Charges typically post the next day.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly id?: string;
            /** @description List that contains individual services included in this invoice. */
            readonly lineItems?: components["schemas"]["InvoiceLineItem"][];
            /** @description List that contains the invoices for organizations linked to the paying organization. */
            readonly linkedInvoices?: components["schemas"]["BillingInvoice"][];
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /**
             * @description Unique 24-hexadecimal digit string that identifies the organization charged for services consumed from MongoDB Cloud.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly orgId?: string;
            /** @description List that contains funds transferred to MongoDB to cover the specified service noted in this invoice. */
            readonly payments?: components["schemas"]["BillingPayment"][];
            /** @description List that contains payments that MongoDB returned to the organization for this invoice. */
            readonly refunds?: components["schemas"]["BillingRefund"][];
            /**
             * Format: int64
             * @description Sum of sales tax applied to this invoice. This parameter expresses its value in cents (100ths of one US Dollar).
             */
            readonly salesTaxCents?: number;
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud began the billing period that this invoice covers. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly startDate?: string;
            /**
             * Format: int64
             * @description Sum that the specified organization owed to MongoDB when MongoDB issued this invoice. This parameter expresses its value in US Dollars.
             */
            readonly startingBalanceCents?: number;
            /**
             * @description Phase of payment processing in which this invoice exists when you made this request. Accepted phases include:
             *
             *     - `CLOSED`: MongoDB finalized all charges in the billing cycle but has yet to charge the customer.
             *     - `FAILED`: MongoDB attempted to charge the provided credit card but charge for that amount failed.
             *     - `FORGIVEN`: Customer initiated payment which MongoDB later forgave.
             *     - `FREE`: All charges totalled zero so the customer won't be charged.
             *     - `INVOICED`: MongoDB handled these charges using elastic invoicing.
             *     - `PAID`: MongoDB succeeded in charging the provided credit card.
             *     - `PENDING`: Invoice includes charges for the current billing cycle.
             *     - `PREPAID`: Customer has a pre-paid plan so they won't be charged.
             * @enum {string}
             */
            statusName?: "PENDING" | "CLOSED" | "FORGIVEN" | "FAILED" | "PAID" | "FREE" | "PREPAID" | "INVOICED";
            /**
             * Format: int64
             * @description Sum of all positive invoice line items contained in this invoice. This parameter expresses its value in cents (100ths of one US Dollar).
             */
            readonly subtotalCents?: number;
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud last updated the value of this payment. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly updated?: string;
        };
        BillingInvoiceMetadata: {
            /**
             * Format: int64
             * @description Sum of services that the specified organization consumed in the period covered in this invoice. This parameter expresses its value in cents (100ths of one US Dollar).
             */
            readonly amountBilledCents?: number;
            /**
             * Format: int64
             * @description Sum that the specified organization paid toward this invoice. This parameter expresses its value in cents (100ths of one US Dollar).
             */
            readonly amountPaidCents?: number;
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud created this invoice. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly created?: string;
            /**
             * Format: int64
             * @description Sum that MongoDB credited the specified organization toward this invoice. This parameter expresses its value in cents (100ths of one US Dollar).
             */
            readonly creditsCents?: number;
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud finished the billing period that this invoice covers. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly endDate?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies the invoice submitted to the specified organization. Charges typically post the next day.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly id?: string;
            /** @description List that contains the invoices for organizations linked to the paying organization. */
            readonly linkedInvoices?: components["schemas"]["BillingInvoiceMetadata"][];
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /**
             * @description Unique 24-hexadecimal digit string that identifies the organization charged for services consumed from MongoDB Cloud.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly orgId?: string;
            /**
             * Format: int64
             * @description Sum of sales tax applied to this invoice. This parameter expresses its value in cents (100ths of one US Dollar).
             */
            readonly salesTaxCents?: number;
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud began the billing period that this invoice covers. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly startDate?: string;
            /**
             * Format: int64
             * @description Sum that the specified organization owed to MongoDB when MongoDB issued this invoice. This parameter expresses its value in US Dollars.
             */
            readonly startingBalanceCents?: number;
            /**
             * @description Phase of payment processing in which this invoice exists when you made this request. Accepted phases include:
             *
             *     - `CLOSED`: MongoDB finalized all charges in the billing cycle but has yet to charge the customer.
             *     - `FAILED`: MongoDB attempted to charge the provided credit card but charge for that amount failed.
             *     - `FORGIVEN`: Customer initiated payment which MongoDB later forgave.
             *     - `FREE`: All charges totalled zero so the customer won't be charged.
             *     - `INVOICED`: MongoDB handled these charges using elastic invoicing.
             *     - `PAID`: MongoDB succeeded in charging the provided credit card.
             *     - `PENDING`: Invoice includes charges for the current billing cycle.
             *     - `PREPAID`: Customer has a pre-paid plan so they won't be charged.
             * @enum {string}
             */
            statusName?: "PENDING" | "CLOSED" | "FORGIVEN" | "FAILED" | "PAID" | "FREE" | "PREPAID" | "INVOICED";
            /**
             * Format: int64
             * @description Sum of all positive invoice line items contained in this invoice. This parameter expresses its value in cents (100ths of one US Dollar).
             */
            readonly subtotalCents?: number;
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud last updated the value of this payment. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly updated?: string;
        };
        /**
         * Payment
         * @description Funds transferred to MongoDB to cover the specified service in this invoice.
         */
        BillingPayment: {
            /**
             * Format: int64
             * @description Sum of services that the specified organization consumed in the period covered in this invoice. This parameter expresses its value in cents (100ths of one US Dollar).
             */
            readonly amountBilledCents?: number;
            /**
             * Format: int64
             * @description Sum that the specified organization paid toward the associated invoice. This parameter expresses its value in cents (100ths of one US Dollar).
             */
            readonly amountPaidCents?: number;
            /**
             * Format: date-time
             * @description Date and time when the customer made this payment attempt. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly created?: string;
            /** @description The currency in which payment was paid. This parameter expresses its value in 3-letter ISO 4217 currency code. */
            readonly currency?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies this payment toward the associated invoice.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly id?: string;
            /**
             * Format: int64
             * @description Sum of sales tax applied to this invoice. This parameter expresses its value in cents (100ths of one US Dollar).
             */
            readonly salesTaxCents?: number;
            /**
             * @description Phase of payment processing for the associated invoice when you made this request. These phases include:
             *
             *     - `CANCELLED`: Customer or MongoDB cancelled the payment.
             *     - `ERROR`: Issue arose when attempting to complete payment.
             *     - `FAILED`: MongoDB tried to charge the credit card without success.
             *     - `FAILED_AUTHENTICATION`: Strong Customer Authentication has failed. Confirm that your payment method is authenticated.
             *     - `FORGIVEN`: Customer initiated payment which MongoDB later forgave.
             *     - `INVOICED`: MongoDB issued an invoice that included this line item.
             *     - `NEW`: Customer provided a method of payment, but MongoDB hasn't tried to charge the credit card.
             *     - `PAID`: Customer submitted a successful payment.
             *     - `PARTIAL_PAID`: Customer paid for part of this line item.
             * @enum {string}
             */
            statusName?: "NEW" | "FORGIVEN" | "FAILED" | "PAID" | "PARTIAL_PAID" | "CANCELLED" | "INVOICED" | "FAILED_AUTHENTICATION" | "PROCESSING" | "PENDING_REVERSAL" | "REFUNDED";
            /**
             * Format: int64
             * @description Sum of all positive invoice line items contained in this invoice. This parameter expresses its value in cents (100ths of one US Dollar).
             */
            readonly subtotalCents?: number;
            /** @description The unit price applied to amountBilledCents to compute total payment amount. This value is represented as a decimal string. */
            readonly unitPrice?: string;
            /**
             * Format: date-time
             * @description Date and time when the customer made an update to this payment attempt. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly updated?: string;
        };
        /**
         * Refund
         * @description One payment that MongoDB returned to the organization for this invoice.
         */
        BillingRefund: {
            /**
             * Format: int64
             * @description Sum of the funds returned to the specified organization expressed in cents (100th of US Dollar).
             */
            readonly amountCents?: number;
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud created this refund. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly created?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies the payment that the organization had made.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly paymentId?: string;
            /** @description Justification that MongoDB accepted to return funds to the organization. */
            readonly reason?: string;
        };
        /** @description Settings that describe the clusters in each project that the API key is authorized to view. */
        CloudCluster: {
            /**
             * Format: int32
             * @description Whole number that indicates the quantity of alerts open on the cluster.
             */
            readonly alertCount?: number;
            /** @description Flag that indicates whether authentication is required to access the nodes in this cluster. */
            readonly authEnabled?: boolean;
            /**
             * @description Term that expresses how many nodes of the cluster can be accessed when MongoDB Cloud receives this request. This parameter returns `available` when all nodes are accessible, `warning` only when some nodes in the cluster can be accessed, `unavailable` when the cluster can't be accessed, or `dead` when the cluster has been deactivated.
             * @enum {string}
             */
            readonly availability?: "available" | "dead" | "unavailable" | "warning";
            /** @description Flag that indicates whether the cluster can perform backups. If set to `true`, the cluster can perform backups. You must set this value to `true` for NVMe clusters. Backup uses Cloud Backups for dedicated clusters and Shared Cluster Backups for tenant clusters. If set to `false`, the cluster doesn't use MongoDB Cloud backups. */
            readonly backupEnabled?: boolean;
            /** @description Unique 24-hexadecimal character string that identifies the cluster. Each ``clusterId`` is used only once across all MongoDB Cloud deployments. */
            readonly clusterId?: string;
            /**
             * Format: int64
             * @description Total size of the data stored on each node in the cluster. The resource expresses this value in bytes.
             */
            readonly dataSizeBytes?: number;
            /** @description Human-readable label that identifies the cluster. */
            readonly name?: string;
            /**
             * Format: int32
             * @description Whole number that indicates the quantity of nodes that comprise the cluster.
             */
            readonly nodeCount?: number;
            /** @description Flag that indicates whether TLS authentication is required to access the nodes in this cluster. */
            readonly sslEnabled?: boolean;
            /**
             * @description Human-readable label that indicates the cluster type.
             * @enum {string}
             */
            readonly type?: "REPLICA_SET" | "SHARDED_CLUSTER";
            /** @description List that contains the versions of MongoDB that each node in the cluster runs. */
            readonly versions?: string[];
        };
        CloudDatabaseUser: {
            /**
             * @description Human-readable label that indicates whether the new database user authenticates with the Amazon Web Services (AWS) Identity and Access Management (IAM) credentials associated with the user or the user's role.
             * @default NONE
             * @enum {string}
             */
            awsIAMType: "NONE" | "USER" | "ROLE";
            /**
             * @description The database against which the database user authenticates. Database users must provide both a username and authentication database to log into MongoDB. If the user authenticates with AWS IAM, x.509, LDAP, or OIDC Workload this value should be `$external`. If the user authenticates with SCRAM-SHA or OIDC Workforce, this value should be `admin`.
             * @default admin
             * @enum {string}
             */
            databaseName: "admin" | "$external";
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud deletes the user. This parameter expresses its value in the ISO 8601 timestamp format in UTC and can include the time zone designation. You must specify a future date that falls within one week of making the Application Programming Interface (API) request.
             */
            deleteAfterDate?: string;
            /** @description Description of this database user. */
            description?: string;
            /** @description Unique 24-hexadecimal digit string that identifies the project. */
            groupId: string;
            /** @description List that contains the key-value pairs for tagging and categorizing the MongoDB database user. The labels that you define do not appear in the console. */
            labels?: components["schemas"]["ComponentLabel"][];
            /**
             * @description Part of the Lightweight Directory Access Protocol (LDAP) record that the database uses to authenticate this database user on the LDAP host.
             * @default NONE
             * @enum {string}
             */
            ldapAuthType: "NONE" | "GROUP" | "USER";
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /**
             * @description Human-readable label that indicates whether the new database user or group authenticates with OIDC federated authentication. To create a federated authentication user, specify the value of USER in this field. To create a federated authentication group, specify the value of IDP_GROUP in this field.
             * @default NONE
             * @enum {string}
             */
            oidcAuthType: "NONE" | "IDP_GROUP" | "USER";
            /** @description Alphanumeric string that authenticates this database user against the database specified in `databaseName`. To authenticate with SCRAM-SHA, you must specify this parameter. This parameter doesn't appear in this response. */
            password?: string;
            /** @description List that provides the pairings of one role with one applicable database. */
            roles?: components["schemas"]["DatabaseUserRole"][];
            /** @description List that contains clusters, MongoDB Atlas Data Lakes, and MongoDB Atlas Streams Instances that this database user can access. If omitted, MongoDB Cloud grants the database user access to all the clusters, MongoDB Atlas Data Lakes, and MongoDB Atlas Streams Instances in the project. */
            scopes?: components["schemas"]["UserScope"][];
            /** @description Human-readable label that represents the user that authenticates to MongoDB. The format of this label depends on the method of authentication:
             *
             *     | Authentication Method | Parameter Needed | Parameter Value | username Format |
             *     |---|---|---|---|
             *     | AWS IAM | awsIAMType | ROLE | <abbr title="Amazon Resource Name">ARN</abbr> |
             *     | AWS IAM | awsIAMType | USER | <abbr title="Amazon Resource Name">ARN</abbr> |
             *     | x.509 | x509Type | CUSTOMER | [RFC 2253](https://tools.ietf.org/html/2253) Distinguished Name |
             *     | x.509 | x509Type | MANAGED | [RFC 2253](https://tools.ietf.org/html/2253) Distinguished Name |
             *     | LDAP | ldapAuthType | USER | [RFC 2253](https://tools.ietf.org/html/2253) Distinguished Name |
             *     | LDAP | ldapAuthType | GROUP | [RFC 2253](https://tools.ietf.org/html/2253) Distinguished Name |
             *     | OIDC Workforce | oidcAuthType | IDP_GROUP | Atlas OIDC IdP ID (found in federation settings), followed by a '/', followed by the IdP group name |
             *     | OIDC Workload | oidcAuthType | USER | Atlas OIDC IdP ID (found in federation settings), followed by a '/', followed by the IdP user name |
             *     | SCRAM-SHA | awsIAMType, x509Type, ldapAuthType, oidcAuthType | NONE | Alphanumeric string |
             *      */
            username: string;
            /**
             * @description X.509 method that MongoDB Cloud uses to authenticate the database user.
             *
             *     - For application-managed X.509, specify `MANAGED`.
             *     - For self-managed X.509, specify `CUSTOMER`.
             *
             *     Users created with the `CUSTOMER` method require a Common Name (CN) in the **username** parameter. You must create externally authenticated users on the `$external` database.
             * @default NONE
             * @enum {string}
             */
            x509Type: "NONE" | "CUSTOMER" | "MANAGED";
        };
        CloudGCPProviderSettings: Omit<components["schemas"]["ClusterProviderSettings"], "providerName"> & {
            autoScaling?: components["schemas"]["CloudProviderGCPAutoScaling"];
            /**
             * GCP Instance Sizes
             * @description Cluster tier, with a default storage and memory capacity, that applies to all the data-bearing hosts in your cluster.
             * @enum {string}
             */
            instanceSizeName?: "M10" | "M20" | "M30" | "M40" | "M50" | "M60" | "M80" | "M140" | "M200" | "M250" | "M300" | "M400" | "R40" | "R50" | "R60" | "R80" | "R200" | "R300" | "R400" | "R600";
            /**
             * GCP Regions
             * @description Google Compute Regions.
             * @enum {string}
             */
            regionName?: "EASTERN_US" | "EASTERN_US_AW" | "US_EAST_4" | "US_EAST_4_AW" | "US_EAST_5" | "US_EAST_5_AW" | "US_WEST_2" | "US_WEST_2_AW" | "US_WEST_3" | "US_WEST_3_AW" | "US_WEST_4" | "US_WEST_4_AW" | "US_SOUTH_1" | "US_SOUTH_1_AW" | "CENTRAL_US" | "CENTRAL_US_AW" | "WESTERN_US" | "WESTERN_US_AW" | "NORTH_AMERICA_NORTHEAST_1" | "NORTH_AMERICA_NORTHEAST_2" | "NORTH_AMERICA_SOUTH_1" | "SOUTH_AMERICA_EAST_1" | "SOUTH_AMERICA_WEST_1" | "WESTERN_EUROPE" | "EUROPE_NORTH_1" | "EUROPE_WEST_2" | "EUROPE_WEST_3" | "EUROPE_WEST_4" | "EUROPE_WEST_6" | "EUROPE_WEST_8" | "EUROPE_WEST_9" | "EUROPE_WEST_10" | "EUROPE_WEST_12" | "EUROPE_SOUTHWEST_1" | "EUROPE_CENTRAL_2" | "MIDDLE_EAST_CENTRAL_1" | "MIDDLE_EAST_CENTRAL_2" | "MIDDLE_EAST_WEST_1" | "AUSTRALIA_SOUTHEAST_1" | "AUSTRALIA_SOUTHEAST_2" | "AFRICA_SOUTH_1" | "EASTERN_ASIA_PACIFIC" | "NORTHEASTERN_ASIA_PACIFIC" | "SOUTHEASTERN_ASIA_PACIFIC" | "ASIA_EAST_2" | "ASIA_NORTHEAST_2" | "ASIA_NORTHEAST_3" | "ASIA_SOUTH_1" | "ASIA_SOUTH_2" | "ASIA_SOUTHEAST_2";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "GCP";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "GCP";
        };
        /** @description Range of instance sizes to which your cluster can scale. */
        CloudProviderAWSAutoScaling: {
            compute?: components["schemas"]["AWSComputeAutoScaling"];
        };
        /** @description Details that describe the features linked to the Amazon Web Services (AWS) Identity and Access Management (IAM) role. */
        CloudProviderAccessAWSIAMRole: Omit<WithRequired<components["schemas"]["CloudProviderAccessRole"], "providerName">, "providerName"> & {
            /**
             * @description Amazon Resource Name that identifies the Amazon Web Services (AWS) user account that MongoDB Cloud uses when it assumes the Identity and Access Management (IAM) role.
             * @example arn:aws:iam::772401394250:role/my-test-aws-role
             */
            readonly atlasAWSAccountArn?: string;
            /**
             * Format: uuid
             * @description Unique external ID that MongoDB Cloud uses when it assumes the IAM role in your Amazon Web Services (AWS) account.
             */
            readonly atlasAssumedRoleExternalId?: string;
            /**
             * Format: date-time
             * @description Date and time when someone authorized this role for the specified cloud service provider. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly authorizedDate?: string;
            /**
             * Format: date-time
             * @description Date and time when someone created this role for the specified cloud service provider. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly createdDate?: string;
            /** @description List that contains application features associated with this Amazon Web Services (AWS) Identity and Access Management (IAM) role. */
            readonly featureUsages?: components["schemas"]["CloudProviderAccessFeatureUsage"][];
            /**
             * @description Amazon Resource Name (ARN) that identifies the Amazon Web Services (AWS) Identity and Access Management (IAM) role that MongoDB Cloud assumes when it accesses resources in your AWS account.
             * @example arn:aws:iam::123456789012:root
             */
            iamAssumedRoleArn?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies the role.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly roleId?: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "AWS";
        };
        /** @description Details that describe the features linked to the Amazon Web Services (AWS) Identity and Access Management (IAM) role. */
        CloudProviderAccessAWSIAMRoleRequestUpdate: Omit<WithRequired<components["schemas"]["CloudProviderAccessRoleRequestUpdate"], "providerName">, "providerName"> & {
            /**
             * @description Amazon Resource Name that identifies the Amazon Web Services (AWS) user account that MongoDB Cloud uses when it assumes the Identity and Access Management (IAM) role.
             * @example arn:aws:iam::772401394250:role/my-test-aws-role
             */
            readonly atlasAWSAccountArn?: string;
            /**
             * Format: uuid
             * @description Unique external ID that MongoDB Cloud uses when it assumes the IAM role in your Amazon Web Services (AWS) account.
             */
            readonly atlasAssumedRoleExternalId?: string;
            /**
             * Format: date-time
             * @description Date and time when someone authorized this role for the specified cloud service provider. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly authorizedDate?: string;
            /**
             * Format: date-time
             * @description Date and time when someone created this role for the specified cloud service provider. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly createdDate?: string;
            /** @description List that contains application features associated with this Amazon Web Services (AWS) Identity and Access Management (IAM) role. */
            readonly featureUsages?: components["schemas"]["CloudProviderAccessFeatureUsage"][];
            /**
             * @description Amazon Resource Name (ARN) that identifies the Amazon Web Services (AWS) Identity and Access Management (IAM) role that MongoDB Cloud assumes when it accesses resources in your AWS account.
             * @example arn:aws:iam::123456789012:root
             */
            iamAssumedRoleArn?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies the role.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly roleId?: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "AWS";
        };
        /** @description Details that describe the features linked to the Azure Service Principal. */
        CloudProviderAccessAzureServicePrincipal: Omit<WithRequired<components["schemas"]["CloudProviderAccessRole"], "providerName">, "providerName"> & {
            /**
             * @description Unique 24-hexadecimal digit string that identifies the role.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly _id?: string;
            /**
             * Format: uuid
             * @description Azure Active Directory Application ID of Atlas.
             */
            atlasAzureAppId?: string;
            /**
             * Format: date-time
             * @description Date and time when this Azure Service Principal was created. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly createdDate?: string;
            /** @description List that contains application features associated with this Azure Service Principal. */
            readonly featureUsages?: components["schemas"]["CloudProviderAccessFeatureUsage"][];
            /**
             * Format: date-time
             * @description Date and time when this Azure Service Principal was last updated. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly lastUpdatedDate?: string;
            /**
             * Format: uuid
             * @description UUID string that identifies the Azure Service Principal.
             */
            servicePrincipalId?: string;
            /**
             * Format: uuid
             * @description UUID String that identifies the Azure Active Directory Tenant ID.
             */
            tenantId?: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "AZURE";
        };
        /** @description Details that describe the features linked to the Azure Service Principal. */
        CloudProviderAccessAzureServicePrincipalRequestUpdate: Omit<WithRequired<components["schemas"]["CloudProviderAccessRoleRequestUpdate"], "providerName">, "providerName"> & {
            /**
             * @description Unique 24-hexadecimal digit string that identifies the role.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly _id?: string;
            /**
             * Format: uuid
             * @description Azure Active Directory Application ID of Atlas.
             */
            atlasAzureAppId?: string;
            /**
             * Format: date-time
             * @description Date and time when this Azure Service Principal was created. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly createdDate?: string;
            /** @description List that contains application features associated with this Azure Service Principal. */
            readonly featureUsages?: components["schemas"]["CloudProviderAccessFeatureUsage"][];
            /**
             * Format: date-time
             * @description Date and time when this Azure Service Principal was last updated. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly lastUpdatedDate?: string;
            /**
             * Format: uuid
             * @description UUID string that identifies the Azure Service Principal.
             */
            servicePrincipalId?: string;
            /**
             * Format: uuid
             * @description UUID String that identifies the Azure Active Directory Tenant ID.
             */
            tenantId?: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "AZURE";
        };
        /** @description Details that describe the Atlas Data Lakes linked to this Amazon Web Services (AWS) Identity and Access Management (IAM) role. */
        CloudProviderAccessDataLakeFeatureUsage: Omit<components["schemas"]["CloudProviderAccessFeatureUsage"], "featureType"> & {
            featureId?: components["schemas"]["CloudProviderAccessFeatureUsageDataLakeFeatureId"];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            featureType: "ATLAS_DATA_LAKE";
        };
        /** @description Details that describe the Key Management Service (KMS) linked to this Amazon Web Services (AWS) Identity and Access Management (IAM) role. */
        CloudProviderAccessEncryptionAtRestFeatureUsage: Omit<components["schemas"]["CloudProviderAccessFeatureUsage"], "featureType"> & {
            featureId?: components["schemas"]["ApiAtlasCloudProviderAccessFeatureUsageFeatureIdView"];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            featureType: "ENCRYPTION_AT_REST";
        };
        /** @description Details that describe the Amazon Web Services (AWS) Simple Storage Service (S3) export buckets linked to this AWS Identity and Access Management (IAM) role. */
        CloudProviderAccessExportSnapshotFeatureUsage: Omit<components["schemas"]["CloudProviderAccessFeatureUsage"], "featureType"> & {
            featureId?: components["schemas"]["CloudProviderAccessFeatureUsageExportSnapshotFeatureId"];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            featureType: "EXPORT_SNAPSHOT";
        };
        /** @description MongoDB Cloud features associated with this Amazon Web Services (AWS) Identity and Access Management (IAM) role. */
        CloudProviderAccessFeatureUsage: {
            /**
             * @description Human-readable label that describes one MongoDB Cloud feature linked to this Amazon Web Services (AWS) Identity and Access Management (IAM) role.
             * @enum {string}
             */
            readonly featureType?: "ATLAS_DATA_LAKE" | "ENCRYPTION_AT_REST" | "EXPORT_SNAPSHOT" | "PUSH_BASED_LOG_EXPORT";
        };
        /** @description Identifying characteristics about the data lake linked to this Amazon Web Services (AWS) Identity and Access Management (IAM) role. */
        CloudProviderAccessFeatureUsageDataLakeFeatureId: {
            /**
             * @description Unique 24-hexadecimal digit string that identifies your project.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly groupId?: string;
            /** @description Human-readable label that identifies the data lake. */
            name?: string;
        };
        /** @description Identifying characteristics about the Amazon Web Services (AWS) Simple Storage Service (S3) export bucket linked to this AWS Identity and Access Management (IAM) role. */
        CloudProviderAccessFeatureUsageExportSnapshotFeatureId: {
            /**
             * @description Unique 24-hexadecimal digit string that identifies the AWS S3 bucket to which you export your snapshots.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly exportBucketId?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies your project.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly groupId?: string;
        };
        /** @description Identifying characteristics about the Amazon Web Services (AWS) Simple Storage Service (S3) export bucket linked to this AWS Identity and Access Management (IAM) role. */
        CloudProviderAccessFeatureUsagePushBasedLogExportFeatureId: {
            /** @description Name of the AWS S3 bucket to which your logs will be exported to. */
            readonly bucketName?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies your project.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly groupId?: string;
        };
        /** @description Details that describe the features linked to the GCP Service Account. */
        CloudProviderAccessGCPServiceAccount: Omit<WithRequired<components["schemas"]["CloudProviderAccessRole"], "providerName">, "providerName"> & {
            /**
             * Format: date-time
             * @description Date and time when this Google Service Account was created. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly createdDate?: string;
            /** @description List that contains application features associated with this Google Service Account. */
            readonly featureUsages?: components["schemas"]["CloudProviderAccessFeatureUsage"][];
            /** @description Email address for the Google Service Account created by Atlas. */
            gcpServiceAccountForAtlas?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies the role.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly roleId?: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "GCP";
        };
        /** @description Details that describe the features linked to the GCP Service Account. */
        CloudProviderAccessGCPServiceAccountRequestUpdate: Omit<WithRequired<components["schemas"]["CloudProviderAccessRoleRequestUpdate"], "providerName">, "providerName"> & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "GCP";
        };
        /** @description Details that describe the Amazon Web Services (AWS) Simple Storage Service (S3) export buckets linked to this AWS Identity and Access Management (IAM) role. */
        CloudProviderAccessPushBasedLogExportFeatureUsage: Omit<components["schemas"]["CloudProviderAccessFeatureUsage"], "featureType"> & {
            featureId?: components["schemas"]["CloudProviderAccessFeatureUsagePushBasedLogExportFeatureId"];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            featureType: "PUSH_BASED_LOG_EXPORT";
        };
        /** @description Cloud provider access role. */
        CloudProviderAccessRole: {
            /**
             * @description Human-readable label that identifies the cloud provider of the role.
             * @enum {string}
             */
            providerName: "AWS" | "AZURE" | "GCP";
        };
        /** @description Cloud provider access role. */
        CloudProviderAccessRoleRequestUpdate: {
            /**
             * @description Human-readable label that identifies the cloud provider of the role.
             * @enum {string}
             */
            providerName: "AWS" | "AZURE" | "GCP";
        };
        /** @description Range of instance sizes to which your cluster can scale. */
        CloudProviderAzureAutoScaling: {
            compute?: components["schemas"]["AzureComputeAutoScalingRules"];
        };
        /** @description Collection of settings that configures the network container for a virtual private connection on Amazon Web Services. */
        CloudProviderContainer: {
            /**
             * @description Unique 24-hexadecimal digit string that identifies the network peering container.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly id?: string;
            /**
             * @description Cloud service provider that serves the requested network peering containers.
             * @enum {string}
             */
            providerName?: "AWS" | "GCP" | "AZURE" | "TENANT" | "SERVERLESS";
            /** @description Flag that indicates whether MongoDB Cloud clusters exist in the specified network peering container. */
            readonly provisioned?: boolean;
        } & (components["schemas"]["AzureCloudProviderContainer"] | components["schemas"]["GCPCloudProviderContainer"] | components["schemas"]["AWSCloudProviderContainer"]);
        /** @description Range of instance sizes to which your cluster can scale. */
        CloudProviderGCPAutoScaling: {
            compute?: components["schemas"]["GCPComputeAutoScaling"];
        };
        /**
         * Cloud Service Provider Settings for Multi-Cloud Clusters
         * @description Cloud service provider on which MongoDB Cloud provisions the hosts.
         */
        CloudRegionConfig: {
            electableSpecs?: components["schemas"]["HardwareSpec"];
            /**
             * Format: int32
             * @description Precedence is given to this region when a primary election occurs. If your **regionConfigs** has only **readOnlySpecs**, **analyticsSpecs**, or both, set this value to `0`. If you have multiple **regionConfigs** objects (your cluster is multi-region or multi-cloud), they must have priorities in descending order. The highest priority is `7`.
             *
             *     **Example:** If you have three regions, their priorities would be `7`, `6`, and `5` respectively. If you added two more regions for supporting electable nodes, the priorities of those regions would be `4` and `3` respectively.
             */
            priority?: number;
            /**
             * @description Cloud service provider on which MongoDB Cloud provisions the hosts. Set dedicated clusters to `AWS`, `GCP`, `AZURE` or `TENANT`.
             * @enum {string}
             */
            providerName?: "AWS" | "AZURE" | "GCP" | "TENANT";
            /** @description Physical location of your MongoDB cluster nodes. The region you choose can affect network latency for clients accessing your databases. The region name is only returned in the response for single-region clusters. When MongoDB Cloud deploys a dedicated cluster, it checks if a VPC or VPC connection exists for that provider and region. If not, MongoDB Cloud creates them as part of the deployment. It assigns the VPC a Classless Inter-Domain Routing (CIDR) block. To limit a new VPC peering connection to one Classless Inter-Domain Routing (CIDR) block and region, create the connection first. Deploy the cluster after the connection starts. GCP Clusters and Multi-region clusters require one VPC peering connection for each region. MongoDB nodes can use only the peering connection that resides in the same region as the nodes to communicate with the peered VPC. */
            regionName?: ("US_GOV_WEST_1" | "US_GOV_EAST_1" | "US_EAST_1" | "US_EAST_2" | "US_WEST_1" | "US_WEST_2" | "CA_CENTRAL_1" | "EU_NORTH_1" | "EU_WEST_1" | "EU_WEST_2" | "EU_WEST_3" | "EU_CENTRAL_1" | "EU_CENTRAL_2" | "AP_EAST_1" | "AP_NORTHEAST_1" | "AP_NORTHEAST_2" | "AP_NORTHEAST_3" | "AP_SOUTHEAST_1" | "AP_SOUTHEAST_2" | "AP_SOUTHEAST_3" | "AP_SOUTHEAST_4" | "AP_SOUTH_1" | "AP_SOUTH_2" | "SA_EAST_1" | "CN_NORTH_1" | "CN_NORTHWEST_1" | "ME_SOUTH_1" | "ME_CENTRAL_1" | "AF_SOUTH_1" | "EU_SOUTH_1" | "EU_SOUTH_2" | "IL_CENTRAL_1" | "CA_WEST_1" | "AP_SOUTHEAST_5" | "AP_SOUTHEAST_7" | "MX_CENTRAL_1" | "GLOBAL") | ("US_CENTRAL" | "US_EAST" | "US_EAST_2" | "US_NORTH_CENTRAL" | "US_WEST" | "US_SOUTH_CENTRAL" | "EUROPE_NORTH" | "EUROPE_WEST" | "US_WEST_CENTRAL" | "US_WEST_2" | "US_WEST_3" | "CANADA_EAST" | "CANADA_CENTRAL" | "BRAZIL_SOUTH" | "BRAZIL_SOUTHEAST" | "AUSTRALIA_CENTRAL" | "AUSTRALIA_CENTRAL_2" | "AUSTRALIA_EAST" | "AUSTRALIA_SOUTH_EAST" | "GERMANY_WEST_CENTRAL" | "GERMANY_NORTH" | "SWEDEN_CENTRAL" | "SWEDEN_SOUTH" | "SWITZERLAND_NORTH" | "SWITZERLAND_WEST" | "UK_SOUTH" | "UK_WEST" | "NORWAY_EAST" | "NORWAY_WEST" | "INDIA_CENTRAL" | "INDIA_SOUTH" | "INDIA_WEST" | "CHINA_EAST" | "CHINA_NORTH" | "ASIA_EAST" | "JAPAN_EAST" | "JAPAN_WEST" | "ASIA_SOUTH_EAST" | "KOREA_CENTRAL" | "KOREA_SOUTH" | "FRANCE_CENTRAL" | "FRANCE_SOUTH" | "SOUTH_AFRICA_NORTH" | "SOUTH_AFRICA_WEST" | "UAE_CENTRAL" | "UAE_NORTH" | "QATAR_CENTRAL") | ("EASTERN_US" | "EASTERN_US_AW" | "US_EAST_4" | "US_EAST_4_AW" | "US_EAST_5" | "US_EAST_5_AW" | "US_WEST_2" | "US_WEST_2_AW" | "US_WEST_3" | "US_WEST_3_AW" | "US_WEST_4" | "US_WEST_4_AW" | "US_SOUTH_1" | "US_SOUTH_1_AW" | "CENTRAL_US" | "CENTRAL_US_AW" | "WESTERN_US" | "WESTERN_US_AW" | "NORTH_AMERICA_NORTHEAST_1" | "NORTH_AMERICA_NORTHEAST_2" | "NORTH_AMERICA_SOUTH_1" | "SOUTH_AMERICA_EAST_1" | "SOUTH_AMERICA_WEST_1" | "WESTERN_EUROPE" | "EUROPE_NORTH_1" | "EUROPE_WEST_2" | "EUROPE_WEST_3" | "EUROPE_WEST_4" | "EUROPE_WEST_6" | "EUROPE_WEST_8" | "EUROPE_WEST_9" | "EUROPE_WEST_10" | "EUROPE_WEST_12" | "EUROPE_SOUTHWEST_1" | "EUROPE_CENTRAL_2" | "MIDDLE_EAST_CENTRAL_1" | "MIDDLE_EAST_CENTRAL_2" | "MIDDLE_EAST_WEST_1" | "AUSTRALIA_SOUTHEAST_1" | "AUSTRALIA_SOUTHEAST_2" | "AFRICA_SOUTH_1" | "EASTERN_ASIA_PACIFIC" | "NORTHEASTERN_ASIA_PACIFIC" | "SOUTHEASTERN_ASIA_PACIFIC" | "ASIA_EAST_2" | "ASIA_NORTHEAST_2" | "ASIA_NORTHEAST_3" | "ASIA_SOUTH_1" | "ASIA_SOUTH_2" | "ASIA_SOUTHEAST_2");
        } & (components["schemas"]["AWSRegionConfig"] | components["schemas"]["AzureRegionConfig"] | components["schemas"]["GCPRegionConfig"] | components["schemas"]["TenantRegionConfig"]);
        /**
         * Cloud Service Provider Settings
         * @description Cloud service provider on which MongoDB Cloud provisions the hosts.
         */
        CloudRegionConfig20240805: {
            electableSpecs?: components["schemas"]["HardwareSpec20240805"];
            /**
             * Format: int32
             * @description Precedence is given to this region when a primary election occurs. If your **regionConfigs** has only **readOnlySpecs**, **analyticsSpecs**, or both, set this value to `0`. If you have multiple **regionConfigs** objects (your cluster is multi-region or multi-cloud), they must have priorities in descending order. The highest priority is `7`.
             *
             *     **Example:** If you have three regions, their priorities would be `7`, `6`, and `5` respectively. If you added two more regions for supporting electable nodes, the priorities of those regions would be `4` and `3` respectively.
             */
            priority?: number;
            /**
             * @description Cloud service provider on which MongoDB Cloud provisions the hosts. Set dedicated clusters to `AWS`, `GCP`, `AZURE` or `TENANT`.
             * @enum {string}
             */
            providerName?: "AWS" | "AZURE" | "GCP" | "TENANT";
            /** @description Physical location of your MongoDB cluster nodes. The region you choose can affect network latency for clients accessing your databases. The region name is only returned in the response for single-region clusters. When MongoDB Cloud deploys a dedicated cluster, it checks if a VPC or VPC connection exists for that provider and region. If not, MongoDB Cloud creates them as part of the deployment. It assigns the VPC a Classless Inter-Domain Routing (CIDR) block. To limit a new VPC peering connection to one Classless Inter-Domain Routing (CIDR) block and region, create the connection first. Deploy the cluster after the connection starts. GCP Clusters and Multi-region clusters require one VPC peering connection for each region. MongoDB nodes can use only the peering connection that resides in the same region as the nodes to communicate with the peered VPC. */
            regionName?: ("US_GOV_WEST_1" | "US_GOV_EAST_1" | "US_EAST_1" | "US_EAST_2" | "US_WEST_1" | "US_WEST_2" | "CA_CENTRAL_1" | "EU_NORTH_1" | "EU_WEST_1" | "EU_WEST_2" | "EU_WEST_3" | "EU_CENTRAL_1" | "EU_CENTRAL_2" | "AP_EAST_1" | "AP_NORTHEAST_1" | "AP_NORTHEAST_2" | "AP_NORTHEAST_3" | "AP_SOUTHEAST_1" | "AP_SOUTHEAST_2" | "AP_SOUTHEAST_3" | "AP_SOUTHEAST_4" | "AP_SOUTH_1" | "AP_SOUTH_2" | "SA_EAST_1" | "CN_NORTH_1" | "CN_NORTHWEST_1" | "ME_SOUTH_1" | "ME_CENTRAL_1" | "AF_SOUTH_1" | "EU_SOUTH_1" | "EU_SOUTH_2" | "IL_CENTRAL_1" | "CA_WEST_1" | "AP_SOUTHEAST_5" | "AP_SOUTHEAST_7" | "MX_CENTRAL_1" | "GLOBAL") | ("US_CENTRAL" | "US_EAST" | "US_EAST_2" | "US_NORTH_CENTRAL" | "US_WEST" | "US_SOUTH_CENTRAL" | "EUROPE_NORTH" | "EUROPE_WEST" | "US_WEST_CENTRAL" | "US_WEST_2" | "US_WEST_3" | "CANADA_EAST" | "CANADA_CENTRAL" | "BRAZIL_SOUTH" | "BRAZIL_SOUTHEAST" | "AUSTRALIA_CENTRAL" | "AUSTRALIA_CENTRAL_2" | "AUSTRALIA_EAST" | "AUSTRALIA_SOUTH_EAST" | "GERMANY_WEST_CENTRAL" | "GERMANY_NORTH" | "SWEDEN_CENTRAL" | "SWEDEN_SOUTH" | "SWITZERLAND_NORTH" | "SWITZERLAND_WEST" | "UK_SOUTH" | "UK_WEST" | "NORWAY_EAST" | "NORWAY_WEST" | "INDIA_CENTRAL" | "INDIA_SOUTH" | "INDIA_WEST" | "CHINA_EAST" | "CHINA_NORTH" | "ASIA_EAST" | "JAPAN_EAST" | "JAPAN_WEST" | "ASIA_SOUTH_EAST" | "KOREA_CENTRAL" | "KOREA_SOUTH" | "FRANCE_CENTRAL" | "FRANCE_SOUTH" | "SOUTH_AFRICA_NORTH" | "SOUTH_AFRICA_WEST" | "UAE_CENTRAL" | "UAE_NORTH" | "QATAR_CENTRAL") | ("EASTERN_US" | "EASTERN_US_AW" | "US_EAST_4" | "US_EAST_4_AW" | "US_EAST_5" | "US_EAST_5_AW" | "US_WEST_2" | "US_WEST_2_AW" | "US_WEST_3" | "US_WEST_3_AW" | "US_WEST_4" | "US_WEST_4_AW" | "US_SOUTH_1" | "US_SOUTH_1_AW" | "CENTRAL_US" | "CENTRAL_US_AW" | "WESTERN_US" | "WESTERN_US_AW" | "NORTH_AMERICA_NORTHEAST_1" | "NORTH_AMERICA_NORTHEAST_2" | "NORTH_AMERICA_SOUTH_1" | "SOUTH_AMERICA_EAST_1" | "SOUTH_AMERICA_WEST_1" | "WESTERN_EUROPE" | "EUROPE_NORTH_1" | "EUROPE_WEST_2" | "EUROPE_WEST_3" | "EUROPE_WEST_4" | "EUROPE_WEST_6" | "EUROPE_WEST_8" | "EUROPE_WEST_9" | "EUROPE_WEST_10" | "EUROPE_WEST_12" | "EUROPE_SOUTHWEST_1" | "EUROPE_CENTRAL_2" | "MIDDLE_EAST_CENTRAL_1" | "MIDDLE_EAST_CENTRAL_2" | "MIDDLE_EAST_WEST_1" | "AUSTRALIA_SOUTHEAST_1" | "AUSTRALIA_SOUTHEAST_2" | "AFRICA_SOUTH_1" | "EASTERN_ASIA_PACIFIC" | "NORTHEASTERN_ASIA_PACIFIC" | "SOUTHEASTERN_ASIA_PACIFIC" | "ASIA_EAST_2" | "ASIA_NORTHEAST_2" | "ASIA_NORTHEAST_3" | "ASIA_SOUTH_1" | "ASIA_SOUTH_2" | "ASIA_SOUTHEAST_2");
        } & (components["schemas"]["AWSRegionConfig20240805"] | components["schemas"]["AzureRegionConfig20240805"] | components["schemas"]["GCPRegionConfig20240805"] | components["schemas"]["TenantRegionConfig20240805"]);
        /**
         * Cluster Alerts
         * @description Cluster alert notifies different activities and conditions about cluster of mongod hosts.
         */
        ClusterAlertView: {
            /**
             * Format: date-time
             * @description Date and time until which this alert has been acknowledged. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter if a MongoDB User previously acknowledged this alert.
             *
             *     - To acknowledge this alert forever, set the parameter value to 100 years in the future.
             *
             *     - To unacknowledge a previously acknowledged alert, do not set this parameter value.
             */
            acknowledgedUntil?: string;
            /**
             * @description Comment that a MongoDB Cloud user submitted when acknowledging the alert.
             * @example Expiration on 3/19.  Silencing for 7days.
             */
            acknowledgementComment?: string;
            /**
             * Format: email
             * @description MongoDB Cloud username of the person who acknowledged the alert. The response returns this parameter if a MongoDB Cloud user previously acknowledged this alert.
             */
            readonly acknowledgingUsername?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies the alert configuration that sets this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly alertConfigId: string;
            /**
             * @description Human-readable label that identifies the cluster to which this alert applies. This resource returns this parameter for alerts of events impacting backups, replica sets, or sharded clusters.
             * @example cluster1
             */
            readonly clusterName?: string;
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud created this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly created: string;
            eventTypeName: components["schemas"]["ClusterEventTypeViewAlertable"];
            /**
             * @description Unique 24-hexadecimal digit string that identifies the project that owns this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly groupId?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly id: string;
            /**
             * Format: date-time
             * @description Date and time that any notifications were last sent for this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter if MongoDB Cloud has sent notifications for this alert.
             */
            readonly lastNotified?: string;
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /**
             * @description Unique 24-hexadecimal character string that identifies the organization that owns the project to which this alert applies.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly orgId?: string;
            /**
             * Format: date-time
             * @description Date and time that this alert changed to `"status" : "CLOSED"`. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter once `"status" : "CLOSED"`.
             */
            readonly resolved?: string;
            /**
             * @description State of this alert at the time you requested its details.
             * @example OPEN
             * @enum {string}
             */
            readonly status: "CANCELLED" | "CLOSED" | "OPEN" | "TRACKING";
            /**
             * Format: date-time
             * @description Date and time when someone last updated this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly updated: string;
        };
        /**
         * Cluster Connection Strings
         * @description Collection of Uniform Resource Locators that point to the MongoDB database.
         */
        ClusterConnectionStrings: {
            /** @description Private endpoint-aware connection strings that use AWS-hosted clusters with Amazon Web Services (AWS) PrivateLink. Each key identifies an Amazon Web Services (AWS) interface endpoint. Each value identifies the related `mongodb://` connection string that you use to connect to MongoDB Cloud through the interface endpoint that the key names. */
            readonly awsPrivateLink?: {
                [key: string]: string;
            };
            /** @description Private endpoint-aware connection strings that use AWS-hosted clusters with Amazon Web Services (AWS) PrivateLink. Each key identifies an Amazon Web Services (AWS) interface endpoint. Each value identifies the related `mongodb://` connection string that you use to connect to Atlas through the interface endpoint that the key names. If the cluster uses an optimized connection string, `awsPrivateLinkSrv` contains the optimized connection string. If the cluster has the non-optimized (legacy) connection string, `awsPrivateLinkSrv` contains the non-optimized connection string even if an optimized connection string is also present. */
            readonly awsPrivateLinkSrv?: {
                [key: string]: string;
            };
            /** @description Network peering connection strings for each interface Virtual Private Cloud (VPC) endpoint that you configured to connect to this cluster. This connection string uses the `mongodb+srv://` protocol. The resource returns this parameter once someone creates a network peering connection to this cluster. This protocol tells the application to look up the host seed list in the Domain Name System (DNS). This list synchronizes with the nodes in a cluster. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn't, use connectionStrings.private. For Amazon Web Services (AWS) clusters, this resource returns this parameter only if you enable custom DNS. */
            readonly private?: string;
            /** @description List of private endpoint-aware connection strings that you can use to connect to this cluster through a private endpoint. This parameter returns only if you deployed a private endpoint to all regions to which you deployed this clusters' nodes. */
            readonly privateEndpoint?: components["schemas"]["ClusterDescriptionConnectionStringsPrivateEndpoint"][];
            /** @description Network peering connection strings for each interface Virtual Private Cloud (VPC) endpoint that you configured to connect to this cluster. This connection string uses the `mongodb+srv://` protocol. The resource returns this parameter when someone creates a network peering connection to this cluster. This protocol tells the application to look up the host seed list in the Domain Name System (DNS). This list synchronizes with the nodes in a cluster. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to append the seed list or change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your driver supports it. If it doesn't, use `connectionStrings.private`. For Amazon Web Services (AWS) clusters, this parameter returns only if you [enable custom DNS](https://docs.atlas.mongodb.com/reference/api/aws-custom-dns-update/). */
            readonly privateSrv?: string;
            /** @description Public connection string that you can use to connect to this cluster. This connection string uses the `mongodb://` protocol. */
            readonly standard?: string;
            /** @description Public connection string that you can use to connect to this cluster. This connection string uses the `mongodb+srv://` protocol. */
            readonly standardSrv?: string;
        };
        ClusterDescription20240805: {
            /**
             * Format: date-time
             * @description If reconfiguration is necessary to regain a primary due to a regional outage, submit this field alongside your topology reconfiguration to request a new regional outage resistant topology. Forced reconfigurations during an outage of the majority of electable nodes carry a risk of data loss if replicated writes (even majority committed writes) have not been replicated to the new primary node. MongoDB Atlas docs contain more information. To proceed with an operation which carries that risk, set **acceptDataRisksAndForceReplicaSetReconfig** to the current date. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            acceptDataRisksAndForceReplicaSetReconfig?: string;
            advancedConfiguration?: components["schemas"]["ApiAtlasClusterAdvancedConfigurationView"];
            /**
             * @description Flag that indicates whether the cluster can perform backups. If set to `true`, the cluster can perform backups. You must set this value to `true` for NVMe clusters. Backup uses Cloud Backups for dedicated clusters and [Shared Cluster Backups](https://docs.atlas.mongodb.com/backup/shared-tier/overview/) for tenant clusters. If set to `false`, the cluster doesn't use backups.
             * @default false
             */
            backupEnabled: boolean;
            biConnector?: components["schemas"]["BiConnector"];
            /**
             * @description Configuration of nodes that comprise the cluster.
             * @enum {string}
             */
            clusterType?: "REPLICASET" | "SHARDED" | "GEOSHARDED";
            /**
             * @description Config Server Management Mode for creating or updating a sharded cluster.
             *
             *     When configured as ATLAS_MANAGED, atlas may automatically switch the cluster's config server type for optimal performance and savings.
             *
             *     When configured as FIXED_TO_DEDICATED, the cluster will always use a dedicated config server.
             * @default ATLAS_MANAGED
             * @enum {string}
             */
            configServerManagementMode: "ATLAS_MANAGED" | "FIXED_TO_DEDICATED";
            /**
             * @description Describes a sharded cluster's config server type.
             * @enum {string}
             */
            readonly configServerType?: "DEDICATED" | "EMBEDDED";
            connectionStrings?: components["schemas"]["ClusterConnectionStrings"];
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud created this cluster. This parameter expresses its value in ISO 8601 format in UTC.
             */
            readonly createDate?: string;
            /**
             * @description Disk warming mode selection.
             * @default FULLY_WARMED
             * @enum {string}
             */
            diskWarmingMode: "FULLY_WARMED" | "VISIBLE_EARLIER";
            /**
             * @description Cloud service provider that manages your customer keys to provide an additional layer of encryption at rest for the cluster. To enable customer key management for encryption at rest, the cluster **replicationSpecs[n].regionConfigs[m].{type}Specs.instanceSize** setting must be `M10` or higher and `"backupEnabled" : false` or omitted entirely.
             * @enum {string}
             */
            encryptionAtRestProvider?: "NONE" | "AWS" | "AZURE" | "GCP";
            /** @description Feature compatibility version of the cluster. This will always appear regardless of whether FCV is pinned. */
            readonly featureCompatibilityVersion?: string;
            /**
             * Format: date-time
             * @description Feature compatibility version expiration date. Will only appear if FCV is pinned. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly featureCompatibilityVersionExpirationDate?: string;
            /** @description Set this field to configure the Sharding Management Mode when creating a new Global Cluster.
             *
             *     When set to false, the management mode is set to Atlas-Managed Sharding. This mode fully manages the sharding of your Global Cluster and is built to provide a seamless deployment experience.
             *
             *     When set to true, the management mode is set to Self-Managed Sharding. This mode leaves the management of shards in your hands and is built to provide an advanced and flexible deployment experience.
             *
             *     This setting cannot be changed once the cluster is deployed. */
            globalClusterSelfManagedSharding?: boolean;
            /**
             * @description Unique 24-hexadecimal character string that identifies the project.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly groupId?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies the cluster.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly id?: string;
            /**
             * @deprecated
             * @description Collection of key-value pairs between 1 to 255 characters in length that tag and categorize the cluster. The MongoDB Cloud console doesn't display your labels.
             *
             *     Cluster labels are deprecated and will be removed in a future release. We strongly recommend that you use Resource Tags instead.
             */
            labels?: components["schemas"]["ComponentLabel"][];
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            mongoDBEmployeeAccessGrant?: components["schemas"]["EmployeeAccessGrantView"];
            /** @description MongoDB major version of the cluster. Set to the binary major version.
             *
             *     On creation: Choose from the available versions of MongoDB, or leave unspecified for the current recommended default in the MongoDB Cloud platform. The recommended version is a recent Long Term Support version. The default is not guaranteed to be the most recently released version throughout the entire release cycle. For versions available in a specific project, see the linked documentation or use the API endpoint for [project LTS versions endpoint](#tag/Projects/operation/getProjectLtsVersions).
             *
             *      On update: Increase version only by 1 major version at a time. If the cluster is pinned to a MongoDB feature compatibility version exactly one major version below the current MongoDB version, the MongoDB version can be downgraded to the previous major version. */
            mongoDBMajorVersion?: string;
            /** @description Version of MongoDB that the cluster runs. */
            readonly mongoDBVersion?: string;
            /** @description Human-readable label that identifies the cluster. */
            name?: string;
            /** @description Flag that indicates whether the cluster is paused. */
            paused?: boolean;
            /** @description Flag that indicates whether the cluster uses continuous cloud backups. */
            pitEnabled?: boolean;
            /** @description Enable or disable log redaction.
             *
             *     This setting configures the ``mongod`` or ``mongos`` to redact any document field contents from a message accompanying a given log event before logging. This prevents the program from writing potentially sensitive data stored on the database to the diagnostic log. Metadata such as error or operation codes, line numbers, and source file names are still visible in the logs.
             *
             *     Use ``redactClientLogData`` in conjunction with Encryption at Rest and TLS/SSL (Transport Encryption) to assist compliance with regulatory requirements.
             *
             *     *Note*: changing this setting on a cluster will trigger a rolling restart as soon as the cluster is updated. */
            redactClientLogData?: boolean;
            /**
             * @description Set this field to configure the replica set scaling mode for your cluster.
             *
             *     By default, Atlas scales under WORKLOAD_TYPE. This mode allows Atlas to scale your analytics nodes in parallel to your operational nodes.
             *
             *     When configured as SEQUENTIAL, Atlas scales all nodes sequentially. This mode is intended for steady-state workloads and applications performing latency-sensitive secondary reads.
             *
             *     When configured as NODE_TYPE, Atlas scales your electable nodes in parallel with your read-only and analytics nodes. This mode is intended for large, dynamic workloads requiring frequent and timely cluster tier scaling. This is the fastest scaling strategy, but it might impact latency of workloads when performing extensive secondary reads.
             * @default WORKLOAD_TYPE
             * @enum {string}
             */
            replicaSetScalingStrategy: "SEQUENTIAL" | "WORKLOAD_TYPE" | "NODE_TYPE";
            /** @description List of settings that configure your cluster regions. This array has one object per shard representing node configurations in each shard. For replica sets there is only one object representing node configurations. */
            replicationSpecs?: components["schemas"]["ReplicationSpec20240805"][];
            /**
             * @description Root Certificate Authority that MongoDB Cloud cluster uses. MongoDB Cloud supports Internet Security Research Group.
             * @default ISRGROOTX1
             * @enum {string}
             */
            rootCertType: "ISRGROOTX1";
            /**
             * @description Human-readable label that indicates the current operating condition of this cluster.
             * @enum {string}
             */
            readonly stateName?: "IDLE" | "CREATING" | "UPDATING" | "DELETING" | "REPAIRING";
            /** @description List that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. */
            tags?: components["schemas"]["ResourceTag"][];
            /**
             * @description Flag that indicates whether termination protection is enabled on the cluster. If set to `true`, MongoDB Cloud won't delete the cluster. If set to `false`, MongoDB Cloud will delete the cluster.
             * @default false
             */
            terminationProtectionEnabled: boolean;
            /**
             * @description Method by which the cluster maintains the MongoDB versions. If value is `CONTINUOUS`, you must not specify **mongoDBMajorVersion**.
             * @default LTS
             * @enum {string}
             */
            versionReleaseSystem: "LTS" | "CONTINUOUS";
        };
        /**
         * Cluster Private Endpoint Connection String
         * @description Private endpoint-aware connection string that you can use to connect to this cluster through a private endpoint.
         */
        ClusterDescriptionConnectionStringsPrivateEndpoint: {
            /** @description Private endpoint-aware connection string that uses the `mongodb://` protocol to connect to MongoDB Cloud through a private endpoint. */
            readonly connectionString?: string;
            /** @description List that contains the private endpoints through which you connect to MongoDB Cloud when you use **connectionStrings.privateEndpoint[n].connectionString** or **connectionStrings.privateEndpoint[n].srvConnectionString**. */
            readonly endpoints?: components["schemas"]["ClusterDescriptionConnectionStringsPrivateEndpointEndpoint"][];
            /** @description Private endpoint-aware connection string that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in the Domain Name System (DNS). This list synchronizes with the nodes in a cluster. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to append the seed list or change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application supports it. If it doesn't, use connectionStrings.privateEndpoint[n].connectionString. */
            readonly srvConnectionString?: string;
            /** @description Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster supports it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[n].srvConnectionString. */
            readonly srvShardOptimizedConnectionString?: string;
            /**
             * @description MongoDB process type to which your application connects. Use `MONGOD` for replica sets and `MONGOS` for sharded clusters.
             * @enum {string}
             */
            readonly type?: "MONGOD" | "MONGOS";
        };
        /**
         * Cluster Private Endpoint Connection Strings Endpoint
         * @description Details of a private endpoint deployed for this cluster.
         */
        ClusterDescriptionConnectionStringsPrivateEndpointEndpoint: {
            /** @description Unique string that the cloud provider uses to identify the private endpoint. */
            readonly endpointId?: string;
            /**
             * @description Cloud provider in which MongoDB Cloud deploys the private endpoint.
             * @enum {string}
             */
            readonly providerName?: "AWS" | "AZURE" | "GCP";
            /** @description Region where the private endpoint is deployed. */
            readonly region?: string;
        };
        /**
         * Cluster Event Types
         * @description Event type that triggers an alert.
         * @example CLUSTER_MONGOS_IS_MISSING
         * @enum {string}
         */
        ClusterEventTypeViewAlertable: "CLUSTER_MONGOS_IS_MISSING" | "CLUSTER_AGENT_IN_CRASH_LOOP";
        ClusterFlexProviderSettings: Omit<components["schemas"]["ClusterProviderSettings"], "providerName"> & {
            /**
             * @description Cloud service provider on which MongoDB Cloud provisioned the multi-tenant host. The resource returns this parameter when **providerSettings.providerName** is `FLEX` and **providerSetting.instanceSizeName** is `FLEX`.
             * @enum {string}
             */
            backingProviderName?: "AWS" | "GCP" | "AZURE";
            /**
             * Flex Instance Sizes
             * @description Cluster tier, with a default storage and memory capacity, that applies to all the data-bearing hosts in your cluster. You must set **providerSettings.providerName** to `FLEX` and specify the cloud service provider in **providerSettings.backingProviderName**.
             * @enum {string}
             */
            instanceSizeName?: "FLEX";
            /** @description Human-readable label that identifies the geographic location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases. For a complete list of region names, see [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/#std-label-amazon-aws), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), and [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/). */
            regionName?: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "FLEX";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "FLEX";
        };
        /** @description Range of instance sizes to which your cluster can scale. */
        ClusterFreeAutoScaling: {
            compute?: components["schemas"]["FreeComputeAutoScalingRules"];
        };
        ClusterFreeProviderSettings: Omit<components["schemas"]["ClusterProviderSettings"], "providerName"> & {
            autoScaling?: components["schemas"]["ClusterFreeAutoScaling"];
            /**
             * @description Cloud service provider on which MongoDB Cloud provisioned the multi-tenant host. The resource returns this parameter when **providerSettings.providerName** is `TENANT` and **providerSetting.instanceSizeName** is `M0`, `M2` or `M5`.
             *
             *     Please note that using an instanceSize of M2 or M5 will create a Flex cluster instead. Support for the instanceSize of M2 or M5 will be discontinued in January 2026. We recommend using the createFlexCluster API for such configurations moving forward.
             * @enum {string}
             */
            backingProviderName?: "AWS" | "GCP" | "AZURE";
            /**
             * @description The true tenant instance size. This is present to support backwards compatibility for deprecated provider types and/or instance sizes.
             * @enum {string}
             */
            readonly effectiveInstanceSizeName?: "FLEX" | "M2" | "M5" | "M0";
            /**
             * Tenant Instance Sizes
             * @description Cluster tier, with a default storage and memory capacity, that applies to all the data-bearing hosts in your cluster. You must set **providerSettings.providerName** to `TENANT` and specify the cloud service provider in **providerSettings.backingProviderName**.
             * @enum {string}
             */
            instanceSizeName?: "M0" | "M2" | "M5";
            /** @description Human-readable label that identifies the geographic location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases. For a complete list of region names, see [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/#std-label-amazon-aws), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), and [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/). For multi-region clusters, see **replicationSpec.{region}**. */
            regionName?: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "TENANT";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "TENANT";
        };
        /**
         * Cloud Service Provider Settings for a Cluster
         * @description Group of cloud provider settings that configure the provisioned MongoDB hosts.
         */
        ClusterProviderSettings: {
            providerName: string;
        } & (components["schemas"]["AWSCloudProviderSettings"] | components["schemas"]["AzureCloudProviderSettings"] | components["schemas"]["CloudGCPProviderSettings"] | components["schemas"]["ClusterFreeProviderSettings"] | components["schemas"]["ClusterFlexProviderSettings"]);
        ClusterSearchIndex: {
            /** @description Human-readable label that identifies the collection that contains one or more Atlas Search indexes. */
            collectionName: string;
            /** @description Human-readable label that identifies the database that contains the collection with one or more Atlas Search indexes. */
            database: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies this Atlas Search index.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly indexID?: string;
            /** @description Human-readable label that identifies this index. Within each namespace, names of all indexes in the namespace must be unique. */
            name: string;
            /**
             * Format: int32
             * @description Number of index partitions. Allowed values are [1, 2, 4].
             * @default 1
             */
            numPartitions: number;
            /**
             * @description Condition of the search index when you made this request.
             *
             *     - `IN_PROGRESS`: Atlas is building or re-building the index after an edit.
             *     - `STEADY`: You can use this search index.
             *     - `FAILED`: Atlas could not build the index.
             *     - `MIGRATING`: Atlas is upgrading the underlying cluster tier and migrating indexes.
             *     - `PAUSED`: The cluster is paused.
             * @enum {string}
             */
            readonly status?: "IN_PROGRESS" | "STEADY" | "FAILED" | "MIGRATING" | "STALE" | "PAUSED";
            /**
             * @description Type of the index. Default type is search.
             * @enum {string}
             */
            type?: "search" | "vectorSearch";
        };
        /**
         * Component Label
         * @description Human-readable labels applied to this MongoDB Cloud component.
         */
        ComponentLabel: {
            /** @description Key applied to tag and categorize this component. */
            key?: string;
            /** @description Value set to the Key applied to tag and categorize this component. */
            value?: string;
        };
        /**
         * AWS
         * @description Group of Private Endpoint settings.
         */
        CreateAWSEndpointRequest: components["schemas"]["CreateEndpointRequest"] & {
            /**
             * @description Unique string that identifies the private endpoint's network interface that someone added to this private endpoint service.
             * @example vpce-3bf78b0ddee411ba1
             */
            id: string;
        };
        /**
         * AZURE
         * @description Group of Private Endpoint settings.
         */
        CreateAzureEndpointRequest: components["schemas"]["CreateEndpointRequest"] & {
            /**
             * @description Unique string that identifies the private endpoint's network interface that someone added to this private endpoint service.
             * @example /subscriptions/cba6d9c6-1d3f-3c11-03cb-c705d895e636/resourcegroups/qrRTqi4TSN)7yB5YLRjVDveH3.yLzpNR7Br0D3-SGrU3j0.0/providers/Microsoft.Network/privateEndpoints/pVP(vb(XeckpxtXzP0NaOsDjeWDbOK)DX8A2j2E_vBYL2.GEYIdln
             */
            id: string;
            /** @description IPv4 address of the private endpoint in your Azure VNet that someone added to this private endpoint service. */
            privateEndpointIPAddress: string;
        };
        /** @description Settings to configure the region where you wish to store your archived data. */
        CreateDataProcessRegionView: {
            /**
             * @description Human-readable label that identifies the Cloud service provider where you wish to store your archived data. **AZURE** or **GCP** may be selected only if it is the Cloud service provider for the cluster and no archives for any other cloud provider have been created for the cluster.
             * @enum {string}
             */
            cloudProvider?: "AWS" | "AZURE" | "GCP";
        };
        CreateEndpointRequest: components["schemas"]["CreateAWSEndpointRequest"] | components["schemas"]["CreateAzureEndpointRequest"] | components["schemas"]["CreateGCPEndpointGroupRequest"];
        /**
         * GCP
         * @description Group of Private Endpoint settings.
         */
        CreateGCPEndpointGroupRequest: components["schemas"]["CreateEndpointRequest"] & {
            /** @description Human-readable label that identifies a set of endpoints. */
            endpointGroupName: string;
            /** @description List of individual private endpoints that comprise this endpoint group. */
            endpoints?: components["schemas"]["CreateGCPForwardingRuleRequest"][];
            /**
             * @description Unique string that identifies the Google Cloud project in which you created the endpoints.
             * @example p-fdeeb3e43b8e733e5ab627b1
             */
            gcpProjectId: string;
        };
        /** GCP Forwarding Rules */
        CreateGCPForwardingRuleRequest: {
            /** @description Human-readable label that identifies the Google Cloud consumer forwarding rule that you created. */
            endpointName?: string;
            /** @description One Private Internet Protocol version 4 (IPv4) address to which this Google Cloud consumer forwarding rule resolves. */
            ipAddress?: string;
        };
        /** @description Rules by which MongoDB Cloud archives data.
         *
         *     Use the **criteria.type** field to choose how MongoDB Cloud selects data to archive. Choose data using the age of the data or a MongoDB query.
         *     **"criteria.type": "DATE"** selects documents to archive based on a date.
         *     **"criteria.type": "CUSTOM"** selects documents to archive based on a custom JSON query. MongoDB Cloud doesn't support **"criteria.type": "CUSTOM"** when **"collectionType": "TIMESERIES"**. */
        CriteriaView: {
            /**
             * @description Means by which MongoDB Cloud selects data to archive. Data can be chosen using the age of the data or a MongoDB query.
             *     **DATE** selects documents to archive based on a date.
             *     **CUSTOM** selects documents to archive based on a custom JSON query. MongoDB Cloud doesn't support **CUSTOM** when `"collectionType": "TIMESERIES"`.
             * @enum {string}
             */
            type?: "DATE" | "CUSTOM";
        };
        /**
         * Archival Criteria
         * @description **CUSTOM criteria.type**.
         */
        CustomCriteriaView: Omit<components["schemas"]["CriteriaView"], "type"> & {
            /** @description MongoDB find query that selects documents to archive. The specified query follows the syntax of the `db.collection.find(query)` command. This query can't use the empty document (`{}`) to return all documents. Set this parameter when **"criteria.type" : "CUSTOM"**. */
            query: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "CUSTOM";
        };
        /** @description The name of a Built in or Custom DB Role to connect to an Atlas Cluster. */
        DBRoleToExecute: {
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /** @description The name of the role to use. Can be a built in role or a custom role. */
            role?: string;
            /**
             * DB Role Type
             * @description Type of the DB role. Can be either BuiltIn or Custom.
             * @enum {string}
             */
            type?: "BUILT_IN" | "CUSTOM";
        };
        /**
         * DLS Ingestion Destination
         * @description Atlas Data Lake Storage as the destination for a Data Lake Pipeline.
         */
        DLSIngestionSink: Omit<components["schemas"]["IngestionSink"], "type"> & {
            /**
             * @description Target cloud provider for this Data Lake Pipeline.
             * @enum {string}
             */
            metadataProvider?: "AWS";
            /** @description Target cloud provider region for this Data Lake Pipeline. */
            metadataRegion?: string;
            /** @description Ordered fields used to physically organize data in the destination. */
            partitionFields?: components["schemas"]["DataLakePipelinesPartitionField"][];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "DLS";
        };
        DailyScheduleView: Omit<WithRequired<components["schemas"]["OnlineArchiveSchedule"], "type">, "type"> & {
            /**
             * Format: int32
             * @description Hour of the day when the scheduled window to run one online archive ends.
             */
            endHour?: number;
            /**
             * Format: int32
             * @description Minute of the hour when the scheduled window to run one online archive ends.
             */
            endMinute?: number;
            /**
             * Format: int32
             * @description Hour of the day when the when the scheduled window to run one online archive starts.
             */
            startHour?: number;
            /**
             * Format: int32
             * @description Minute of the hour when the scheduled window to run one online archive starts.
             */
            startMinute?: number;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "DAILY";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "DAILY";
        };
        DataLakeAtlasStoreInstance: Omit<components["schemas"]["DataLakeStoreSettings"], "provider"> & {
            /** @description Human-readable label of the MongoDB Cloud cluster on which the store is based. */
            clusterName?: string;
            /** @description Unique 24-hexadecimal digit string that identifies the project. */
            readonly projectId?: string;
            readConcern?: components["schemas"]["DataLakeAtlasStoreReadConcern"];
            readPreference?: components["schemas"]["DataLakeAtlasStoreReadPreference"];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "atlas";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "atlas";
        };
        /** @description MongoDB Cloud cluster read concern, which determines the consistency and isolation properties of the data read from an Atlas cluster. */
        DataLakeAtlasStoreReadConcern: {
            /**
             * @description Read Concern level that specifies the consistency and availability of the data read.
             * @enum {string}
             */
            level?: "LOCAL" | "MAJORITY" | "LINEARIZABLE" | "SNAPSHOT" | "AVAILABLE";
        };
        /** @description MongoDB Cloud cluster read preference, which describes how to route read requests to the cluster. */
        DataLakeAtlasStoreReadPreference: {
            /**
             * Format: int32
             * @description Maximum replication lag, or **staleness**, for reads from secondaries.
             */
            maxStalenessSeconds?: number;
            /**
             * @description Read preference mode that specifies to which replica set member to route the read requests.
             * @enum {string}
             */
            mode?: "primary" | "primaryPreferred" | "secondary" | "secondaryPreferred" | "nearest";
            /** @description List that contains tag sets or tag specification documents. If specified, Atlas Data Lake routes read requests to replica set member or members that are associated with the specified tags. */
            tagSets?: components["schemas"]["DataLakeAtlasStoreReadPreferenceTag"][][];
        };
        DataLakeAtlasStoreReadPreferenceTag: {
            /** @description Human-readable label of the tag. */
            name?: string;
            /** @description Value of the tag. */
            value?: string;
        };
        DataLakeAzureBlobStore: Omit<components["schemas"]["DataLakeStoreSettings"], "provider"> & {
            /** @description Human-readable label that identifies the name of the container. */
            containerName?: string;
            /** @description Delimiter. */
            delimiter?: string;
            /** @description Prefix. */
            prefix?: string;
            /**
             * @description Flag that indicates whether the blob store is public. If set to `true`, MongoDB Cloud doesn't use the configured Azure service principal to access the blob store. If set to `false`, the configured Azure service principal must include permissions to access the blob store.
             * @default false
             */
            public: boolean;
            /**
             * Azure Regions
             * @description Microsoft Azure Regions.
             * @enum {string}
             */
            region?: "US_CENTRAL" | "US_EAST" | "US_EAST_2" | "US_NORTH_CENTRAL" | "US_WEST" | "US_SOUTH_CENTRAL" | "EUROPE_NORTH" | "EUROPE_WEST" | "US_WEST_CENTRAL" | "US_WEST_2" | "US_WEST_3" | "CANADA_EAST" | "CANADA_CENTRAL" | "BRAZIL_SOUTH" | "BRAZIL_SOUTHEAST" | "AUSTRALIA_CENTRAL" | "AUSTRALIA_CENTRAL_2" | "AUSTRALIA_EAST" | "AUSTRALIA_SOUTH_EAST" | "GERMANY_CENTRAL" | "GERMANY_NORTH_EAST" | "GERMANY_WEST_CENTRAL" | "GERMANY_NORTH" | "SWEDEN_CENTRAL" | "SWEDEN_SOUTH" | "SWITZERLAND_NORTH" | "SWITZERLAND_WEST" | "UK_SOUTH" | "UK_WEST" | "NORWAY_EAST" | "NORWAY_WEST" | "INDIA_CENTRAL" | "INDIA_SOUTH" | "INDIA_WEST" | "CHINA_EAST" | "CHINA_NORTH" | "ASIA_EAST" | "JAPAN_EAST" | "JAPAN_WEST" | "ASIA_SOUTH_EAST" | "KOREA_CENTRAL" | "KOREA_SOUTH" | "FRANCE_CENTRAL" | "FRANCE_SOUTH" | "SOUTH_AFRICA_NORTH" | "SOUTH_AFRICA_WEST" | "UAE_CENTRAL" | "UAE_NORTH" | "QATAR_CENTRAL";
            /** @description Replacement Delimiter. */
            replacementDelimiter?: string;
            /** @description Service URL. */
            serviceURL?: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "azure";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "azure";
        };
        DataLakeDLSAWSStore: Omit<components["schemas"]["DataLakeStoreSettings"], "provider"> & {
            /**
             * AWS Regions
             * @description Physical location where MongoDB Cloud deploys your AWS-hosted MongoDB cluster nodes. The region you choose can affect network latency for clients accessing your databases. When MongoDB Cloud deploys a dedicated cluster, it checks if a VPC or VPC connection exists for that provider and region. If not, MongoDB Cloud creates them as part of the deployment. MongoDB Cloud assigns the VPC a CIDR block. To limit a new VPC peering connection to one CIDR block and region, create the connection first. Deploy the cluster after the connection starts.
             * @enum {string}
             */
            region?: "US_GOV_WEST_1" | "US_GOV_EAST_1" | "US_EAST_1" | "US_EAST_2" | "US_WEST_1" | "US_WEST_2" | "CA_CENTRAL_1" | "EU_NORTH_1" | "EU_WEST_1" | "EU_WEST_2" | "EU_WEST_3" | "EU_CENTRAL_1" | "EU_CENTRAL_2" | "AP_EAST_1" | "AP_NORTHEAST_1" | "AP_NORTHEAST_2" | "AP_NORTHEAST_3" | "AP_SOUTHEAST_1" | "AP_SOUTHEAST_2" | "AP_SOUTHEAST_3" | "AP_SOUTHEAST_4" | "AP_SOUTH_1" | "AP_SOUTH_2" | "SA_EAST_1" | "CN_NORTH_1" | "CN_NORTHWEST_1" | "ME_SOUTH_1" | "ME_CENTRAL_1" | "AF_SOUTH_1" | "EU_SOUTH_1" | "EU_SOUTH_2" | "IL_CENTRAL_1" | "CA_WEST_1" | "GLOBAL";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "dls:aws";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "dls:aws";
        };
        DataLakeDLSAzureStore: Omit<components["schemas"]["DataLakeStoreSettings"], "provider"> & {
            /**
             * Azure Regions
             * @description Microsoft Azure Regions.
             * @enum {string}
             */
            region?: "US_CENTRAL" | "US_EAST" | "US_EAST_2" | "US_NORTH_CENTRAL" | "US_WEST" | "US_SOUTH_CENTRAL" | "EUROPE_NORTH" | "EUROPE_WEST" | "US_WEST_CENTRAL" | "US_WEST_2" | "US_WEST_3" | "CANADA_EAST" | "CANADA_CENTRAL" | "BRAZIL_SOUTH" | "BRAZIL_SOUTHEAST" | "AUSTRALIA_CENTRAL" | "AUSTRALIA_CENTRAL_2" | "AUSTRALIA_EAST" | "AUSTRALIA_SOUTH_EAST" | "GERMANY_CENTRAL" | "GERMANY_NORTH_EAST" | "GERMANY_WEST_CENTRAL" | "GERMANY_NORTH" | "SWEDEN_CENTRAL" | "SWEDEN_SOUTH" | "SWITZERLAND_NORTH" | "SWITZERLAND_WEST" | "UK_SOUTH" | "UK_WEST" | "NORWAY_EAST" | "NORWAY_WEST" | "INDIA_CENTRAL" | "INDIA_SOUTH" | "INDIA_WEST" | "CHINA_EAST" | "CHINA_NORTH" | "ASIA_EAST" | "JAPAN_EAST" | "JAPAN_WEST" | "ASIA_SOUTH_EAST" | "KOREA_CENTRAL" | "KOREA_SOUTH" | "FRANCE_CENTRAL" | "FRANCE_SOUTH" | "SOUTH_AFRICA_NORTH" | "SOUTH_AFRICA_WEST" | "UAE_CENTRAL" | "UAE_NORTH" | "QATAR_CENTRAL";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "dls:azure";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "dls:azure";
        };
        DataLakeDLSGCPStore: Omit<components["schemas"]["DataLakeStoreSettings"], "provider"> & {
            /**
             * GCP Regions
             * @description Google Cloud Platform Regions.
             * @enum {string}
             */
            region?: "ASIA_EAST_2" | "ASIA_NORTHEAST_2" | "ASIA_NORTHEAST_3" | "ASIA_SOUTH_1" | "ASIA_SOUTH_2" | "ASIA_SOUTHEAST_2" | "AUSTRALIA_SOUTHEAST_1" | "AUSTRALIA_SOUTHEAST_2" | "CENTRAL_US" | "EASTERN_ASIA_PACIFIC" | "EASTERN_US" | "EUROPE_CENTRAL_2" | "EUROPE_NORTH_1" | "EUROPE_WEST_2" | "EUROPE_WEST_3" | "EUROPE_WEST_4" | "EUROPE_WEST_6" | "EUROPE_WEST_10" | "EUROPE_WEST_12" | "MIDDLE_EAST_CENTRAL_1" | "MIDDLE_EAST_CENTRAL_2" | "MIDDLE_EAST_WEST_1" | "NORTH_AMERICA_NORTHEAST_1" | "NORTH_AMERICA_NORTHEAST_2" | "NORTHEASTERN_ASIA_PACIFIC" | "SOUTH_AMERICA_EAST_1" | "SOUTH_AMERICA_WEST_1" | "SOUTHEASTERN_ASIA_PACIFIC" | "US_EAST_4" | "US_EAST_5" | "US_WEST_2" | "US_WEST_3" | "US_WEST_4" | "US_SOUTH_1" | "WESTERN_EUROPE" | "WESTERN_US";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "dls:gcp";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "dls:gcp";
        };
        DataLakeGoogleCloudStorageStore: Omit<components["schemas"]["DataLakeStoreSettings"], "provider"> & {
            /** @description Human-readable label that identifies the Google Cloud Storage bucket. */
            bucket?: string;
            /** @description Delimiter. */
            delimiter?: string;
            /** @description Prefix. */
            prefix?: string;
            /**
             * @description Flag that indicates whether the bucket is public. If set to `true`, MongoDB Cloud doesn't use the configured GCP service account to access the bucket. If set to `false`, the configured GCP service acccount must include permissions to access the bucket.
             * @default false
             */
            public: boolean;
            /**
             * GCP Regions
             * @description Google Cloud Platform Regions.
             * @enum {string}
             */
            region?: "ASIA_EAST_2" | "ASIA_NORTHEAST_2" | "ASIA_NORTHEAST_3" | "ASIA_SOUTH_1" | "ASIA_SOUTH_2" | "ASIA_SOUTHEAST_2" | "AUSTRALIA_SOUTHEAST_1" | "AUSTRALIA_SOUTHEAST_2" | "CENTRAL_US" | "EASTERN_ASIA_PACIFIC" | "EASTERN_US" | "EUROPE_CENTRAL_2" | "EUROPE_NORTH_1" | "EUROPE_WEST_2" | "EUROPE_WEST_3" | "EUROPE_WEST_4" | "EUROPE_WEST_6" | "EUROPE_WEST_10" | "EUROPE_WEST_12" | "MIDDLE_EAST_CENTRAL_1" | "MIDDLE_EAST_CENTRAL_2" | "MIDDLE_EAST_WEST_1" | "NORTH_AMERICA_NORTHEAST_1" | "NORTH_AMERICA_NORTHEAST_2" | "NORTHEASTERN_ASIA_PACIFIC" | "SOUTH_AMERICA_EAST_1" | "SOUTH_AMERICA_WEST_1" | "SOUTHEASTERN_ASIA_PACIFIC" | "US_EAST_4" | "US_EAST_5" | "US_WEST_2" | "US_WEST_3" | "US_WEST_4" | "US_SOUTH_1" | "WESTERN_EUROPE" | "WESTERN_US";
            /** @description Replacement Delimiter. */
            replacementDelimiter?: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "gcs";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "gcs";
        };
        DataLakeHTTPStore: Omit<components["schemas"]["DataLakeStoreSettings"], "provider"> & {
            /**
             * @description Flag that validates the scheme in the specified URLs. If `true`, allows insecure `HTTP` scheme, doesn't verify the server's certificate chain and hostname, and accepts any certificate with any hostname presented by the server. If `false`, allows secure `HTTPS` scheme only.
             * @default false
             */
            allowInsecure: boolean;
            /** @description Default format that Data Lake assumes if it encounters a file without an extension while searching the `storeName`. If omitted, Data Lake attempts to detect the file type by processing a few bytes of the file. The specified format only applies to the URLs specified in the **databases.[n].collections.[n].dataSources** object. */
            defaultFormat?: string;
            /** @description Comma-separated list of publicly accessible HTTP URLs where data is stored. You can't specify URLs that require authentication. */
            urls?: string[];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "http";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "http";
        };
        /**
         * Partition Field
         * @description Partition Field in the Data Lake Storage provider for a Data Lake Pipeline.
         */
        DataLakePipelinesPartitionField: {
            /** @description Human-readable label that identifies the field name used to partition data. */
            fieldName: string;
            /**
             * Format: int32
             * @description Sequence in which MongoDB Cloud slices the collection data to create partitions. The resource expresses this sequence starting with zero.
             * @default 0
             */
            order: number;
        };
        DataLakeS3StoreSettings: Omit<components["schemas"]["DataLakeStoreSettings"], "provider"> & {
            /** @description Collection of AWS S3 [storage classes](https://aws.amazon.com/s3/storage-classes/). Atlas Data Lake includes the files in these storage classes in the query results. */
            additionalStorageClasses?: ("STANDARD" | "INTELLIGENT_TIERING" | "STANDARD_IA")[];
            /** @description Human-readable label that identifies the AWS S3 bucket. This label must exactly match the name of an S3 bucket that the data lake can access with the configured AWS Identity and Access Management (IAM) credentials. */
            bucket?: string;
            /** @description The delimiter that separates **databases.[n].collections.[n].dataSources.[n].path** segments in the data store. MongoDB Cloud uses the delimiter to efficiently traverse S3 buckets with a hierarchical directory structure. You can specify any character supported by the S3 object keys as the delimiter. For example, you can specify an underscore (_) or a plus sign (+) or multiple characters, such as double underscores (__) as the delimiter. If omitted, defaults to `/`. */
            delimiter?: string;
            /**
             * @description Flag that indicates whether to use S3 tags on the files in the given path as additional partition attributes. If set to `true`, data lake adds the S3 tags as additional partition attributes and adds new top-level BSON elements associating each tag to each document.
             * @default false
             */
            includeTags: boolean;
            /** @description Prefix that MongoDB Cloud applies when searching for files in the S3 bucket. The data store prepends the value of prefix to the **databases.[n].collections.[n].dataSources.[n].path** to create the full path for files to ingest. If omitted, MongoDB Cloud searches all files from the root of the S3 bucket. */
            prefix?: string;
            /**
             * @description Flag that indicates whether the bucket is public. If set to `true`, MongoDB Cloud doesn't use the configured AWS Identity and Access Management (IAM) role to access the S3 bucket. If set to `false`, the configured AWS IAM role must include permissions to access the S3 bucket.
             * @default false
             */
            public: boolean;
            /**
             * AWS Regions
             * @description Physical location where MongoDB Cloud deploys your AWS-hosted MongoDB cluster nodes. The region you choose can affect network latency for clients accessing your databases. When MongoDB Cloud deploys a dedicated cluster, it checks if a VPC or VPC connection exists for that provider and region. If not, MongoDB Cloud creates them as part of the deployment. MongoDB Cloud assigns the VPC a CIDR block. To limit a new VPC peering connection to one CIDR block and region, create the connection first. Deploy the cluster after the connection starts.
             * @enum {string}
             */
            region?: "US_GOV_WEST_1" | "US_GOV_EAST_1" | "US_EAST_1" | "US_EAST_2" | "US_WEST_1" | "US_WEST_2" | "CA_CENTRAL_1" | "EU_NORTH_1" | "EU_WEST_1" | "EU_WEST_2" | "EU_WEST_3" | "EU_CENTRAL_1" | "EU_CENTRAL_2" | "AP_EAST_1" | "AP_NORTHEAST_1" | "AP_NORTHEAST_2" | "AP_NORTHEAST_3" | "AP_SOUTHEAST_1" | "AP_SOUTHEAST_2" | "AP_SOUTHEAST_3" | "AP_SOUTHEAST_4" | "AP_SOUTH_1" | "AP_SOUTH_2" | "SA_EAST_1" | "CN_NORTH_1" | "CN_NORTHWEST_1" | "ME_SOUTH_1" | "ME_CENTRAL_1" | "AF_SOUTH_1" | "EU_SOUTH_1" | "EU_SOUTH_2" | "IL_CENTRAL_1" | "CA_WEST_1" | "GLOBAL";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "s3";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            provider: "s3";
        };
        /** @description Group of settings that define where the data is stored. */
        DataLakeStoreSettings: {
            /** @description Human-readable label that identifies the data store. The **databases.[n].collections.[n].dataSources.[n].storeName** field references this values as part of the mapping configuration. To use MongoDB Cloud as a data store, the data lake requires a serverless instance or an `M10` or higher cluster. */
            name?: string;
            provider: string;
        } & (components["schemas"]["DataLakeS3StoreSettings"] | components["schemas"]["DataLakeDLSAWSStore"] | components["schemas"]["DataLakeDLSAzureStore"] | components["schemas"]["DataLakeDLSGCPStore"] | components["schemas"]["DataLakeAtlasStoreInstance"] | components["schemas"]["DataLakeHTTPStore"] | components["schemas"]["DataLakeAzureBlobStore"] | components["schemas"]["DataLakeGoogleCloudStorageStore"]);
        DataMetricAlertView: {
            /**
             * Format: date-time
             * @description Date and time until which this alert has been acknowledged. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter if a MongoDB User previously acknowledged this alert.
             *
             *     - To acknowledge this alert forever, set the parameter value to 100 years in the future.
             *
             *     - To unacknowledge a previously acknowledged alert, do not set this parameter value.
             */
            acknowledgedUntil?: string;
            /**
             * @description Comment that a MongoDB Cloud user submitted when acknowledging the alert.
             * @example Expiration on 3/19.  Silencing for 7days.
             */
            acknowledgementComment?: string;
            /**
             * Format: email
             * @description MongoDB Cloud username of the person who acknowledged the alert. The response returns this parameter if a MongoDB Cloud user previously acknowledged this alert.
             */
            readonly acknowledgingUsername?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies the alert configuration that sets this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly alertConfigId: string;
            /**
             * @description Human-readable label that identifies the cluster to which this alert applies. This resource returns this parameter for alerts of events impacting backups, replica sets, or sharded clusters.
             * @example cluster1
             */
            readonly clusterName?: string;
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud created this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly created: string;
            currentValue?: components["schemas"]["DataMetricValueView"];
            eventTypeName: components["schemas"]["HostMetricEventTypeViewAlertable"];
            /**
             * @description Unique 24-hexadecimal digit string that identifies the project that owns this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly groupId?: string;
            /**
             * @description Hostname and port of the host to which this alert applies. The resource returns this parameter for alerts of events impacting hosts or replica sets.
             * @example cloud-test.mongodb.com:27017
             */
            readonly hostnameAndPort?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly id: string;
            /**
             * Format: date-time
             * @description Date and time that any notifications were last sent for this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter if MongoDB Cloud has sent notifications for this alert.
             */
            readonly lastNotified?: string;
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /**
             * @description Name of the metric against which Atlas checks the configured `metricThreshold.threshold`.
             *
             *     To learn more about the available metrics, see <a href="https://www.mongodb.com/docs/atlas/reference/alert-host-metrics/#std-label-measurement-types" target="_blank">Host Metrics</a>.
             *
             *     **NOTE**: If you set eventTypeName to OUTSIDE_SERVERLESS_METRIC_THRESHOLD, you can specify only metrics available for serverless. To learn more, see <a href="https://dochub.mongodb.org/core/alert-config-serverless-measurements" target="_blank">Serverless Measurements</a>.
             * @example ASSERT_USER
             */
            readonly metricName?: string;
            /**
             * @description Unique 24-hexadecimal character string that identifies the organization that owns the project to which this alert applies.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly orgId?: string;
            /**
             * @description Name of the replica set to which this alert applies. The response returns this parameter for alerts of events impacting backups, hosts, or replica sets.
             * @example event-replica-set
             */
            readonly replicaSetName?: string;
            /**
             * Format: date-time
             * @description Date and time that this alert changed to `"status" : "CLOSED"`. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter once `"status" : "CLOSED"`.
             */
            readonly resolved?: string;
            /**
             * @description State of this alert at the time you requested its details.
             * @example OPEN
             * @enum {string}
             */
            readonly status: "CANCELLED" | "CLOSED" | "OPEN" | "TRACKING";
            /**
             * Format: date-time
             * @description Date and time when someone last updated this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly updated: string;
        };
        /**
         * Data Metric Units
         * @description Element used to express the quantity. This can be an element of time, storage capacity, and the like.
         * @example BYTES
         * @enum {string}
         */
        DataMetricUnits: "BITS" | "KILOBITS" | "MEGABITS" | "GIGABITS" | "BYTES" | "KILOBYTES" | "MEGABYTES" | "GIGABYTES" | "TERABYTES" | "PETABYTES";
        /**
         * Data Metric Value
         * @description Measurement of the **metricName** recorded at the time of the event.
         */
        DataMetricValueView: {
            /**
             * Format: double
             * @description Amount of the **metricName** recorded at the time of the event. This value triggered the alert.
             */
            readonly number?: number;
            units?: components["schemas"]["DataMetricUnits"];
        };
        /** @description Settings to configure the region where you wish to store your archived data. */
        DataProcessRegionView: {
            /**
             * @description Human-readable label that identifies the Cloud service provider where you store your archived data.
             * @enum {string}
             */
            readonly cloudProvider?: "AWS" | "AZURE" | "GCP";
        };
        /**
         * Database User Role
         * @description Range of resources available to this database user.
         */
        DatabaseUserRole: {
            /** @description Collection on which this role applies. */
            collectionName?: string;
            /** @description Database to which the user is granted access privileges. */
            databaseName: string;
            /**
             * @description Human-readable label that identifies a group of privileges assigned to a database user. This value can either be a built-in role or a custom role.
             * @enum {string}
             */
            roleName: "atlasAdmin" | "backup" | "clusterMonitor" | "dbAdmin" | "dbAdminAnyDatabase" | "enableSharding" | "read" | "readAnyDatabase" | "readWrite" | "readWriteAnyDatabase" | "<a custom role name>";
        };
        /**
         * Archival Criteria
         * @description **DATE criteria.type**.
         */
        DateCriteriaView: Omit<components["schemas"]["CriteriaView"], "type"> & {
            /** @description Indexed database parameter that stores the date that determines when data moves to the online archive. MongoDB Cloud archives the data when the current date exceeds the date in this database parameter plus the number of days specified through the **expireAfterDays** parameter. Set this parameter when you set `"criteria.type" : "DATE"`. */
            dateField?: string;
            /**
             * @description Syntax used to write the date after which data moves to the online archive. Date can be expressed as ISO 8601, Epoch timestamps, or ObjectId. The Epoch timestamp can be expressed as nanoseconds, milliseconds, or seconds. Set this parameter when **"criteria.type" : "DATE"**.
             *     You must set **"criteria.type" : "DATE"** if **"collectionType": "TIMESERIES"**.
             * @default ISODATE
             * @enum {string}
             */
            dateFormat: "ISODATE" | "EPOCH_SECONDS" | "EPOCH_MILLIS" | "EPOCH_NANOSECONDS" | "OBJECT_ID";
            /**
             * Format: int32
             * @description Number of days after the value in the **criteria.dateField** when MongoDB Cloud archives data in the specified cluster. Set this parameter when you set **"criteria.type" : "DATE"**.
             */
            expireAfterDays?: number;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "DATE";
        };
        /** @description Hardware specifications for read-only nodes in the region. Read-only nodes can never become the primary member, but can enable local reads.If you don't specify this parameter, no read-only nodes are deployed to the region. */
        DedicatedHardwareSpec: {
            /**
             * Format: int32
             * @description Number of nodes of the given type for MongoDB Cloud to deploy to the region.
             */
            nodeCount?: number;
        } & (components["schemas"]["AWSHardwareSpec"] | components["schemas"]["AzureHardwareSpec"] | components["schemas"]["GCPHardwareSpec"]);
        /** @description Hardware specifications for read-only nodes in the region. Read-only nodes can never become the primary member, but can enable local reads. If you don't specify this parameter, no read-only nodes are deployed to the region. */
        DedicatedHardwareSpec20240805: {
            /**
             * Format: double
             * @description Storage capacity of instance data volumes expressed in gigabytes. Increase this number to add capacity.
             *
             *      This value must be equal for all shards and node types.
             *
             *      This value is not configurable on M0/M2/M5 clusters.
             *
             *      MongoDB Cloud requires this parameter if you set **replicationSpecs**.
             *
             *      If you specify a disk size below the minimum (10 GB), this parameter defaults to the minimum disk size value.
             *
             *      Storage charge calculations depend on whether you choose the default value or a custom value.
             *
             *      The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
             */
            diskSizeGB?: number;
            /**
             * Format: int32
             * @description Number of nodes of the given type for MongoDB Cloud to deploy to the region.
             */
            nodeCount?: number;
        } & (components["schemas"]["AWSHardwareSpec20240805"] | components["schemas"]["AzureHardwareSpec20240805"] | components["schemas"]["GCPHardwareSpec20240805"]);
        /**
         * Any Other Alerts
         * @description Other alerts which don't have extra details beside of basic one.
         */
        DefaultAlertViewForNdsGroup: {
            /**
             * Format: date-time
             * @description Date and time until which this alert has been acknowledged. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter if a MongoDB User previously acknowledged this alert.
             *
             *     - To acknowledge this alert forever, set the parameter value to 100 years in the future.
             *
             *     - To unacknowledge a previously acknowledged alert, do not set this parameter value.
             */
            acknowledgedUntil?: string;
            /**
             * @description Comment that a MongoDB Cloud user submitted when acknowledging the alert.
             * @example Expiration on 3/19.  Silencing for 7days.
             */
            acknowledgementComment?: string;
            /**
             * Format: email
             * @description MongoDB Cloud username of the person who acknowledged the alert. The response returns this parameter if a MongoDB Cloud user previously acknowledged this alert.
             */
            readonly acknowledgingUsername?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies the alert configuration that sets this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly alertConfigId: string;
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud created this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly created: string;
            /** @description Incident that triggered this alert. */
            readonly eventTypeName: ("CREDIT_CARD_ABOUT_TO_EXPIRE" | "PENDING_INVOICE_OVER_THRESHOLD" | "DAILY_BILL_OVER_THRESHOLD") | ("CPS_SNAPSHOT_STARTED" | "CPS_SNAPSHOT_SUCCESSFUL" | "CPS_SNAPSHOT_FAILED" | "CPS_CONCURRENT_SNAPSHOT_FAILED_WILL_RETRY" | "CPS_SNAPSHOT_BEHIND" | "CPS_COPY_SNAPSHOT_STARTED" | "CPS_COPY_SNAPSHOT_FAILED" | "CPS_COPY_SNAPSHOT_FAILED_WILL_RETRY" | "CPS_COPY_SNAPSHOT_SUCCESSFUL" | "CPS_PREV_SNAPSHOT_OLD" | "CPS_SNAPSHOT_FALLBACK_SUCCESSFUL" | "CPS_SNAPSHOT_FALLBACK_FAILED" | "CPS_RESTORE_SUCCESSFUL" | "CPS_EXPORT_SUCCESSFUL" | "CPS_RESTORE_FAILED" | "CPS_EXPORT_FAILED" | "CPS_AUTO_EXPORT_FAILED" | "CPS_SNAPSHOT_DOWNLOAD_REQUEST_FAILED" | "CPS_OPLOG_BEHIND" | "CPS_OPLOG_CAUGHT_UP") | ("AWS_ENCRYPTION_KEY_NEEDS_ROTATION" | "AZURE_ENCRYPTION_KEY_NEEDS_ROTATION" | "GCP_ENCRYPTION_KEY_NEEDS_ROTATION" | "AWS_ENCRYPTION_KEY_INVALID" | "AZURE_ENCRYPTION_KEY_INVALID" | "GCP_ENCRYPTION_KEY_INVALID") | ("FTS_INDEX_DELETION_FAILED" | "FTS_INDEX_BUILD_COMPLETE" | "FTS_INDEX_BUILD_FAILED" | "FTS_INDEXES_RESTORE_FAILED" | "FTS_INDEXES_SYNONYM_MAPPING_INVALID") | ("USERS_WITHOUT_MULTI_FACTOR_AUTH" | "ENCRYPTION_AT_REST_KMS_NETWORK_ACCESS_DENIED" | "ENCRYPTION_AT_REST_CONFIG_NO_LONGER_VALID") | ("CLUSTER_INSTANCE_STOP_START" | "CLUSTER_INSTANCE_RESYNC_REQUESTED" | "CLUSTER_INSTANCE_UPDATE_REQUESTED" | "SAMPLE_DATASET_LOAD_REQUESTED" | "TENANT_UPGRADE_TO_SERVERLESS_SUCCESSFUL" | "TENANT_UPGRADE_TO_SERVERLESS_FAILED" | "NETWORK_PERMISSION_ENTRY_ADDED" | "NETWORK_PERMISSION_ENTRY_REMOVED" | "NETWORK_PERMISSION_ENTRY_UPDATED") | ("MAINTENANCE_IN_ADVANCED" | "MAINTENANCE_AUTO_DEFERRED" | "MAINTENANCE_STARTED" | "MAINTENANCE_NO_LONGER_NEEDED") | ("NDS_X509_USER_AUTHENTICATION_CUSTOMER_CA_EXPIRATION_CHECK" | "NDS_X509_USER_AUTHENTICATION_CUSTOMER_CRL_EXPIRATION_CHECK" | "NDS_X509_USER_AUTHENTICATION_MANAGED_USER_CERTS_EXPIRATION_CHECK") | ("ONLINE_ARCHIVE_INSUFFICIENT_INDEXES_CHECK" | "ONLINE_ARCHIVE_MAX_CONSECUTIVE_OFFLOAD_WINDOWS_CHECK") | "OUTSIDE_SERVERLESS_METRIC_THRESHOLD" | "OUTSIDE_FLEX_METRIC_THRESHOLD" | ("JOINED_GROUP" | "REMOVED_FROM_GROUP" | "USER_ROLES_CHANGED_AUDIT") | ("TAGS_MODIFIED" | "CLUSTER_TAGS_MODIFIED" | "GROUP_TAGS_MODIFIED") | ("STREAM_PROCESSOR_STATE_IS_FAILED" | "OUTSIDE_STREAM_PROCESSOR_METRIC_THRESHOLD") | ("COMPUTE_AUTO_SCALE_INITIATED_BASE" | "COMPUTE_AUTO_SCALE_INITIATED_ANALYTICS" | "COMPUTE_AUTO_SCALE_SCALE_DOWN_FAIL_BASE" | "COMPUTE_AUTO_SCALE_SCALE_DOWN_FAIL_ANALYTICS" | "COMPUTE_AUTO_SCALE_MAX_INSTANCE_SIZE_FAIL_BASE" | "COMPUTE_AUTO_SCALE_MAX_INSTANCE_SIZE_FAIL_ANALYTICS" | "COMPUTE_AUTO_SCALE_OPLOG_FAIL_BASE" | "COMPUTE_AUTO_SCALE_OPLOG_FAIL_ANALYTICS" | "DISK_AUTO_SCALE_INITIATED" | "DISK_AUTO_SCALE_MAX_DISK_SIZE_FAIL" | "DISK_AUTO_SCALE_OPLOG_FAIL" | "PREDICTIVE_COMPUTE_AUTO_SCALE_INITIATED_BASE" | "PREDICTIVE_COMPUTE_AUTO_SCALE_MAX_INSTANCE_SIZE_FAIL_BASE" | "PREDICTIVE_COMPUTE_AUTO_SCALE_OPLOG_FAIL_BASE") | ("CPS_DATA_PROTECTION_ENABLE_REQUESTED" | "CPS_DATA_PROTECTION_ENABLED" | "CPS_DATA_PROTECTION_UPDATE_REQUESTED" | "CPS_DATA_PROTECTION_UPDATED" | "CPS_DATA_PROTECTION_DISABLE_REQUESTED" | "CPS_DATA_PROTECTION_DISABLED" | "CPS_DATA_PROTECTION_APPROVED_FOR_DISABLEMENT") | "RESOURCE_POLICY_VIOLATED";
            /**
             * @description Unique 24-hexadecimal digit string that identifies the project that owns this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly groupId?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly id: string;
            /**
             * Format: date-time
             * @description Date and time that any notifications were last sent for this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter if MongoDB Cloud has sent notifications for this alert.
             */
            readonly lastNotified?: string;
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /**
             * @description Unique 24-hexadecimal character string that identifies the organization that owns the project to which this alert applies.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly orgId?: string;
            /**
             * Format: date-time
             * @description Date and time that this alert changed to `"status" : "CLOSED"`. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter once `"status" : "CLOSED"`.
             */
            readonly resolved?: string;
            /**
             * @description State of this alert at the time you requested its details.
             * @example OPEN
             * @enum {string}
             */
            readonly status: "CANCELLED" | "CLOSED" | "OPEN" | "TRACKING";
            /**
             * Format: date-time
             * @description Date and time when someone last updated this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly updated: string;
        };
        DefaultScheduleView: Omit<WithRequired<components["schemas"]["OnlineArchiveSchedule"], "type">, "type"> & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "DEFAULT";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "DEFAULT";
        };
        DiskBackupSnapshotAWSExportBucketRequest: Omit<WithRequired<components["schemas"]["DiskBackupSnapshotExportBucketRequest"], "cloudProvider">, "cloudProvider"> & {
            /**
             * @description Human-readable label that identifies the AWS S3 Bucket that the role is authorized to export to.
             * @example export-bucket
             */
            bucketName: string;
            /**
             * @description Unique 24-hexadecimal character string that identifies the Unified AWS Access role ID that MongoDB Cloud uses to access the AWS S3 bucket.
             * @example 32b6e34b3d91647abb20e7b8
             */
            iamRoleId: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            cloudProvider: "AWS";
        };
        DiskBackupSnapshotAWSExportBucketResponse: {
            /**
             * @description Unique 24-hexadecimal character string that identifies the Export Bucket.
             * @example 32b6e34b3d91647abb20e7b8
             */
            _id: string;
            /**
             * @description The name of the AWS S3 Bucket, Azure Storage Container, or Google Cloud Storage Bucket that Snapshots are exported to.
             * @example export-bucket
             */
            bucketName: string;
            /**
             * @description Human-readable label that identifies the cloud provider that Snapshots will be exported to.
             * @enum {string}
             */
            cloudProvider: "AWS" | "AZURE" | "GCP";
            /**
             * @description Unique 24-hexadecimal character string that identifies the Unified AWS Access role ID that MongoDB Cloud uses to access the AWS S3 bucket.
             * @example 32b6e34b3d91647abb20e7b8
             */
            iamRoleId: string;
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
        };
        DiskBackupSnapshotAzureExportBucketRequest: Omit<WithRequired<components["schemas"]["DiskBackupSnapshotExportBucketRequest"], "cloudProvider">, "cloudProvider"> & {
            /**
             * @description The name of the Azure Storage Container to export to. This can be omitted and computed from the serviceUrl if the serviceUrl includes a Azure Storage Container name. For example a serviceUrl of "https://examplestorageaccount.blob.core.windows.net/exportcontainer" will yield a computed bucketName of "exportcontainer". If the serviceUrl does not include a Container name, this field is required.
             * @example exportcontainer
             */
            bucketName?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies the Azure Cloud Provider Access Role that MongoDB Cloud uses to access the Azure Blob Storage Container.
             * @example 32b6e34b3d91647abb20e7b8
             */
            roleId: string;
            /**
             * @description URL of the Azure Storage Account to export to. For example: "https://examplestorageaccount.blob.core.windows.net/exportcontainer". Only standard endpoints (with "blob.core.windows.net") are supported.
             * @example https://examplestorageaccount.blob.core.windows.net/exportcontainer
             */
            serviceUrl: string;
            /**
             * Format: uuid
             * @deprecated
             * @description UUID that identifies the Azure Active Directory Tenant ID. Deprecated: this field is ignored; the tenantId of the Cloud Provider Access role (from roleId) is used.
             */
            tenantId?: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            cloudProvider: "AZURE";
        };
        DiskBackupSnapshotAzureExportBucketResponse: Omit<WithRequired<components["schemas"]["DiskBackupSnapshotExportBucketResponse"], "_id" | "bucketName" | "cloudProvider">, "cloudProvider"> & {
            /**
             * @description Unique 24-hexadecimal digit string that identifies the Azure Cloud Provider Access Role that MongoDB Cloud uses to access the Azure Blob Storage Container.
             * @example 32b6e34b3d91647abb20e7b8
             */
            roleId: string;
            /**
             * @description URL of the Azure Storage Account to export to. Only standard endpoints (with "blob.core.windows.net") are supported.
             * @example https://examplestorageaccount.blob.core.windows.net/exportcontainer
             */
            serviceUrl: string;
            /**
             * Format: uuid
             * @description UUID that identifies the Azure Active Directory Tenant ID used during exports.
             */
            tenantId: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            cloudProvider: "AZURE";
        };
        /** @description Disk backup snapshot Export Bucket Request. */
        DiskBackupSnapshotExportBucketRequest: {
            /**
             * @description Human-readable label that identifies the cloud provider that Snapshots are exported to.
             * @enum {string}
             */
            cloudProvider: "AWS" | "AZURE" | "GCP";
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
        };
        /** @description Disk backup snapshot Export Bucket. */
        DiskBackupSnapshotExportBucketResponse: {
            /**
             * @description Unique 24-hexadecimal character string that identifies the Export Bucket.
             * @example 32b6e34b3d91647abb20e7b8
             */
            _id: string;
            /**
             * @description The name of the AWS S3 Bucket, Azure Storage Container, or Google Cloud Storage Bucket that Snapshots are exported to.
             * @example export-bucket
             */
            bucketName: string;
            /**
             * @description Human-readable label that identifies the cloud provider that Snapshots will be exported to.
             * @enum {string}
             */
            cloudProvider: "AWS" | "AZURE" | "GCP";
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
        };
        DiskBackupSnapshotGCPExportBucketRequest: Omit<WithRequired<components["schemas"]["DiskBackupSnapshotExportBucketRequest"], "cloudProvider">, "cloudProvider"> & {
            /**
             * @description Human-readable label that identifies the Google Cloud Storage Bucket that the role is authorized to export to.
             * @example export-bucket
             */
            bucketName: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies the GCP Cloud Provider Access Role that MongoDB Cloud uses to access the Google Cloud Storage Bucket.
             * @example 32b6e34b3d91647abb20e7b8
             */
            roleId: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            cloudProvider: "GCP";
        };
        DiskBackupSnapshotGCPExportBucketResponse: Omit<WithRequired<components["schemas"]["DiskBackupSnapshotExportBucketResponse"], "_id" | "bucketName" | "cloudProvider">, "cloudProvider"> & {
            /**
             * @description Unique 24-hexadecimal digit string that identifies the GCP Cloud Provider Access Role that MongoDB Cloud uses to access the Google Cloud Storage Bucket.
             * @example 32b6e34b3d91647abb20e7b8
             */
            roleId: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            cloudProvider: "GCP";
        };
        /** @description Setting that enables disk auto-scaling. */
        DiskGBAutoScaling: {
            /** @description Flag that indicates whether this cluster enables disk auto-scaling. The maximum memory allowed for the selected cluster tier and the oplog size can limit storage auto-scaling. */
            enabled?: boolean;
        };
        /** @description MongoDB employee granted access level and expiration for a cluster. */
        EmployeeAccessGrantView: {
            /**
             * Format: date-time
             * @description Expiration date for the employee access grant. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            expirationTime: string;
            /**
             * @description Level of access to grant to MongoDB Employees.
             * @enum {string}
             */
            grantType: "CLUSTER_DATABASE_LOGS" | "CLUSTER_INFRASTRUCTURE" | "CLUSTER_INFRASTRUCTURE_AND_APP_SERVICES_SYNC_DATA";
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
        };
        FieldViolation: {
            /** @description A description of why the request element is bad. */
            description: string;
            /** @description A path that leads to a field in the request body. */
            field: string;
        };
        Fields: Record<string, never>;
        /**
         * Flex Backup Configuration
         * @description Flex backup configuration.
         */
        FlexBackupSettings20241113: {
            /**
             * @description Flag that indicates whether backups are performed for this flex cluster. Backup uses flex cluster backups.
             * @default true
             */
            readonly enabled: boolean;
        };
        /**
         * Flex Cluster Description
         * @description Group of settings that configure a MongoDB Flex cluster.
         */
        FlexClusterDescription20241113: {
            backupSettings?: components["schemas"]["FlexBackupSettings20241113"];
            /**
             * @description Flex cluster topology.
             * @default REPLICASET
             * @enum {string}
             */
            readonly clusterType: "REPLICASET";
            connectionStrings?: components["schemas"]["FlexConnectionStrings20241113"];
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud created this instance. This parameter expresses its value in ISO 8601 format in UTC.
             */
            readonly createDate?: string;
            /**
             * @description Unique 24-hexadecimal character string that identifies the project.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly groupId?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies the instance.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly id?: string;
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /** @description Version of MongoDB that the instance runs. */
            readonly mongoDBVersion?: string;
            /** @description Human-readable label that identifies the instance. */
            readonly name?: string;
            providerSettings: components["schemas"]["FlexProviderSettings20241113"];
            /**
             * @description Human-readable label that indicates the current operating condition of this instance.
             * @enum {string}
             */
            readonly stateName?: "IDLE" | "CREATING" | "UPDATING" | "DELETING" | "REPAIRING";
            /** @description List that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the instance. */
            tags?: components["schemas"]["ResourceTag"][];
            /**
             * @description Flag that indicates whether termination protection is enabled on the cluster. If set to `true`, MongoDB Cloud won't delete the cluster. If set to `false`, MongoDB Cloud will delete the cluster.
             * @default false
             */
            terminationProtectionEnabled: boolean;
            /**
             * @description Method by which the cluster maintains the MongoDB versions.
             * @default LTS
             * @enum {string}
             */
            readonly versionReleaseSystem: "LTS";
        };
        /**
         * Flex Cluster Description Create
         * @description Settings that you can specify when you create a flex cluster.
         */
        FlexClusterDescriptionCreate20241113: {
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /** @description Human-readable label that identifies the instance. */
            name: string;
            providerSettings: components["schemas"]["FlexProviderSettingsCreate20241113"];
            /** @description List that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the instance. */
            tags?: components["schemas"]["ResourceTag"][];
            /**
             * @description Flag that indicates whether termination protection is enabled on the cluster. If set to `true`, MongoDB Cloud won't delete the cluster. If set to `false`, MongoDB Cloud will delete the cluster.
             * @default false
             */
            terminationProtectionEnabled: boolean;
        };
        /**
         * Flex Cluster Connection Strings
         * @description Collection of Uniform Resource Locators that point to the MongoDB database.
         */
        FlexConnectionStrings20241113: {
            /** @description Public connection string that you can use to connect to this cluster. This connection string uses the mongodb:// protocol. */
            readonly standard?: string;
            /** @description Public connection string that you can use to connect to this flex cluster. This connection string uses the `mongodb+srv://` protocol. */
            readonly standardSrv?: string;
        };
        /**
         * Cloud Service Provider Settings for a Flex Cluster
         * @description Group of cloud provider settings that configure the provisioned MongoDB flex cluster.
         */
        FlexProviderSettings20241113: {
            /**
             * @description Cloud service provider on which MongoDB Cloud provisioned the flex cluster.
             * @enum {string}
             */
            readonly backingProviderName?: "AWS" | "AZURE" | "GCP";
            /**
             * Format: double
             * @description Storage capacity available to the flex cluster expressed in gigabytes.
             */
            readonly diskSizeGB?: number;
            /**
             * @description Human-readable label that identifies the provider type.
             * @default FLEX
             * @enum {string}
             */
            readonly providerName: "FLEX";
            /** @description Human-readable label that identifies the geographic location of your MongoDB flex cluster. The region you choose can affect network latency for clients accessing your databases. For a complete list of region names, see [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/#std-label-amazon-aws), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), and [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/). */
            readonly regionName?: string;
        };
        /**
         * Cloud Service Provider Settings for a Flex Cluster
         * @description Group of cloud provider settings that configure the provisioned MongoDB flex cluster.
         */
        FlexProviderSettingsCreate20241113: {
            /**
             * @description Cloud service provider on which MongoDB Cloud provisioned the flex cluster.
             * @enum {string}
             */
            backingProviderName: "AWS" | "AZURE" | "GCP";
            /**
             * Format: double
             * @description Storage capacity available to the flex cluster expressed in gigabytes.
             */
            readonly diskSizeGB?: number;
            /**
             * @description Human-readable label that identifies the provider type.
             * @default FLEX
             * @enum {string}
             */
            readonly providerName: "FLEX";
            /** @description Human-readable label that identifies the geographic location of your MongoDB flex cluster. The region you choose can affect network latency for clients accessing your databases. For a complete list of region names, see [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/#std-label-amazon-aws), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), and [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/). */
            regionName: string;
        };
        /**
         * Tenant
         * @description Collection of settings that configures how a cluster might scale its cluster tier and whether the cluster can scale down.
         */
        FreeComputeAutoScalingRules: {
            /**
             * Tenant Instance Sizes
             * @description Maximum instance size to which your cluster can automatically scale.
             * @enum {string}
             */
            maxInstanceSize?: "M0" | "M2" | "M5";
            /**
             * Tenant Instance Sizes
             * @description Minimum instance size to which your cluster can automatically scale.
             * @enum {string}
             */
            minInstanceSize?: "M0" | "M2" | "M5";
        };
        /**
         * GCP
         * @description Collection of settings that configures the network container for a virtual private connection on Amazon Web Services.
         */
        GCPCloudProviderContainer: Omit<components["schemas"]["CloudProviderContainer"], "providerName"> & {
            /** @description IP addresses expressed in Classless Inter-Domain Routing (CIDR) notation that MongoDB Cloud uses for the network peering containers in your project. MongoDB Cloud assigns all of the project's clusters deployed to this cloud provider an IP address from this range. MongoDB Cloud locks this value if an M10 or greater cluster or a network peering connection exists in this project.
             *
             *     These CIDR blocks must fall within the ranges reserved per RFC 1918. GCP further limits the block to a lower bound of the `/18` range.
             *
             *     To modify the CIDR block, the target project cannot have:
             *
             *     - Any M10 or greater clusters
             *     - Any other VPC peering connections
             *
             *      You can also create a new project and create a network peering connection to set the desired MongoDB Cloud network peering container CIDR block for that project. MongoDB Cloud limits the number of MongoDB nodes per network peering connection based on the CIDR block and the region selected for the project.
             *
             *      **Example:** A project in an Google Cloud (GCP) region supporting three availability zones and an MongoDB CIDR network peering container block of limit of `/24` equals 27 three-node replica sets. */
            atlasCidrBlock: string;
            /** @description Unique string that identifies the GCP project in which MongoDB Cloud clusters in this network peering container exist. The response returns **null** if no clusters exist in this network peering container. */
            readonly gcpProjectId?: string;
            /** @description Human-readable label that identifies the network in which MongoDB Cloud clusters in this network peering container exist. MongoDB Cloud returns **null** if no clusters exist in this network peering container. */
            readonly networkName?: string;
            /** @description List of GCP regions to which you want to deploy this MongoDB Cloud network peering container.  In this MongoDB Cloud project, you can deploy clusters only to the GCP regions in this list. To deploy MongoDB Cloud clusters to other GCP regions, create additional projects. */
            regions?: ("AFRICA_SOUTH_1" | "ASIA_EAST_2" | "ASIA_NORTHEAST_2" | "ASIA_NORTHEAST_3" | "ASIA_SOUTH_1" | "ASIA_SOUTH_2" | "ASIA_SOUTHEAST_2" | "AUSTRALIA_SOUTHEAST_1" | "AUSTRALIA_SOUTHEAST_2" | "CENTRAL_US" | "EASTERN_ASIA_PACIFIC" | "EASTERN_US" | "EUROPE_CENTRAL_2" | "EUROPE_NORTH_1" | "EUROPE_WEST_2" | "EUROPE_WEST_3" | "EUROPE_WEST_4" | "EUROPE_WEST_6" | "EUROPE_WEST_10" | "EUROPE_WEST_12" | "MIDDLE_EAST_CENTRAL_1" | "MIDDLE_EAST_CENTRAL_2" | "MIDDLE_EAST_WEST_1" | "NORTH_AMERICA_NORTHEAST_1" | "NORTH_AMERICA_NORTHEAST_2" | "NORTH_AMERICA_SOUTH_1" | "NORTHEASTERN_ASIA_PACIFIC" | "SOUTH_AMERICA_EAST_1" | "SOUTH_AMERICA_WEST_1" | "SOUTHEASTERN_ASIA_PACIFIC" | "US_EAST_4" | "US_EAST_5" | "US_WEST_2" | "US_WEST_3" | "US_WEST_4" | "US_SOUTH_1" | "WESTERN_EUROPE" | "WESTERN_US")[];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "GCP";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "GCP";
        };
        /**
         * GCP
         * @description Collection of settings that configures how a cluster might scale its cluster tier and whether the cluster can scale down. Cluster tier auto-scaling is unavailable for clusters using Low CPU or NVME storage classes.
         */
        GCPComputeAutoScaling: {
            /**
             * GCP Instance Sizes
             * @description Maximum instance size to which your cluster can automatically scale.
             * @enum {string}
             */
            maxInstanceSize?: "M10" | "M20" | "M30" | "M40" | "M50" | "M60" | "M80" | "M140" | "M200" | "M250" | "M300" | "M400" | "R40" | "R50" | "R60" | "R80" | "R200" | "R300" | "R400" | "R600";
            /**
             * GCP Instance Sizes
             * @description Minimum instance size to which your cluster can automatically scale.
             * @enum {string}
             */
            minInstanceSize?: "M10" | "M20" | "M30" | "M40" | "M50" | "M60" | "M80" | "M140" | "M200" | "M250" | "M300" | "M400" | "R40" | "R50" | "R60" | "R80" | "R200" | "R300" | "R400" | "R600";
        };
        GCPCreateDataProcessRegionView: Omit<components["schemas"]["CreateDataProcessRegionView"], "cloudProvider"> & {
            /**
             * @description Human-readable label that identifies the geographic location of the region where you wish to store your archived data.
             * @enum {string}
             */
            region?: "CENTRAL_US" | "WESTERN_EUROPE";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            cloudProvider: "GCP";
        };
        GCPDataProcessRegionView: Omit<components["schemas"]["DataProcessRegionView"], "cloudProvider"> & {
            /**
             * @description Human-readable label that identifies the geographic location of the region where you store your archived data.
             * @enum {string}
             */
            readonly region?: "CENTRAL_US" | "WESTERN_EUROPE";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            cloudProvider: "GCP";
        };
        GCPHardwareSpec: {
            /**
             * GCP Instance Sizes
             * @description Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts of the node type.
             * @enum {string}
             */
            instanceSize?: "M10" | "M20" | "M30" | "M40" | "M50" | "M60" | "M80" | "M140" | "M200" | "M250" | "M300" | "M400" | "R40" | "R50" | "R60" | "R80" | "R200" | "R300" | "R400" | "R600";
            /**
             * Format: int32
             * @description Number of nodes of the given type for MongoDB Cloud to deploy to the region.
             */
            nodeCount?: number;
        };
        GCPHardwareSpec20240805: {
            /**
             * Format: double
             * @description Storage capacity of instance data volumes expressed in gigabytes. Increase this number to add capacity.
             *
             *      This value must be equal for all shards and node types.
             *
             *      This value is not configurable on M0/M2/M5 clusters.
             *
             *      MongoDB Cloud requires this parameter if you set **replicationSpecs**.
             *
             *      If you specify a disk size below the minimum (10 GB), this parameter defaults to the minimum disk size value.
             *
             *      Storage charge calculations depend on whether you choose the default value or a custom value.
             *
             *      The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
             */
            diskSizeGB?: number;
            /**
             * GCP Instance Sizes
             * @description Hardware specification for the instance sizes in this region in this shard. Each instance size has a default storage and memory capacity. Electable nodes and read-only nodes (known as "base nodes") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.
             * @enum {string}
             */
            instanceSize?: "M10" | "M20" | "M30" | "M40" | "M50" | "M60" | "M80" | "M140" | "M200" | "M250" | "M300" | "M400" | "R40" | "R50" | "R60" | "R80" | "R200" | "R300" | "R400" | "R600";
            /**
             * Format: int32
             * @description Number of nodes of the given type for MongoDB Cloud to deploy to the region.
             */
            nodeCount?: number;
        };
        /**
         * GCP Regional Replication Specifications
         * @description Details that explain how MongoDB Cloud replicates data in one region on the specified MongoDB database.
         */
        GCPRegionConfig: Omit<components["schemas"]["CloudRegionConfig"], "providerName"> & {
            analyticsAutoScaling?: components["schemas"]["AdvancedAutoScalingSettings"];
            analyticsSpecs?: components["schemas"]["DedicatedHardwareSpec"];
            autoScaling?: components["schemas"]["AdvancedAutoScalingSettings"];
            readOnlySpecs?: components["schemas"]["DedicatedHardwareSpec"];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "GCP";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "GCP";
        };
        /**
         * GCP Regional Replication Specifications
         * @description Details that explain how MongoDB Cloud replicates data in one region on the specified MongoDB database.
         */
        GCPRegionConfig20240805: Omit<components["schemas"]["CloudRegionConfig20240805"], "providerName"> & {
            analyticsAutoScaling?: components["schemas"]["AdvancedAutoScalingSettings"];
            analyticsSpecs?: components["schemas"]["DedicatedHardwareSpec20240805"];
            autoScaling?: components["schemas"]["AdvancedAutoScalingSettings"];
            readOnlySpecs?: components["schemas"]["DedicatedHardwareSpec20240805"];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "GCP";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "GCP";
        };
        Group: {
            /**
             * Format: int64
             * @description Quantity of MongoDB Cloud clusters deployed in this project.
             */
            readonly clusterCount: number;
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud created this project. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly created: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies the MongoDB Cloud project.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly id?: string;
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /** @description Human-readable label that identifies the project included in the MongoDB Cloud organization. */
            name: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies the MongoDB Cloud organization to which the project belongs.
             * @example 32b6e34b3d91647abb20e7b8
             */
            orgId: string;
            /**
             * @description Applies to Atlas for Government only.
             *
             *     In Commercial Atlas, this field will be rejected in requests and missing in responses.
             *
             *     This field sets restrictions on available regions in the project.
             *
             *     `COMMERCIAL_FEDRAMP_REGIONS_ONLY`: Only allows deployments in FedRAMP Moderate regions.
             *
             *     `GOV_REGIONS_ONLY`: Only allows deployments in GovCloud regions.
             * @default COMMERCIAL_FEDRAMP_REGIONS_ONLY
             * @enum {string}
             */
            regionUsageRestrictions: "COMMERCIAL_FEDRAMP_REGIONS_ONLY" | "GOV_REGIONS_ONLY";
            /** @description List that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the project. */
            tags?: components["schemas"]["ResourceTag"][];
            /**
             * @description Flag that indicates whether to create the project with default alert settings.
             * @default true
             */
            withDefaultAlertsSettings: boolean;
        };
        GroupActiveUserResponse: Omit<WithRequired<components["schemas"]["GroupUserResponse"], "id" | "orgMembershipStatus" | "roles" | "username">, "orgMembershipStatus"> & {
            /**
             * @description Two-character alphabetical string that identifies the MongoDB Cloud user's geographic location. This parameter uses the ISO 3166-1a2 code format.
             * @example US
             */
            readonly country?: string;
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud created the current account. This value is in the ISO 8601 timestamp format in UTC.
             */
            readonly createdAt: string;
            /**
             * @description First or given name that belongs to the MongoDB Cloud user.
             * @example John
             */
            readonly firstName: string;
            /**
             * Format: date-time
             * @description Date and time when the current account last authenticated. This value is in the ISO 8601 timestamp format in UTC.
             */
            readonly lastAuth?: string;
            /**
             * @description Last name, family name, or surname that belongs to the MongoDB Cloud user.
             * @example Doe
             */
            readonly lastName: string;
            /** @description Mobile phone number that belongs to the MongoDB Cloud user. */
            readonly mobileNumber?: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            orgMembershipStatus: "ACTIVE";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            orgMembershipStatus: "ACTIVE";
        };
        GroupPendingUserResponse: Omit<WithRequired<components["schemas"]["GroupUserResponse"], "id" | "orgMembershipStatus" | "roles" | "username">, "orgMembershipStatus"> & {
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud sent the invitation. MongoDB Cloud represents this timestamp in ISO 8601 format in UTC.
             */
            readonly invitationCreatedAt: string;
            /**
             * Format: date-time
             * @description Date and time when the invitation from MongoDB Cloud expires. MongoDB Cloud represents this timestamp in ISO 8601 format in UTC.
             */
            readonly invitationExpiresAt: string;
            /**
             * Format: email
             * @description Username of the MongoDB Cloud user who sent the invitation to join the organization.
             */
            readonly inviterUsername: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            orgMembershipStatus: "PENDING";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            orgMembershipStatus: "PENDING";
        };
        GroupRoleAssignment: {
            /**
             * @description Unique 24-hexadecimal digit string that identifies the project to which these roles belong.
             * @example 32b6e34b3d91647abb20e7b8
             */
            groupId?: string;
            /** @description One or more project-level roles assigned to the MongoDB Cloud user. */
            groupRoles?: ("GROUP_OWNER" | "GROUP_CLUSTER_MANAGER" | "GROUP_STREAM_PROCESSING_OWNER" | "GROUP_DATA_ACCESS_ADMIN" | "GROUP_DATA_ACCESS_READ_WRITE" | "GROUP_DATA_ACCESS_READ_ONLY" | "GROUP_READ_ONLY" | "GROUP_SEARCH_INDEX_EDITOR" | "GROUP_BACKUP_MANAGER" | "GROUP_OBSERVABILITY_VIEWER" | "GROUP_DATABASE_ACCESS_ADMIN")[];
        };
        GroupUserResponse: {
            /**
             * @description Unique 24-hexadecimal digit string that identifies the MongoDB Cloud user.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly id: string;
            /**
             * @description String enum that indicates whether the MongoDB Cloud user has a pending invitation to join the organization or they are already active in the organization.
             * @enum {string}
             */
            readonly orgMembershipStatus: "PENDING" | "ACTIVE";
            /** @description One or more project-level roles assigned to the MongoDB Cloud user. */
            readonly roles: ("GROUP_OWNER" | "GROUP_CLUSTER_MANAGER" | "GROUP_STREAM_PROCESSING_OWNER" | "GROUP_DATA_ACCESS_ADMIN" | "GROUP_DATA_ACCESS_READ_WRITE" | "GROUP_DATA_ACCESS_READ_ONLY" | "GROUP_READ_ONLY" | "GROUP_SEARCH_INDEX_EDITOR" | "GROUP_BACKUP_MANAGER" | "GROUP_OBSERVABILITY_VIEWER" | "GROUP_DATABASE_ACCESS_ADMIN")[];
            /**
             * Format: email
             * @description Email address that represents the username of the MongoDB Cloud user.
             */
            readonly username: string;
        } & (components["schemas"]["GroupPendingUserResponse"] | components["schemas"]["GroupActiveUserResponse"]);
        /** @description Hardware specifications for all electable nodes deployed in the region. Electable nodes can become the primary and can enable local reads. If you don't specify this option, MongoDB Cloud deploys no electable nodes to the region. */
        HardwareSpec: components["schemas"]["AWSHardwareSpec"] | components["schemas"]["AzureHardwareSpec"] | components["schemas"]["GCPHardwareSpec"] | components["schemas"]["TenantHardwareSpec"];
        /** @description Hardware specifications for all electable nodes deployed in the region. Electable nodes can become the primary and can enable local reads. If you don't specify this option, MongoDB Cloud deploys no electable nodes to the region. */
        HardwareSpec20240805: {
            /**
             * Format: double
             * @description Storage capacity of instance data volumes expressed in gigabytes. Increase this number to add capacity.
             *
             *      This value must be equal for all shards and node types.
             *
             *      This value is not configurable on M0/M2/M5 clusters.
             *
             *      MongoDB Cloud requires this parameter if you set **replicationSpecs**.
             *
             *      If you specify a disk size below the minimum (10 GB), this parameter defaults to the minimum disk size value.
             *
             *      Storage charge calculations depend on whether you choose the default value or a custom value.
             *
             *      The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
             */
            diskSizeGB?: number;
        } & (components["schemas"]["AWSHardwareSpec20240805"] | components["schemas"]["AzureHardwareSpec20240805"] | components["schemas"]["GCPHardwareSpec20240805"] | components["schemas"]["TenantHardwareSpec20240805"]);
        /**
         * Host Alerts
         * @description Host alert notifies about activities on mongod host.
         */
        HostAlertViewForNdsGroup: {
            /**
             * Format: date-time
             * @description Date and time until which this alert has been acknowledged. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter if a MongoDB User previously acknowledged this alert.
             *
             *     - To acknowledge this alert forever, set the parameter value to 100 years in the future.
             *
             *     - To unacknowledge a previously acknowledged alert, do not set this parameter value.
             */
            acknowledgedUntil?: string;
            /**
             * @description Comment that a MongoDB Cloud user submitted when acknowledging the alert.
             * @example Expiration on 3/19.  Silencing for 7days.
             */
            acknowledgementComment?: string;
            /**
             * Format: email
             * @description MongoDB Cloud username of the person who acknowledged the alert. The response returns this parameter if a MongoDB Cloud user previously acknowledged this alert.
             */
            readonly acknowledgingUsername?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies the alert configuration that sets this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly alertConfigId: string;
            /**
             * @description Human-readable label that identifies the cluster to which this alert applies. This resource returns this parameter for alerts of events impacting backups, replica sets, or sharded clusters.
             * @example cluster1
             */
            readonly clusterName?: string;
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud created this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly created: string;
            eventTypeName: components["schemas"]["HostEventTypeViewForNdsGroupAlertable"];
            /**
             * @description Unique 24-hexadecimal digit string that identifies the project that owns this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly groupId?: string;
            /**
             * @description Hostname and port of the host to which this alert applies. The resource returns this parameter for alerts of events impacting hosts or replica sets.
             * @example cloud-test.mongodb.com:27017
             */
            readonly hostnameAndPort?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly id: string;
            /**
             * Format: date-time
             * @description Date and time that any notifications were last sent for this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter if MongoDB Cloud has sent notifications for this alert.
             */
            readonly lastNotified?: string;
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /**
             * @description Unique 24-hexadecimal character string that identifies the organization that owns the project to which this alert applies.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly orgId?: string;
            /**
             * @description Name of the replica set to which this alert applies. The response returns this parameter for alerts of events impacting backups, hosts, or replica sets.
             * @example event-replica-set
             */
            readonly replicaSetName?: string;
            /**
             * Format: date-time
             * @description Date and time that this alert changed to `"status" : "CLOSED"`. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter once `"status" : "CLOSED"`.
             */
            readonly resolved?: string;
            /**
             * @description State of this alert at the time you requested its details.
             * @example OPEN
             * @enum {string}
             */
            readonly status: "CANCELLED" | "CLOSED" | "OPEN" | "TRACKING";
            /**
             * Format: date-time
             * @description Date and time when someone last updated this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly updated: string;
        };
        /**
         * Host Event Types
         * @description Event type that triggers an alert.
         * @example HOST_DOWN
         * @enum {string}
         */
        HostEventTypeViewForNdsGroupAlertable: "HOST_DOWN" | "HOST_HAS_INDEX_SUGGESTIONS" | "HOST_MONGOT_CRASHING_OOM" | "HOST_MONGOT_STOP_REPLICATION" | "HOST_NOT_ENOUGH_DISK_SPACE" | "SSH_KEY_NDS_HOST_ACCESS_REQUESTED" | "SSH_KEY_NDS_HOST_ACCESS_REFRESHED" | "PUSH_BASED_LOG_EXPORT_STOPPED" | "PUSH_BASED_LOG_EXPORT_DROPPED_LOG" | "HOST_VERSION_BEHIND" | "VERSION_BEHIND" | "HOST_EXPOSED" | "HOST_SSL_CERTIFICATE_STALE" | "HOST_SECURITY_CHECKUP_NOT_MET";
        /**
         * Host Metric Alerts
         * @description Host Metric Alert notifies about changes of measurements or metrics for mongod host.
         */
        HostMetricAlert: {
            /**
             * Format: date-time
             * @description Date and time until which this alert has been acknowledged. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter if a MongoDB User previously acknowledged this alert.
             *
             *     - To acknowledge this alert forever, set the parameter value to 100 years in the future.
             *
             *     - To unacknowledge a previously acknowledged alert, do not set this parameter value.
             */
            acknowledgedUntil?: string;
            /**
             * @description Comment that a MongoDB Cloud user submitted when acknowledging the alert.
             * @example Expiration on 3/19.  Silencing for 7days.
             */
            acknowledgementComment?: string;
            /**
             * Format: email
             * @description MongoDB Cloud username of the person who acknowledged the alert. The response returns this parameter if a MongoDB Cloud user previously acknowledged this alert.
             */
            readonly acknowledgingUsername?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies the alert configuration that sets this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly alertConfigId: string;
            /**
             * @description Human-readable label that identifies the cluster to which this alert applies. This resource returns this parameter for alerts of events impacting backups, replica sets, or sharded clusters.
             * @example cluster1
             */
            readonly clusterName?: string;
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud created this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly created: string;
            currentValue?: components["schemas"]["HostMetricValue"];
            eventTypeName: components["schemas"]["HostMetricEventTypeViewAlertable"];
            /**
             * @description Unique 24-hexadecimal digit string that identifies the project that owns this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly groupId?: string;
            /**
             * @description Hostname and port of the host to which this alert applies. The resource returns this parameter for alerts of events impacting hosts or replica sets.
             * @example cloud-test.mongodb.com:27017
             */
            readonly hostnameAndPort?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly id: string;
            /**
             * Format: date-time
             * @description Date and time that any notifications were last sent for this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter if MongoDB Cloud has sent notifications for this alert.
             */
            readonly lastNotified?: string;
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /**
             * @description Name of the metric against which Atlas checks the configured `metricThreshold.threshold`.
             *
             *     To learn more about the available metrics, see <a href="https://www.mongodb.com/docs/atlas/reference/alert-host-metrics/#std-label-measurement-types" target="_blank">Host Metrics</a>.
             *
             *     **NOTE**: If you set eventTypeName to OUTSIDE_SERVERLESS_METRIC_THRESHOLD, you can specify only metrics available for serverless. To learn more, see <a href="https://dochub.mongodb.org/core/alert-config-serverless-measurements" target="_blank">Serverless Measurements</a>.
             * @example ASSERT_USER
             */
            readonly metricName?: string;
            /**
             * @description Unique 24-hexadecimal character string that identifies the organization that owns the project to which this alert applies.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly orgId?: string;
            /**
             * @description Name of the replica set to which this alert applies. The response returns this parameter for alerts of events impacting backups, hosts, or replica sets.
             * @example event-replica-set
             */
            readonly replicaSetName?: string;
            /**
             * Format: date-time
             * @description Date and time that this alert changed to `"status" : "CLOSED"`. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter once `"status" : "CLOSED"`.
             */
            readonly resolved?: string;
            /**
             * @description State of this alert at the time you requested its details.
             * @example OPEN
             * @enum {string}
             */
            readonly status: "CANCELLED" | "CLOSED" | "OPEN" | "TRACKING";
            /**
             * Format: date-time
             * @description Date and time when someone last updated this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly updated: string;
        };
        /**
         * Host Metric Event Types
         * @description Event type that triggers an alert.
         * @example OUTSIDE_METRIC_THRESHOLD
         * @enum {string}
         */
        HostMetricEventTypeViewAlertable: "OUTSIDE_METRIC_THRESHOLD";
        /** @description Value of the metric that triggered the alert. The resource returns this parameter for alerts of events impacting hosts. */
        HostMetricValue: {
            /**
             * Format: double
             * @description Amount of the **metricName** recorded at the time of the event. This value triggered the alert.
             */
            readonly number?: number;
            /**
             * @description Element used to express the quantity in **currentValue.number**. This can be an element of time, storage capacity, and the like. This metric triggered the alert.
             * @enum {string}
             */
            readonly units?: "bits" | "Kbits" | "Mbits" | "Gbits" | "bytes" | "KB" | "MB" | "GB" | "TB" | "PB" | "nsec" | "msec" | "sec" | "min" | "hours" | "million minutes" | "days" | "requests" | "1000 requests" | "GB seconds" | "GB hours" | "GB days" | "RPU" | "thousand RPU" | "million RPU" | "WPU" | "thousand WPU" | "million WPU" | "count" | "thousand" | "million" | "billion";
        };
        /**
         * Ingestion Destination
         * @description Ingestion destination of a Data Lake Pipeline.
         */
        IngestionSink: {
            /**
             * @description Type of ingestion destination of this Data Lake Pipeline.
             * @enum {string}
             */
            readonly type?: "DLS";
        };
        /**
         * Ingestion Source
         * @description Ingestion Source of a Data Lake Pipeline.
         */
        IngestionSource: {
            /**
             * @description Type of ingestion source of this Data Lake Pipeline.
             * @enum {string}
             */
            type?: "PERIODIC_CPS" | "ON_DEMAND_CPS";
        };
        /**
         * Line Item
         * @description One service included in this invoice.
         */
        InvoiceLineItem: {
            /** @description Human-readable label that identifies the cluster that incurred the charge. */
            readonly clusterName?: string;
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud created this line item. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly created?: string;
            /**
             * Format: int64
             * @description Sum by which MongoDB discounted this line item. MongoDB Cloud expresses this value in cents (100ths of one US Dollar). The resource returns this parameter when a discount applies.
             */
            readonly discountCents?: number;
            /**
             * Format: date-time
             * @description Date and time when when MongoDB Cloud finished charging for this line item. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly endDate?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies the project associated to this line item.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly groupId?: string;
            /** @description Human-readable label that identifies the project. */
            groupName?: string;
            /** @description Comment that applies to this line item. */
            readonly note?: string;
            /**
             * Format: float
             * @description Percentage by which MongoDB discounted this line item. The resource returns this parameter when a discount applies.
             */
            readonly percentDiscount?: number;
            /**
             * Format: double
             * @description Number of units included for the line item. These can be expressions of storage (GB), time (hours), or other units.
             */
            readonly quantity?: number;
            /**
             * @description Human-readable description of the service that this line item provided. This Stock Keeping Unit (SKU) could be the instance type, a support charge, advanced security, or another service.
             * @enum {string}
             */
            readonly sku?: "CLASSIC_BACKUP_OPLOG" | "CLASSIC_BACKUP_STORAGE" | "CLASSIC_BACKUP_SNAPSHOT_CREATE" | "CLASSIC_BACKUP_DAILY_MINIMUM" | "CLASSIC_BACKUP_FREE_TIER" | "CLASSIC_COUPON" | "BACKUP_STORAGE_FREE_TIER" | "BACKUP_STORAGE" | "FLEX_CONSULTING" | "CLOUD_MANAGER_CLASSIC" | "CLOUD_MANAGER_BASIC_FREE_TIER" | "CLOUD_MANAGER_BASIC" | "CLOUD_MANAGER_PREMIUM" | "CLOUD_MANAGER_FREE_TIER" | "CLOUD_MANAGER_STANDARD_FREE_TIER" | "CLOUD_MANAGER_STANDARD_ANNUAL" | "CLOUD_MANAGER_STANDARD" | "CLOUD_MANAGER_FREE_TRIAL" | "ATLAS_INSTANCE_M0" | "ATLAS_INSTANCE_M2" | "ATLAS_INSTANCE_M5" | "ATLAS_AWS_INSTANCE_M10" | "ATLAS_AWS_INSTANCE_M20" | "ATLAS_AWS_INSTANCE_M30" | "ATLAS_AWS_INSTANCE_M40" | "ATLAS_AWS_INSTANCE_M50" | "ATLAS_AWS_INSTANCE_M60" | "ATLAS_AWS_INSTANCE_M80" | "ATLAS_AWS_INSTANCE_M100" | "ATLAS_AWS_INSTANCE_M140" | "ATLAS_AWS_INSTANCE_M200" | "ATLAS_AWS_INSTANCE_M300" | "ATLAS_AWS_INSTANCE_M40_LOW_CPU" | "ATLAS_AWS_INSTANCE_M50_LOW_CPU" | "ATLAS_AWS_INSTANCE_M60_LOW_CPU" | "ATLAS_AWS_INSTANCE_M80_LOW_CPU" | "ATLAS_AWS_INSTANCE_M200_LOW_CPU" | "ATLAS_AWS_INSTANCE_M300_LOW_CPU" | "ATLAS_AWS_INSTANCE_M400_LOW_CPU" | "ATLAS_AWS_INSTANCE_M700_LOW_CPU" | "ATLAS_AWS_INSTANCE_M40_NVME" | "ATLAS_AWS_INSTANCE_M50_NVME" | "ATLAS_AWS_INSTANCE_M60_NVME" | "ATLAS_AWS_INSTANCE_M80_NVME" | "ATLAS_AWS_INSTANCE_M200_NVME" | "ATLAS_AWS_INSTANCE_M400_NVME" | "ATLAS_AWS_INSTANCE_M10_PAUSED" | "ATLAS_AWS_INSTANCE_M20_PAUSED" | "ATLAS_AWS_INSTANCE_M30_PAUSED" | "ATLAS_AWS_INSTANCE_M40_PAUSED" | "ATLAS_AWS_INSTANCE_M50_PAUSED" | "ATLAS_AWS_INSTANCE_M60_PAUSED" | "ATLAS_AWS_INSTANCE_M80_PAUSED" | "ATLAS_AWS_INSTANCE_M100_PAUSED" | "ATLAS_AWS_INSTANCE_M140_PAUSED" | "ATLAS_AWS_INSTANCE_M200_PAUSED" | "ATLAS_AWS_INSTANCE_M300_PAUSED" | "ATLAS_AWS_INSTANCE_M40_LOW_CPU_PAUSED" | "ATLAS_AWS_INSTANCE_M50_LOW_CPU_PAUSED" | "ATLAS_AWS_INSTANCE_M60_LOW_CPU_PAUSED" | "ATLAS_AWS_INSTANCE_M80_LOW_CPU_PAUSED" | "ATLAS_AWS_INSTANCE_M200_LOW_CPU_PAUSED" | "ATLAS_AWS_INSTANCE_M300_LOW_CPU_PAUSED" | "ATLAS_AWS_INSTANCE_M400_LOW_CPU_PAUSED" | "ATLAS_AWS_INSTANCE_M700_LOW_CPU_PAUSED" | "ATLAS_AWS_SEARCH_INSTANCE_S20_COMPUTE_NVME" | "ATLAS_AWS_SEARCH_INSTANCE_S30_COMPUTE_NVME" | "ATLAS_AWS_SEARCH_INSTANCE_S40_COMPUTE_NVME" | "ATLAS_AWS_SEARCH_INSTANCE_S50_COMPUTE_NVME" | "ATLAS_AWS_SEARCH_INSTANCE_S60_COMPUTE_NVME" | "ATLAS_AWS_SEARCH_INSTANCE_S70_COMPUTE_NVME" | "ATLAS_AWS_SEARCH_INSTANCE_S80_COMPUTE_NVME" | "ATLAS_AWS_SEARCH_INSTANCE_S30_MEMORY_NVME" | "ATLAS_AWS_SEARCH_INSTANCE_S40_MEMORY_NVME" | "ATLAS_AWS_SEARCH_INSTANCE_S50_MEMORY_NVME" | "ATLAS_AWS_SEARCH_INSTANCE_S60_MEMORY_NVME" | "ATLAS_AWS_SEARCH_INSTANCE_S80_MEMORY_NVME" | "ATLAS_AWS_SEARCH_INSTANCE_S90_MEMORY_NVME" | "ATLAS_AWS_SEARCH_INSTANCE_S100_MEMORY_NVME" | "ATLAS_AWS_SEARCH_INSTANCE_S110_MEMORY_NVME" | "ATLAS_AWS_SEARCH_INSTANCE_S40_STORAGE_NVME" | "ATLAS_AWS_SEARCH_INSTANCE_S50_STORAGE_NVME" | "ATLAS_AWS_SEARCH_INSTANCE_S60_STORAGE_NVME" | "ATLAS_AWS_SEARCH_INSTANCE_S80_STORAGE_NVME" | "ATLAS_AWS_SEARCH_INSTANCE_S90_STORAGE_NVME" | "ATLAS_AWS_STORAGE_PROVISIONED" | "ATLAS_AWS_STORAGE_STANDARD" | "ATLAS_AWS_STORAGE_STANDARD_GP3" | "ATLAS_AWS_STORAGE_IOPS" | "ATLAS_AWS_DATA_TRANSFER_SAME_REGION" | "ATLAS_AWS_DATA_TRANSFER_DIFFERENT_REGION" | "ATLAS_AWS_DATA_TRANSFER_INTERNET" | "ATLAS_AWS_BACKUP_SNAPSHOT_STORAGE" | "ATLAS_AWS_BACKUP_DOWNLOAD_VM" | "ATLAS_AWS_BACKUP_DOWNLOAD_VM_STORAGE" | "ATLAS_AWS_BACKUP_DOWNLOAD_VM_STORAGE_IOPS" | "ATLAS_AWS_PRIVATE_ENDPOINT" | "ATLAS_AWS_PRIVATE_ENDPOINT_CAPACITY_UNITS" | "ATLAS_GCP_SEARCH_INSTANCE_S20_COMPUTE_LOCALSSD" | "ATLAS_GCP_SEARCH_INSTANCE_S30_COMPUTE_LOCALSSD" | "ATLAS_GCP_SEARCH_INSTANCE_S40_COMPUTE_LOCALSSD" | "ATLAS_GCP_SEARCH_INSTANCE_S50_COMPUTE_LOCALSSD" | "ATLAS_GCP_SEARCH_INSTANCE_S60_COMPUTE_LOCALSSD" | "ATLAS_GCP_SEARCH_INSTANCE_S70_COMPUTE_LOCALSSD" | "ATLAS_GCP_SEARCH_INSTANCE_S80_COMPUTE_LOCALSSD" | "ATLAS_GCP_SEARCH_INSTANCE_S30_MEMORY_LOCALSSD" | "ATLAS_GCP_SEARCH_INSTANCE_S40_MEMORY_LOCALSSD" | "ATLAS_GCP_SEARCH_INSTANCE_S50_MEMORY_LOCALSSD" | "ATLAS_GCP_SEARCH_INSTANCE_S60_MEMORY_LOCALSSD" | "ATLAS_GCP_SEARCH_INSTANCE_S70_MEMORY_LOCALSSD" | "ATLAS_GCP_SEARCH_INSTANCE_S80_MEMORY_LOCALSSD" | "ATLAS_GCP_SEARCH_INSTANCE_S90_MEMORY_LOCALSSD" | "ATLAS_GCP_SEARCH_INSTANCE_S100_MEMORY_LOCALSSD" | "ATLAS_GCP_SEARCH_INSTANCE_S110_MEMORY_LOCALSSD" | "ATLAS_GCP_SEARCH_INSTANCE_S120_MEMORY_LOCALSSD" | "ATLAS_GCP_SEARCH_INSTANCE_S130_MEMORY_LOCALSSD" | "ATLAS_GCP_SEARCH_INSTANCE_S140_MEMORY_LOCALSSD" | "ATLAS_GCP_INSTANCE_M10" | "ATLAS_GCP_INSTANCE_M20" | "ATLAS_GCP_INSTANCE_M30" | "ATLAS_GCP_INSTANCE_M40" | "ATLAS_GCP_INSTANCE_M50" | "ATLAS_GCP_INSTANCE_M60" | "ATLAS_GCP_INSTANCE_M80" | "ATLAS_GCP_INSTANCE_M140" | "ATLAS_GCP_INSTANCE_M200" | "ATLAS_GCP_INSTANCE_M250" | "ATLAS_GCP_INSTANCE_M300" | "ATLAS_GCP_INSTANCE_M400" | "ATLAS_GCP_INSTANCE_M40_LOW_CPU" | "ATLAS_GCP_INSTANCE_M50_LOW_CPU" | "ATLAS_GCP_INSTANCE_M60_LOW_CPU" | "ATLAS_GCP_INSTANCE_M80_LOW_CPU" | "ATLAS_GCP_INSTANCE_M200_LOW_CPU" | "ATLAS_GCP_INSTANCE_M300_LOW_CPU" | "ATLAS_GCP_INSTANCE_M400_LOW_CPU" | "ATLAS_GCP_INSTANCE_M600_LOW_CPU" | "ATLAS_GCP_INSTANCE_M10_PAUSED" | "ATLAS_GCP_INSTANCE_M20_PAUSED" | "ATLAS_GCP_INSTANCE_M30_PAUSED" | "ATLAS_GCP_INSTANCE_M40_PAUSED" | "ATLAS_GCP_INSTANCE_M50_PAUSED" | "ATLAS_GCP_INSTANCE_M60_PAUSED" | "ATLAS_GCP_INSTANCE_M80_PAUSED" | "ATLAS_GCP_INSTANCE_M140_PAUSED" | "ATLAS_GCP_INSTANCE_M200_PAUSED" | "ATLAS_GCP_INSTANCE_M250_PAUSED" | "ATLAS_GCP_INSTANCE_M300_PAUSED" | "ATLAS_GCP_INSTANCE_M400_PAUSED" | "ATLAS_GCP_INSTANCE_M40_LOW_CPU_PAUSED" | "ATLAS_GCP_INSTANCE_M50_LOW_CPU_PAUSED" | "ATLAS_GCP_INSTANCE_M60_LOW_CPU_PAUSED" | "ATLAS_GCP_INSTANCE_M80_LOW_CPU_PAUSED" | "ATLAS_GCP_INSTANCE_M200_LOW_CPU_PAUSED" | "ATLAS_GCP_INSTANCE_M300_LOW_CPU_PAUSED" | "ATLAS_GCP_INSTANCE_M400_LOW_CPU_PAUSED" | "ATLAS_GCP_INSTANCE_M600_LOW_CPU_PAUSED" | "ATLAS_GCP_DATA_TRANSFER_INTERNET" | "ATLAS_GCP_STORAGE_SSD" | "ATLAS_GCP_DATA_TRANSFER_INTER_CONNECT" | "ATLAS_GCP_DATA_TRANSFER_INTER_ZONE" | "ATLAS_GCP_DATA_TRANSFER_INTER_REGION" | "ATLAS_GCP_DATA_TRANSFER_GOOGLE" | "ATLAS_GCP_BACKUP_SNAPSHOT_STORAGE" | "ATLAS_GCP_BACKUP_DOWNLOAD_VM" | "ATLAS_GCP_BACKUP_DOWNLOAD_VM_STORAGE" | "ATLAS_GCP_PRIVATE_ENDPOINT" | "ATLAS_GCP_PRIVATE_ENDPOINT_CAPACITY_UNITS" | "ATLAS_GCP_SNAPSHOT_COPY_DATA_TRANSFER" | "ATLAS_AZURE_INSTANCE_M10" | "ATLAS_AZURE_INSTANCE_M20" | "ATLAS_AZURE_INSTANCE_M30" | "ATLAS_AZURE_INSTANCE_M40" | "ATLAS_AZURE_INSTANCE_M50" | "ATLAS_AZURE_INSTANCE_M60" | "ATLAS_AZURE_INSTANCE_M80" | "ATLAS_AZURE_INSTANCE_M90" | "ATLAS_AZURE_INSTANCE_M200" | "ATLAS_AZURE_INSTANCE_R40" | "ATLAS_AZURE_INSTANCE_R50" | "ATLAS_AZURE_INSTANCE_R60" | "ATLAS_AZURE_INSTANCE_R80" | "ATLAS_AZURE_INSTANCE_R200" | "ATLAS_AZURE_INSTANCE_R300" | "ATLAS_AZURE_INSTANCE_R400" | "ATLAS_AZURE_INSTANCE_M60_NVME" | "ATLAS_AZURE_INSTANCE_M80_NVME" | "ATLAS_AZURE_INSTANCE_M200_NVME" | "ATLAS_AZURE_INSTANCE_M300_NVME" | "ATLAS_AZURE_INSTANCE_M400_NVME" | "ATLAS_AZURE_INSTANCE_M600_NVME" | "ATLAS_AZURE_INSTANCE_M10_PAUSED" | "ATLAS_AZURE_INSTANCE_M20_PAUSED" | "ATLAS_AZURE_INSTANCE_M30_PAUSED" | "ATLAS_AZURE_INSTANCE_M40_PAUSED" | "ATLAS_AZURE_INSTANCE_M50_PAUSED" | "ATLAS_AZURE_INSTANCE_M60_PAUSED" | "ATLAS_AZURE_INSTANCE_M80_PAUSED" | "ATLAS_AZURE_INSTANCE_M90_PAUSED" | "ATLAS_AZURE_INSTANCE_M200_PAUSED" | "ATLAS_AZURE_INSTANCE_R40_PAUSED" | "ATLAS_AZURE_INSTANCE_R50_PAUSED" | "ATLAS_AZURE_INSTANCE_R60_PAUSED" | "ATLAS_AZURE_INSTANCE_R80_PAUSED" | "ATLAS_AZURE_INSTANCE_R200_PAUSED" | "ATLAS_AZURE_INSTANCE_R300_PAUSED" | "ATLAS_AZURE_INSTANCE_R400_PAUSED" | "ATLAS_AZURE_SEARCH_INSTANCE_S20_COMPUTE_LOCALSSD" | "ATLAS_AZURE_SEARCH_INSTANCE_S30_COMPUTE_LOCALSSD" | "ATLAS_AZURE_SEARCH_INSTANCE_S40_COMPUTE_LOCALSSD" | "ATLAS_AZURE_SEARCH_INSTANCE_S50_COMPUTE_LOCALSSD" | "ATLAS_AZURE_SEARCH_INSTANCE_S60_COMPUTE_LOCALSSD" | "ATLAS_AZURE_SEARCH_INSTANCE_S70_COMPUTE_LOCALSSD" | "ATLAS_AZURE_SEARCH_INSTANCE_S80_COMPUTE_LOCALSSD" | "ATLAS_AZURE_SEARCH_INSTANCE_S40_MEMORY_LOCALSSD" | "ATLAS_AZURE_SEARCH_INSTANCE_S50_MEMORY_LOCALSSD" | "ATLAS_AZURE_SEARCH_INSTANCE_S60_MEMORY_LOCALSSD" | "ATLAS_AZURE_SEARCH_INSTANCE_S80_MEMORY_LOCALSSD" | "ATLAS_AZURE_SEARCH_INSTANCE_S90_MEMORY_LOCALSSD" | "ATLAS_AZURE_SEARCH_INSTANCE_S100_MEMORY_LOCALSSD" | "ATLAS_AZURE_SEARCH_INSTANCE_S110_MEMORY_LOCALSSD" | "ATLAS_AZURE_SEARCH_INSTANCE_S130_MEMORY_LOCALSSD" | "ATLAS_AZURE_SEARCH_INSTANCE_S135_MEMORY_LOCALSSD" | "ATLAS_AZURE_STORAGE_P2" | "ATLAS_AZURE_STORAGE_P3" | "ATLAS_AZURE_STORAGE_P4" | "ATLAS_AZURE_STORAGE_P6" | "ATLAS_AZURE_STORAGE_P10" | "ATLAS_AZURE_STORAGE_P15" | "ATLAS_AZURE_STORAGE_P20" | "ATLAS_AZURE_STORAGE_P30" | "ATLAS_AZURE_STORAGE_P40" | "ATLAS_AZURE_STORAGE_P50" | "ATLAS_AZURE_DATA_TRANSFER" | "ATLAS_AZURE_DATA_TRANSFER_REGIONAL_VNET_IN" | "ATLAS_AZURE_DATA_TRANSFER_REGIONAL_VNET_OUT" | "ATLAS_AZURE_DATA_TRANSFER_GLOBAL_VNET_IN" | "ATLAS_AZURE_DATA_TRANSFER_GLOBAL_VNET_OUT" | "ATLAS_AZURE_DATA_TRANSFER_AVAILABILITY_ZONE_IN" | "ATLAS_AZURE_DATA_TRANSFER_AVAILABILITY_ZONE_OUT" | "ATLAS_AZURE_DATA_TRANSFER_INTER_REGION_INTRA_CONTINENT" | "ATLAS_AZURE_DATA_TRANSFER_INTER_REGION_INTER_CONTINENT" | "ATLAS_AZURE_BACKUP_SNAPSHOT_STORAGE" | "ATLAS_AZURE_BACKUP_DOWNLOAD_VM" | "ATLAS_AZURE_BACKUP_DOWNLOAD_VM_STORAGE_P2" | "ATLAS_AZURE_BACKUP_DOWNLOAD_VM_STORAGE_P3" | "ATLAS_AZURE_BACKUP_DOWNLOAD_VM_STORAGE_P4" | "ATLAS_AZURE_BACKUP_DOWNLOAD_VM_STORAGE_P6" | "ATLAS_AZURE_BACKUP_DOWNLOAD_VM_STORAGE_P10" | "ATLAS_AZURE_BACKUP_DOWNLOAD_VM_STORAGE_P15" | "ATLAS_AZURE_BACKUP_DOWNLOAD_VM_STORAGE_P20" | "ATLAS_AZURE_BACKUP_DOWNLOAD_VM_STORAGE_P30" | "ATLAS_AZURE_BACKUP_DOWNLOAD_VM_STORAGE_P40" | "ATLAS_AZURE_BACKUP_DOWNLOAD_VM_STORAGE_P50" | "ATLAS_AZURE_STANDARD_STORAGE" | "ATLAS_AZURE_EXTENDED_STANDARD_IOPS" | "ATLAS_AZURE_BACKUP_DOWNLOAD_VM_STORAGE" | "ATLAS_AZURE_BACKUP_DOWNLOAD_VM_STORAGE_EXTENDED_IOPS" | "ATLAS_AZURE_SNAPSHOT_EXPORT_VM_STORAGE" | "ATLAS_AZURE_SNAPSHOT_EXPORT_VM_STORAGE_EXTENDED_IOPS" | "ATLAS_BI_CONNECTOR" | "ATLAS_ADVANCED_SECURITY" | "ATLAS_ENTERPRISE_AUDITING" | "ATLAS_FREE_SUPPORT" | "ATLAS_SUPPORT" | "ATLAS_NDS_BACKFILL_SUPPORT" | "STITCH_DATA_DOWNLOADED_FREE_TIER" | "STITCH_DATA_DOWNLOADED" | "STITCH_COMPUTE_FREE_TIER" | "STITCH_COMPUTE" | "CREDIT" | "MINIMUM_CHARGE" | "CHARTS_DATA_DOWNLOADED_FREE_TIER" | "CHARTS_DATA_DOWNLOADED" | "ATLAS_DATA_LAKE_AWS_DATA_RETURNED_SAME_REGION" | "ATLAS_DATA_LAKE_AWS_DATA_RETURNED_DIFFERENT_REGION" | "ATLAS_DATA_LAKE_AWS_DATA_RETURNED_INTERNET" | "ATLAS_DATA_LAKE_AWS_DATA_SCANNED" | "ATLAS_DATA_LAKE_AWS_DATA_TRANSFERRED_FROM_DIFFERENT_REGION" | "ATLAS_NDS_AWS_DATA_LAKE_STORAGE_ACCESS" | "ATLAS_NDS_AWS_DATA_LAKE_STORAGE" | "ATLAS_DATA_FEDERATION_AZURE_DATA_RETURNED_SAME_REGION" | "ATLAS_DATA_FEDERATION_AZURE_DATA_RETURNED_SAME_CONTINENT" | "ATLAS_DATA_FEDERATION_AZURE_DATA_RETURNED_DIFFERENT_CONTINENT" | "ATLAS_DATA_FEDERATION_AZURE_DATA_RETURNED_INTERNET" | "ATLAS_DATA_FEDERATION_GCP_DATA_RETURNED_SAME_REGION" | "ATLAS_DATA_FEDERATION_GCP_DATA_RETURNED_DIFFERENT_REGION" | "ATLAS_DATA_FEDERATION_GCP_DATA_RETURNED_INTERNET" | "ATLAS_DATA_FEDERATION_AZURE_DATA_SCANNED" | "ATLAS_NDS_AZURE_DATA_LAKE_STORAGE_ACCESS" | "ATLAS_NDS_AZURE_DATA_LAKE_STORAGE" | "ATLAS_DATA_FEDERATION_GCP_DATA_SCANNED" | "ATLAS_NDS_GCP_DATA_LAKE_STORAGE_ACCESS" | "ATLAS_NDS_GCP_DATA_LAKE_STORAGE" | "ATLAS_NDS_AWS_OBJECT_STORAGE_ACCESS" | "ATLAS_NDS_AWS_COMPRESSED_OBJECT_STORAGE" | "ATLAS_NDS_AZURE_OBJECT_STORAGE_ACCESS" | "ATLAS_NDS_AZURE_OBJECT_STORAGE" | "ATLAS_NDS_AZURE_COMPRESSED_OBJECT_STORAGE" | "ATLAS_NDS_GCP_OBJECT_STORAGE_ACCESS" | "ATLAS_NDS_GCP_OBJECT_STORAGE" | "ATLAS_NDS_GCP_COMPRESSED_OBJECT_STORAGE" | "ATLAS_ARCHIVE_ACCESS_PARTITION_LOCATE" | "ATLAS_NDS_AWS_PIT_RESTORE_STORAGE_FREE_TIER" | "ATLAS_NDS_AWS_PIT_RESTORE_STORAGE" | "ATLAS_NDS_GCP_PIT_RESTORE_STORAGE_FREE_TIER" | "ATLAS_NDS_GCP_PIT_RESTORE_STORAGE" | "ATLAS_NDS_AZURE_PIT_RESTORE_STORAGE_FREE_TIER" | "ATLAS_NDS_AZURE_PIT_RESTORE_STORAGE" | "ATLAS_NDS_AZURE_PRIVATE_ENDPOINT_CAPACITY_UNITS" | "ATLAS_NDS_AZURE_CMK_PRIVATE_NETWORKING" | "ATLAS_NDS_AWS_CMK_PRIVATE_NETWORKING" | "ATLAS_NDS_AWS_OBJECT_STORAGE" | "ATLAS_NDS_AWS_SNAPSHOT_EXPORT_UPLOAD" | "ATLAS_NDS_AZURE_SNAPSHOT_EXPORT_UPLOAD" | "ATLAS_NDS_AZURE_SNAPSHOT_EXPORT_VM" | "ATLAS_NDS_AZURE_SNAPSHOT_EXPORT_VM_M40" | "ATLAS_NDS_AZURE_SNAPSHOT_EXPORT_VM_M50" | "ATLAS_NDS_AZURE_SNAPSHOT_EXPORT_VM_M60" | "ATLAS_NDS_AZURE_SNAPSHOT_EXPORT_VM_STORAGE_P2" | "ATLAS_NDS_AZURE_SNAPSHOT_EXPORT_VM_STORAGE_P3" | "ATLAS_NDS_AZURE_SNAPSHOT_EXPORT_VM_STORAGE_P4" | "ATLAS_NDS_AZURE_SNAPSHOT_EXPORT_VM_STORAGE_P6" | "ATLAS_NDS_AZURE_SNAPSHOT_EXPORT_VM_STORAGE_P10" | "ATLAS_NDS_AZURE_SNAPSHOT_EXPORT_VM_STORAGE_P15" | "ATLAS_NDS_AZURE_SNAPSHOT_EXPORT_VM_STORAGE_P20" | "ATLAS_NDS_AZURE_SNAPSHOT_EXPORT_VM_STORAGE_P30" | "ATLAS_NDS_AZURE_SNAPSHOT_EXPORT_VM_STORAGE_P40" | "ATLAS_NDS_AZURE_SNAPSHOT_EXPORT_VM_STORAGE_P50" | "ATLAS_NDS_AWS_SNAPSHOT_EXPORT_VM" | "ATLAS_NDS_AWS_SNAPSHOT_EXPORT_VM_M40" | "ATLAS_NDS_AWS_SNAPSHOT_EXPORT_VM_M50" | "ATLAS_NDS_AWS_SNAPSHOT_EXPORT_VM_M60" | "ATLAS_NDS_AWS_SNAPSHOT_EXPORT_VM_STORAGE" | "ATLAS_NDS_AWS_SNAPSHOT_EXPORT_VM_STORAGE_IOPS" | "ATLAS_NDS_GCP_SNAPSHOT_EXPORT_VM" | "ATLAS_NDS_GCP_SNAPSHOT_EXPORT_VM_M40" | "ATLAS_NDS_GCP_SNAPSHOT_EXPORT_VM_M50" | "ATLAS_NDS_GCP_SNAPSHOT_EXPORT_VM_M60" | "ATLAS_NDS_GCP_SNAPSHOT_EXPORT_VM_STORAGE" | "ATLAS_NDS_AWS_SERVERLESS_RPU" | "ATLAS_NDS_AWS_SERVERLESS_WPU" | "ATLAS_NDS_AWS_SERVERLESS_STORAGE" | "ATLAS_NDS_AWS_SERVERLESS_CONTINUOUS_BACKUP" | "ATLAS_NDS_AWS_SERVERLESS_BACKUP_RESTORE_VM" | "ATLAS_NDS_AWS_SERVERLESS_DATA_TRANSFER_PREVIEW" | "ATLAS_NDS_AWS_SERVERLESS_DATA_TRANSFER" | "ATLAS_NDS_AWS_SERVERLESS_DATA_TRANSFER_REGIONAL" | "ATLAS_NDS_AWS_SERVERLESS_DATA_TRANSFER_CROSS_REGION" | "ATLAS_NDS_AWS_SERVERLESS_DATA_TRANSFER_INTERNET" | "ATLAS_NDS_GCP_SERVERLESS_RPU" | "ATLAS_NDS_GCP_SERVERLESS_WPU" | "ATLAS_NDS_GCP_SERVERLESS_STORAGE" | "ATLAS_NDS_GCP_SERVERLESS_CONTINUOUS_BACKUP" | "ATLAS_NDS_GCP_SERVERLESS_BACKUP_RESTORE_VM" | "ATLAS_NDS_GCP_SERVERLESS_DATA_TRANSFER_PREVIEW" | "ATLAS_NDS_GCP_SERVERLESS_DATA_TRANSFER" | "ATLAS_NDS_GCP_SERVERLESS_DATA_TRANSFER_REGIONAL" | "ATLAS_NDS_GCP_SERVERLESS_DATA_TRANSFER_CROSS_REGION" | "ATLAS_NDS_GCP_SERVERLESS_DATA_TRANSFER_INTERNET" | "ATLAS_NDS_AZURE_SERVERLESS_RPU" | "ATLAS_NDS_AZURE_SERVERLESS_WPU" | "ATLAS_NDS_AZURE_SERVERLESS_STORAGE" | "ATLAS_NDS_AZURE_SERVERLESS_CONTINUOUS_BACKUP" | "ATLAS_NDS_AZURE_SERVERLESS_BACKUP_RESTORE_VM" | "ATLAS_NDS_AZURE_SERVERLESS_DATA_TRANSFER_PREVIEW" | "ATLAS_NDS_AZURE_SERVERLESS_DATA_TRANSFER" | "ATLAS_NDS_AZURE_SERVERLESS_DATA_TRANSFER_REGIONAL" | "ATLAS_NDS_AZURE_SERVERLESS_DATA_TRANSFER_CROSS_REGION" | "ATLAS_NDS_AZURE_SERVERLESS_DATA_TRANSFER_INTERNET" | "REALM_APP_REQUESTS_FREE_TIER" | "REALM_APP_REQUESTS" | "REALM_APP_COMPUTE_FREE_TIER" | "REALM_APP_COMPUTE" | "REALM_APP_SYNC_FREE_TIER" | "REALM_APP_SYNC" | "REALM_APP_DATA_TRANSFER_FREE_TIER" | "REALM_APP_DATA_TRANSFER" | "GCP_SNAPSHOT_COPY_DISK" | "ATLAS_AWS_STREAM_PROCESSING_INSTANCE_SP10" | "ATLAS_AWS_STREAM_PROCESSING_INSTANCE_SP30" | "ATLAS_AWS_STREAM_PROCESSING_INSTANCE_SP50" | "ATLAS_AZURE_STREAM_PROCESSING_INSTANCE_SP10" | "ATLAS_AZURE_STREAM_PROCESSING_INSTANCE_SP30" | "ATLAS_AZURE_STREAM_PROCESSING_INSTANCE_SP50" | "ATLAS_AWS_STREAM_PROCESSING_DATA_TRANSFER" | "ATLAS_AZURE_STREAM_PROCESSING_DATA_TRANSFER" | "ATLAS_AWS_STREAM_PROCESSING_VPC_PEERING" | "ATLAS_AZURE_STREAM_PROCESSING_PRIVATELINK" | "ATLAS_AWS_STREAM_PROCESSING_PRIVATELINK" | "ATLAS_FLEX_AWS_100_USAGE_HOURS" | "ATLAS_FLEX_AWS_200_USAGE_HOURS" | "ATLAS_FLEX_AWS_300_USAGE_HOURS" | "ATLAS_FLEX_AWS_400_USAGE_HOURS" | "ATLAS_FLEX_AWS_500_USAGE_HOURS" | "ATLAS_FLEX_AZURE_100_USAGE_HOURS" | "ATLAS_FLEX_AZURE_200_USAGE_HOURS" | "ATLAS_FLEX_AZURE_300_USAGE_HOURS" | "ATLAS_FLEX_AZURE_400_USAGE_HOURS" | "ATLAS_FLEX_AZURE_500_USAGE_HOURS" | "ATLAS_FLEX_GCP_100_USAGE_HOURS" | "ATLAS_FLEX_GCP_200_USAGE_HOURS" | "ATLAS_FLEX_GCP_300_USAGE_HOURS" | "ATLAS_FLEX_GCP_400_USAGE_HOURS" | "ATLAS_FLEX_GCP_500_USAGE_HOURS" | "ATLAS_FLEX_AWS_LEGACY_100_USAGE_HOURS" | "ATLAS_FLEX_AWS_LEGACY_200_USAGE_HOURS" | "ATLAS_FLEX_AWS_LEGACY_300_USAGE_HOURS" | "ATLAS_FLEX_AWS_LEGACY_400_USAGE_HOURS" | "ATLAS_FLEX_AWS_LEGACY_500_USAGE_HOURS" | "ATLAS_FLEX_AZURE_LEGACY_100_USAGE_HOURS" | "ATLAS_FLEX_AZURE_LEGACY_200_USAGE_HOURS" | "ATLAS_FLEX_AZURE_LEGACY_300_USAGE_HOURS" | "ATLAS_FLEX_AZURE_LEGACY_400_USAGE_HOURS" | "ATLAS_FLEX_AZURE_LEGACY_500_USAGE_HOURS" | "ATLAS_FLEX_GCP_LEGACY_100_USAGE_HOURS" | "ATLAS_FLEX_GCP_LEGACY_200_USAGE_HOURS" | "ATLAS_FLEX_GCP_LEGACY_300_USAGE_HOURS" | "ATLAS_FLEX_GCP_LEGACY_400_USAGE_HOURS" | "ATLAS_FLEX_GCP_LEGACY_500_USAGE_HOURS";
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud began charging for this line item. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly startDate?: string;
            /** @description Human-readable label that identifies the Atlas App Services application associated with this line item. */
            readonly stitchAppName?: string;
            /** @description A map of key-value pairs corresponding to the tags associated with the line item resource. */
            readonly tags?: {
                [key: string]: string[];
            };
            /**
             * Format: double
             * @description Lower bound for usage amount range in current SKU tier.
             *
             *     **NOTE**: **lineItems[n].tierLowerBound** appears only if your **lineItems[n].sku** is tiered.
             */
            readonly tierLowerBound?: number;
            /**
             * Format: double
             * @description Upper bound for usage amount range in current SKU tier.
             *
             *     **NOTE**: **lineItems[n].tierUpperBound** appears only if your **lineItems[n].sku** is tiered.
             */
            readonly tierUpperBound?: number;
            /**
             * Format: int64
             * @description Sum of the cost set for this line item. MongoDB Cloud expresses this value in cents (100ths of one US Dollar) and calculates this value as **unitPriceDollars**  **quantity**  100.
             */
            readonly totalPriceCents?: number;
            /** @description Element used to express what **quantity** this line item measures. This value can be elements of time, storage capacity, and the like. */
            readonly unit?: string;
            /**
             * Format: double
             * @description Value per **unit** for this line item expressed in US Dollars.
             */
            readonly unitPriceDollars?: number;
        };
        Link: {
            /**
             * @description Uniform Resource Locator (URL) that points another API resource to which this response has some relationship. This URL often begins with `https://cloud.mongodb.com/api/atlas`.
             * @example https://cloud.mongodb.com/api/atlas
             */
            href?: string;
            /**
             * @description Uniform Resource Locator (URL) that defines the semantic relationship between this resource and another API resource. This URL often begins with `https://cloud.mongodb.com/api/atlas`.
             * @example self
             */
            rel?: string;
        };
        MonthlyScheduleView: Omit<WithRequired<components["schemas"]["OnlineArchiveSchedule"], "type">, "type"> & {
            /**
             * Format: int32
             * @description Day of the month when the scheduled archive starts.
             */
            dayOfMonth?: number;
            /**
             * Format: int32
             * @description Hour of the day when the scheduled window to run one online archive ends.
             */
            endHour?: number;
            /**
             * Format: int32
             * @description Minute of the hour when the scheduled window to run one online archive ends.
             */
            endMinute?: number;
            /**
             * Format: int32
             * @description Hour of the day when the when the scheduled window to run one online archive starts.
             */
            startHour?: number;
            /**
             * Format: int32
             * @description Minute of the hour when the scheduled window to run one online archive starts.
             */
            startMinute?: number;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "MONTHLY";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "MONTHLY";
        };
        NetworkPermissionEntry: {
            /** @description Unique string of the Amazon Web Services (AWS) security group that you want to add to the project's IP access list. Your IP access list entry can be one **awsSecurityGroup**, one **cidrBlock**, or one **ipAddress**. You must configure Virtual Private Connection (VPC) peering for your project before you can add an AWS security group to an IP access list. You cannot set AWS security groups as temporary access list entries. Don't set this parameter if you set **cidrBlock** or **ipAddress**. */
            awsSecurityGroup?: string;
            /** @description Range of IP addresses in Classless Inter-Domain Routing (CIDR) notation that you want to add to the project's IP access list. Your IP access list entry can be one **awsSecurityGroup**, one **cidrBlock**, or one **ipAddress**. Don't set this parameter if you set **awsSecurityGroup** or **ipAddress**. */
            cidrBlock?: string;
            /** @description Remark that explains the purpose or scope of this IP access list entry. */
            comment?: string;
            /**
             * Format: date-time
             * @description Date and time after which MongoDB Cloud deletes the temporary access list entry. This parameter expresses its value in the ISO 8601 timestamp format in UTC and can include the time zone designation. The date must be later than the current date but no later than one week after you submit this request. The resource returns this parameter if you specified an expiration date when creating this IP access list entry.
             */
            deleteAfterDate?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies the project that contains the IP access list to which you want to add one or more entries.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly groupId?: string;
            /** @description IP address that you want to add to the project's IP access list. Your IP access list entry can be one **awsSecurityGroup**, one **cidrBlock**, or one **ipAddress**. Don't set this parameter if you set **awsSecurityGroup** or **cidrBlock**. */
            ipAddress?: string;
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
        };
        NumberMetricAlertView: {
            /**
             * Format: date-time
             * @description Date and time until which this alert has been acknowledged. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter if a MongoDB User previously acknowledged this alert.
             *
             *     - To acknowledge this alert forever, set the parameter value to 100 years in the future.
             *
             *     - To unacknowledge a previously acknowledged alert, do not set this parameter value.
             */
            acknowledgedUntil?: string;
            /**
             * @description Comment that a MongoDB Cloud user submitted when acknowledging the alert.
             * @example Expiration on 3/19.  Silencing for 7days.
             */
            acknowledgementComment?: string;
            /**
             * Format: email
             * @description MongoDB Cloud username of the person who acknowledged the alert. The response returns this parameter if a MongoDB Cloud user previously acknowledged this alert.
             */
            readonly acknowledgingUsername?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies the alert configuration that sets this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly alertConfigId: string;
            /**
             * @description Human-readable label that identifies the cluster to which this alert applies. This resource returns this parameter for alerts of events impacting backups, replica sets, or sharded clusters.
             * @example cluster1
             */
            readonly clusterName?: string;
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud created this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly created: string;
            currentValue?: components["schemas"]["NumberMetricValueView"];
            eventTypeName: components["schemas"]["HostMetricEventTypeViewAlertable"];
            /**
             * @description Unique 24-hexadecimal digit string that identifies the project that owns this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly groupId?: string;
            /**
             * @description Hostname and port of the host to which this alert applies. The resource returns this parameter for alerts of events impacting hosts or replica sets.
             * @example cloud-test.mongodb.com:27017
             */
            readonly hostnameAndPort?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly id: string;
            /**
             * Format: date-time
             * @description Date and time that any notifications were last sent for this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter if MongoDB Cloud has sent notifications for this alert.
             */
            readonly lastNotified?: string;
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /**
             * @description Name of the metric against which Atlas checks the configured `metricThreshold.threshold`.
             *
             *     To learn more about the available metrics, see <a href="https://www.mongodb.com/docs/atlas/reference/alert-host-metrics/#std-label-measurement-types" target="_blank">Host Metrics</a>.
             *
             *     **NOTE**: If you set eventTypeName to OUTSIDE_SERVERLESS_METRIC_THRESHOLD, you can specify only metrics available for serverless. To learn more, see <a href="https://dochub.mongodb.org/core/alert-config-serverless-measurements" target="_blank">Serverless Measurements</a>.
             * @example ASSERT_USER
             */
            readonly metricName?: string;
            /**
             * @description Unique 24-hexadecimal character string that identifies the organization that owns the project to which this alert applies.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly orgId?: string;
            /**
             * @description Name of the replica set to which this alert applies. The response returns this parameter for alerts of events impacting backups, hosts, or replica sets.
             * @example event-replica-set
             */
            readonly replicaSetName?: string;
            /**
             * Format: date-time
             * @description Date and time that this alert changed to `"status" : "CLOSED"`. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter once `"status" : "CLOSED"`.
             */
            readonly resolved?: string;
            /**
             * @description State of this alert at the time you requested its details.
             * @example OPEN
             * @enum {string}
             */
            readonly status: "CANCELLED" | "CLOSED" | "OPEN" | "TRACKING";
            /**
             * Format: date-time
             * @description Date and time when someone last updated this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly updated: string;
        };
        /**
         * Number Metric Units
         * @description Element used to express the quantity. This can be an element of time, storage capacity, and the like.
         * @example COUNT
         * @enum {string}
         */
        NumberMetricUnits: "COUNT" | "THOUSAND" | "MILLION" | "BILLION";
        /**
         * Number Metric Value
         * @description Measurement of the **metricName** recorded at the time of the event.
         */
        NumberMetricValueView: {
            /**
             * Format: double
             * @description Amount of the **metricName** recorded at the time of the event. This value triggered the alert.
             */
            readonly number?: number;
            units?: components["schemas"]["NumberMetricUnits"];
        };
        /**
         * On-Demand Cloud Provider Snapshot Source
         * @description On-Demand Cloud Provider Snapshots as Source for a Data Lake Pipeline.
         */
        OnDemandCpsSnapshotSource: Omit<components["schemas"]["IngestionSource"], "type"> & {
            /** @description Human-readable name that identifies the cluster. */
            clusterName?: string;
            /** @description Human-readable name that identifies the collection. */
            collectionName?: string;
            /** @description Human-readable name that identifies the database. */
            databaseName?: string;
            /**
             * @description Unique 24-hexadecimal character string that identifies the project.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly groupId?: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "ON_DEMAND_CPS";
        };
        /**
         * Online Archive Schedule
         * @description Regular frequency and duration when archiving process occurs.
         */
        OnlineArchiveSchedule: {
            /**
             * @description Type of schedule.
             * @enum {string}
             */
            type: "DEFAULT" | "DAILY" | "WEEKLY" | "MONTHLY";
        } & (components["schemas"]["DefaultScheduleView"] | components["schemas"]["DailyScheduleView"] | components["schemas"]["WeeklyScheduleView"] | components["schemas"]["MonthlyScheduleView"]);
        OrgActiveUserResponse: Omit<WithRequired<components["schemas"]["OrgUserResponse"], "id" | "orgMembershipStatus" | "roles" | "username">, "orgMembershipStatus"> & {
            /**
             * @description Two-character alphabetical string that identifies the MongoDB Cloud user's geographic location. This parameter uses the ISO 3166-1a2 code format.
             * @example US
             */
            readonly country?: string;
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud created the current account. This value is in the ISO 8601 timestamp format in UTC.
             */
            readonly createdAt: string;
            /**
             * @description First or given name that belongs to the MongoDB Cloud user.
             * @example John
             */
            readonly firstName: string;
            /**
             * Format: date-time
             * @description Date and time when the current account last authenticated. This value is in the ISO 8601 timestamp format in UTC.
             */
            readonly lastAuth?: string;
            /**
             * @description Last name, family name, or surname that belongs to the MongoDB Cloud user.
             * @example Doe
             */
            readonly lastName: string;
            /** @description Mobile phone number that belongs to the MongoDB Cloud user. */
            readonly mobileNumber?: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            orgMembershipStatus: "ACTIVE";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            orgMembershipStatus: "ACTIVE";
        };
        OrgGroup: {
            /** @description Settings that describe the clusters in each project that the API key is authorized to view. */
            readonly clusters?: components["schemas"]["CloudCluster"][];
            /** @description Unique 24-hexadecimal character string that identifies the project. */
            readonly groupId?: string;
            /** @description Human-readable label that identifies the project. */
            groupName?: string;
            /** @description Unique 24-hexadecimal character string that identifies the organization that contains the project. */
            readonly orgId?: string;
            /** @description Human-readable label that identifies the organization that contains the project. */
            orgName?: string;
            /** @description Human-readable label that indicates the plan type. */
            readonly planType?: string;
            /** @description List of human-readable labels that categorize the specified project. MongoDB Cloud returns an empty array. */
            readonly tags?: string[];
        };
        OrgPendingUserResponse: Omit<WithRequired<components["schemas"]["OrgUserResponse"], "id" | "orgMembershipStatus" | "roles" | "username">, "orgMembershipStatus"> & {
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud sent the invitation. MongoDB Cloud represents this timestamp in ISO 8601 format in UTC.
             */
            readonly invitationCreatedAt: string;
            /**
             * Format: date-time
             * @description Date and time when the invitation from MongoDB Cloud expires. MongoDB Cloud represents this timestamp in ISO 8601 format in UTC.
             */
            readonly invitationExpiresAt: string;
            /**
             * Format: email
             * @description Username of the MongoDB Cloud user who sent the invitation to join the organization.
             */
            readonly inviterUsername: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            orgMembershipStatus: "PENDING";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            orgMembershipStatus: "PENDING";
        };
        OrgUserResponse: {
            /**
             * @description Unique 24-hexadecimal digit string that identifies the MongoDB Cloud user.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly id: string;
            /**
             * @description String enum that indicates whether the MongoDB Cloud user has a pending invitation to join the organization or they are already active in the organization.
             * @enum {string}
             */
            readonly orgMembershipStatus: "PENDING" | "ACTIVE";
            roles: components["schemas"]["OrgUserRolesResponse"];
            /** @description List of unique 24-hexadecimal digit strings that identifies the teams to which this MongoDB Cloud user belongs. */
            readonly teamIds?: string[];
            /**
             * Format: email
             * @description Email address that represents the username of the MongoDB Cloud user.
             */
            readonly username: string;
        } & (components["schemas"]["OrgPendingUserResponse"] | components["schemas"]["OrgActiveUserResponse"]);
        /** @description Organization- and project-level roles assigned to one MongoDB Cloud user within one organization. */
        OrgUserRolesResponse: {
            /** @description List of project-level role assignments assigned to the MongoDB Cloud user. */
            groupRoleAssignments?: components["schemas"]["GroupRoleAssignment"][];
            /** @description One or more organization-level roles assigned to the MongoDB Cloud user. */
            orgRoles?: ("ORG_OWNER" | "ORG_GROUP_CREATOR" | "ORG_BILLING_ADMIN" | "ORG_BILLING_READ_ONLY" | "ORG_READ_ONLY" | "ORG_MEMBER")[];
        };
        PaginatedAlertView: {
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /** @description List of returned documents that MongoDB Cloud provides when completing this request. */
            readonly results?: components["schemas"]["AlertViewForNdsGroup"][];
            /**
             * Format: int32
             * @description Total number of documents available. MongoDB Cloud omits this value if `includeCount` is set to `false`. The total number is an estimate and may not be exact.
             */
            readonly totalCount?: number;
        };
        /** @description List of MongoDB Database users granted access to databases in the specified project. */
        PaginatedApiAtlasDatabaseUserView: {
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /** @description List of returned documents that MongoDB Cloud provides when completing this request. */
            readonly results?: components["schemas"]["CloudDatabaseUser"][];
            /**
             * Format: int32
             * @description Total number of documents available. MongoDB Cloud omits this value if `includeCount` is set to `false`. The total number is an estimate and may not be exact.
             */
            readonly totalCount?: number;
        };
        PaginatedAtlasGroupView: {
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /** @description List of returned documents that MongoDB Cloud provides when completing this request. */
            readonly results?: components["schemas"]["Group"][];
            /**
             * Format: int32
             * @description Total number of documents available. MongoDB Cloud omits this value if `includeCount` is set to `false`. The total number is an estimate and may not be exact.
             */
            readonly totalCount?: number;
        };
        PaginatedClusterDescription20240805: {
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /** @description List of returned documents that MongoDB Cloud provides when completing this request. */
            readonly results?: components["schemas"]["ClusterDescription20240805"][];
            /**
             * Format: int32
             * @description Total number of documents available. MongoDB Cloud omits this value if `includeCount` is set to `false`. The total number is an estimate and may not be exact.
             */
            readonly totalCount?: number;
        };
        PaginatedFlexClusters20241113: {
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /** @description List of returned documents that MongoDB Cloud provides when completing this request. */
            readonly results?: components["schemas"]["FlexClusterDescription20241113"][];
            /**
             * Format: int32
             * @description Total number of documents available. MongoDB Cloud omits this value if `includeCount` is set to `false`. The total number is an estimate and may not be exact.
             */
            readonly totalCount?: number;
        };
        PaginatedNetworkAccessView: {
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /** @description List of returned documents that MongoDB Cloud provides when completing this request. */
            readonly results?: components["schemas"]["NetworkPermissionEntry"][];
            /**
             * Format: int32
             * @description Total number of documents available. MongoDB Cloud omits this value if `includeCount` is set to `false`. The total number is an estimate and may not be exact.
             */
            readonly totalCount?: number;
        };
        PaginatedOrgGroupView: {
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /** @description List of returned documents that MongoDB Cloud provides when completing this request. */
            readonly results?: components["schemas"]["OrgGroup"][];
            /**
             * Format: int32
             * @description Total number of documents available. MongoDB Cloud omits this value if `includeCount` is set to `false`. The total number is an estimate and may not be exact.
             */
            readonly totalCount?: number;
        };
        PaginatedOrganizationView: {
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /** @description List of returned documents that MongoDB Cloud provides when completing this request. */
            readonly results?: components["schemas"]["AtlasOrganization"][];
            /**
             * Format: int32
             * @description Total number of documents available. MongoDB Cloud omits this value if `includeCount` is set to `false`. The total number is an estimate and may not be exact.
             */
            readonly totalCount?: number;
        };
        /**
         * Periodic Cloud Provider Snapshot Source
         * @description Scheduled Cloud Provider Snapshot as Source for a Data Lake Pipeline.
         */
        PeriodicCpsSnapshotSource: Omit<components["schemas"]["IngestionSource"], "type"> & {
            /** @description Human-readable name that identifies the cluster. */
            clusterName?: string;
            /** @description Human-readable name that identifies the collection. */
            collectionName?: string;
            /** @description Human-readable name that identifies the database. */
            databaseName?: string;
            /**
             * @description Unique 24-hexadecimal character string that identifies the project.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly groupId?: string;
            /**
             * @description Unique 24-hexadecimal character string that identifies a policy item.
             * @example 32b6e34b3d91647abb20e7b8
             */
            policyItemId?: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "PERIODIC_CPS";
        };
        RawMetricAlertView: {
            /**
             * Format: date-time
             * @description Date and time until which this alert has been acknowledged. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter if a MongoDB User previously acknowledged this alert.
             *
             *     - To acknowledge this alert forever, set the parameter value to 100 years in the future.
             *
             *     - To unacknowledge a previously acknowledged alert, do not set this parameter value.
             */
            acknowledgedUntil?: string;
            /**
             * @description Comment that a MongoDB Cloud user submitted when acknowledging the alert.
             * @example Expiration on 3/19.  Silencing for 7days.
             */
            acknowledgementComment?: string;
            /**
             * Format: email
             * @description MongoDB Cloud username of the person who acknowledged the alert. The response returns this parameter if a MongoDB Cloud user previously acknowledged this alert.
             */
            readonly acknowledgingUsername?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies the alert configuration that sets this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly alertConfigId: string;
            /**
             * @description Human-readable label that identifies the cluster to which this alert applies. This resource returns this parameter for alerts of events impacting backups, replica sets, or sharded clusters.
             * @example cluster1
             */
            readonly clusterName?: string;
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud created this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly created: string;
            currentValue?: components["schemas"]["RawMetricValueView"];
            eventTypeName: components["schemas"]["HostMetricEventTypeViewAlertable"];
            /**
             * @description Unique 24-hexadecimal digit string that identifies the project that owns this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly groupId?: string;
            /**
             * @description Hostname and port of the host to which this alert applies. The resource returns this parameter for alerts of events impacting hosts or replica sets.
             * @example cloud-test.mongodb.com:27017
             */
            readonly hostnameAndPort?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly id: string;
            /**
             * Format: date-time
             * @description Date and time that any notifications were last sent for this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter if MongoDB Cloud has sent notifications for this alert.
             */
            readonly lastNotified?: string;
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /**
             * @description Name of the metric against which Atlas checks the configured `metricThreshold.threshold`.
             *
             *     To learn more about the available metrics, see <a href="https://www.mongodb.com/docs/atlas/reference/alert-host-metrics/#std-label-measurement-types" target="_blank">Host Metrics</a>.
             *
             *     **NOTE**: If you set eventTypeName to OUTSIDE_SERVERLESS_METRIC_THRESHOLD, you can specify only metrics available for serverless. To learn more, see <a href="https://dochub.mongodb.org/core/alert-config-serverless-measurements" target="_blank">Serverless Measurements</a>.
             * @example ASSERT_USER
             */
            readonly metricName?: string;
            /**
             * @description Unique 24-hexadecimal character string that identifies the organization that owns the project to which this alert applies.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly orgId?: string;
            /**
             * @description Name of the replica set to which this alert applies. The response returns this parameter for alerts of events impacting backups, hosts, or replica sets.
             * @example event-replica-set
             */
            readonly replicaSetName?: string;
            /**
             * Format: date-time
             * @description Date and time that this alert changed to `"status" : "CLOSED"`. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter once `"status" : "CLOSED"`.
             */
            readonly resolved?: string;
            /**
             * @description State of this alert at the time you requested its details.
             * @example OPEN
             * @enum {string}
             */
            readonly status: "CANCELLED" | "CLOSED" | "OPEN" | "TRACKING";
            /**
             * Format: date-time
             * @description Date and time when someone last updated this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly updated: string;
        };
        /**
         * Raw Metric Units
         * @description Element used to express the quantity. This can be an element of time, storage capacity, and the like.
         * @default RAW
         * @enum {string}
         */
        RawMetricUnits: "RAW";
        /**
         * Raw Metric Value
         * @description Measurement of the **metricName** recorded at the time of the event.
         */
        RawMetricValueView: {
            /**
             * Format: double
             * @description Amount of the **metricName** recorded at the time of the event. This value triggered the alert.
             */
            readonly number?: number;
            units?: components["schemas"]["RawMetricUnits"];
        };
        /**
         * ReplicaSet Alerts
         * @description ReplicaSet alert notifies about different activities on replica set of mongod instances.
         */
        ReplicaSetAlertViewForNdsGroup: {
            /**
             * Format: date-time
             * @description Date and time until which this alert has been acknowledged. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter if a MongoDB User previously acknowledged this alert.
             *
             *     - To acknowledge this alert forever, set the parameter value to 100 years in the future.
             *
             *     - To unacknowledge a previously acknowledged alert, do not set this parameter value.
             */
            acknowledgedUntil?: string;
            /**
             * @description Comment that a MongoDB Cloud user submitted when acknowledging the alert.
             * @example Expiration on 3/19.  Silencing for 7days.
             */
            acknowledgementComment?: string;
            /**
             * Format: email
             * @description MongoDB Cloud username of the person who acknowledged the alert. The response returns this parameter if a MongoDB Cloud user previously acknowledged this alert.
             */
            readonly acknowledgingUsername?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies the alert configuration that sets this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly alertConfigId: string;
            /**
             * @description Human-readable label that identifies the cluster to which this alert applies. This resource returns this parameter for alerts of events impacting backups, replica sets, or sharded clusters.
             * @example cluster1
             */
            readonly clusterName?: string;
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud created this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly created: string;
            eventTypeName: components["schemas"]["ReplicaSetEventTypeViewForNdsGroupAlertable"];
            /**
             * @description Unique 24-hexadecimal digit string that identifies the project that owns this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly groupId?: string;
            /**
             * @description Hostname and port of the host to which this alert applies. The resource returns this parameter for alerts of events impacting hosts or replica sets.
             * @example cloud-test.mongodb.com:27017
             */
            readonly hostnameAndPort?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly id: string;
            /**
             * Format: date-time
             * @description Date and time that any notifications were last sent for this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter if MongoDB Cloud has sent notifications for this alert.
             */
            readonly lastNotified?: string;
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /** @description List of unique 24-hexadecimal character strings that identify the replica set members that are not in PRIMARY nor SECONDARY state. */
            readonly nonRunningHostIds?: string[];
            /**
             * @description Unique 24-hexadecimal character string that identifies the organization that owns the project to which this alert applies.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly orgId?: string;
            /**
             * @description Unique 24-hexadecimal character string that identifies the parent cluster to which this alert applies. The parent cluster contains the sharded nodes. MongoDB Cloud returns this parameter only for alerts of events impacting sharded clusters.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly parentClusterId?: string;
            /**
             * @description Name of the replica set to which this alert applies. The response returns this parameter for alerts of events impacting backups, hosts, or replica sets.
             * @example event-replica-set
             */
            readonly replicaSetName?: string;
            /**
             * Format: date-time
             * @description Date and time that this alert changed to `"status" : "CLOSED"`. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter once `"status" : "CLOSED"`.
             */
            readonly resolved?: string;
            /**
             * @description State of this alert at the time you requested its details.
             * @example OPEN
             * @enum {string}
             */
            readonly status: "CANCELLED" | "CLOSED" | "OPEN" | "TRACKING";
            /**
             * Format: date-time
             * @description Date and time when someone last updated this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly updated: string;
        };
        /**
         * ReplicaSet Event Types
         * @description Incident that triggered this alert.
         * @example NO_PRIMARY
         * @enum {string}
         */
        ReplicaSetEventTypeViewForNdsGroupAlertable: "REPLICATION_OPLOG_WINDOW_RUNNING_OUT" | "NO_PRIMARY" | "PRIMARY_ELECTED" | "TOO_MANY_ELECTIONS" | "TOO_FEW_HEALTHY_MEMBERS" | "TOO_MANY_UNHEALTHY_MEMBERS";
        /**
         * Replication Specifications
         * @description Details that explain how MongoDB Cloud replicates data on the specified MongoDB database.
         */
        ReplicationSpec20240805: {
            /**
             * @description Unique 24-hexadecimal digit string that identifies the replication object for a shard in a Cluster. If you include existing shard replication configurations in the request, you must specify this parameter. If you add a new shard to an existing Cluster, you may specify this parameter. The request deletes any existing shards  in the Cluster that you exclude from the request. This corresponds to Shard ID displayed in the UI.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly id?: string;
            /** @description Hardware specifications for nodes set for a given region. Each **regionConfigs** object describes the region's priority in elections and the number and type of MongoDB nodes that MongoDB Cloud deploys to the region. Each **regionConfigs** object must have either an **analyticsSpecs** object, **electableSpecs** object, or **readOnlySpecs** object. Tenant clusters only require **electableSpecs. Dedicated** clusters can specify any of these specifications, but must have at least one **electableSpecs** object within a **replicationSpec**.
             *
             *     **Example:**
             *
             *     If you set `"replicationSpecs[n].regionConfigs[m].analyticsSpecs.instanceSize" : "M30"`, set `"replicationSpecs[n].regionConfigs[m].electableSpecs.instanceSize" : `"M30"` if you have electable nodes and `"replicationSpecs[n].regionConfigs[m].readOnlySpecs.instanceSize" : `"M30"` if you have read-only nodes. */
            regionConfigs?: components["schemas"]["CloudRegionConfig20240805"][];
            /**
             * @description Unique 24-hexadecimal digit string that identifies the zone in a Global Cluster. This value can be used to configure Global Cluster backup policies.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly zoneId?: string;
            /** @description Human-readable label that describes the zone this shard belongs to in a Global Cluster. Provide this value only if "clusterType" : "GEOSHARDED" but not "selfManagedSharding" : true. */
            zoneName?: string;
        };
        /**
         * Resource Tag
         * @description Key-value pair that tags and categorizes a MongoDB Cloud organization, project, or cluster. For example, `environment : production`.
         */
        ResourceTag: {
            /** @description Constant that defines the set of the tag. For example, `environment` in the `environment : production` tag. */
            key: string;
            /** @description Variable that belongs to the set of the tag. For example, `production` in the `environment : production` tag. */
            value: string;
        };
        /** Search Host Status Detail */
        SearchHostStatusDetail: {
            /** @description Hostname that corresponds to the status detail. */
            hostname?: string;
            mainIndex?: components["schemas"]["SearchMainIndexStatusDetail"];
            /** @description Flag that indicates whether the index is queryable on the host. */
            queryable?: boolean;
            stagedIndex?: components["schemas"]["SearchStagedIndexStatusDetail"];
            /**
             * @description Condition of the search index when you made this request.
             *
             *     - `DELETING`: The index is being deleted.
             *     - `FAILED` The index build failed. Indexes can enter the FAILED state due to an invalid index definition.
             *     - `STALE`: The index is queryable but has stopped replicating data from the indexed collection. Searches on the index may return out-of-date data.
             *     - `PENDING`: Atlas has not yet started building the index.
             *     - `BUILDING`: Atlas is building or re-building the index after an edit.
             *     - `READY`: The index is ready and can support queries.
             * @enum {string}
             */
            status?: "DELETING" | "FAILED" | "STALE" | "PENDING" | "BUILDING" | "READY" | "DOES_NOT_EXIST";
        };
        SearchIndex: Omit<WithRequired<components["schemas"]["ClusterSearchIndex"], "collectionName" | "database" | "name">, "type"> & {
            /**
             * @description Specific pre-defined method chosen to convert database field text into searchable words. This conversion reduces the text of fields into the smallest units of text. These units are called a **term** or **token**. This process, known as tokenization, involves a variety of changes made to the text in fields:
             *
             *     - extracting words
             *     - removing punctuation
             *     - removing accents
             *     - changing to lowercase
             *     - removing common words
             *     - reducing words to their root form (stemming)
             *     - changing words to their base form (lemmatization)
             *      MongoDB Cloud uses the selected process to build the Atlas Search index.
             * @default lucene.standard
             * @enum {string}
             */
            analyzer: "lucene.standard" | "lucene.simple" | "lucene.whitespace" | "lucene.keyword" | "lucene.arabic" | "lucene.armenian" | "lucene.basque" | "lucene.bengali" | "lucene.brazilian" | "lucene.bulgarian" | "lucene.catalan" | "lucene.chinese" | "lucene.cjk" | "lucene.czech" | "lucene.danish" | "lucene.dutch" | "lucene.english" | "lucene.finnish" | "lucene.french" | "lucene.galician" | "lucene.german" | "lucene.greek" | "lucene.hindi" | "lucene.hungarian" | "lucene.indonesian" | "lucene.irish" | "lucene.italian" | "lucene.japanese" | "lucene.korean" | "lucene.kuromoji" | "lucene.latvian" | "lucene.lithuanian" | "lucene.morfologik" | "lucene.nori" | "lucene.norwegian" | "lucene.persian" | "lucene.portuguese" | "lucene.romanian" | "lucene.russian" | "lucene.smartcn" | "lucene.sorani" | "lucene.spanish" | "lucene.swedish" | "lucene.thai" | "lucene.turkish" | "lucene.ukrainian";
            /** @description List of user-defined methods to convert database field text into searchable words. */
            analyzers?: components["schemas"]["ApiAtlasFTSAnalyzersViewManual"][];
            mappings?: components["schemas"]["ApiAtlasFTSMappingsViewManual"];
            /**
             * @description Method applied to identify words when searching this index.
             * @default lucene.standard
             * @enum {string}
             */
            searchAnalyzer: "lucene.standard" | "lucene.simple" | "lucene.whitespace" | "lucene.keyword" | "lucene.arabic" | "lucene.armenian" | "lucene.basque" | "lucene.bengali" | "lucene.brazilian" | "lucene.bulgarian" | "lucene.catalan" | "lucene.chinese" | "lucene.cjk" | "lucene.czech" | "lucene.danish" | "lucene.dutch" | "lucene.english" | "lucene.finnish" | "lucene.french" | "lucene.galician" | "lucene.german" | "lucene.greek" | "lucene.hindi" | "lucene.hungarian" | "lucene.indonesian" | "lucene.irish" | "lucene.italian" | "lucene.japanese" | "lucene.korean" | "lucene.kuromoji" | "lucene.latvian" | "lucene.lithuanian" | "lucene.morfologik" | "lucene.nori" | "lucene.norwegian" | "lucene.persian" | "lucene.portuguese" | "lucene.romanian" | "lucene.russian" | "lucene.smartcn" | "lucene.sorani" | "lucene.spanish" | "lucene.swedish" | "lucene.thai" | "lucene.turkish" | "lucene.ukrainian";
            /**
             * @description Flag that indicates whether to store all fields (true) on Atlas Search. By default, Atlas doesn't store (false) the fields on Atlas Search.  Alternatively, you can specify an object that only contains the list of fields to store (include) or not store (exclude) on Atlas Search. To learn more, see documentation.
             * @example {
             *       "include | exclude": [
             *         "field1",
             *         "field2"
             *       ]
             *     }
             */
            storedSource?: Record<string, never>;
            /** @description Rule sets that map words to their synonyms in this index. */
            synonyms?: components["schemas"]["SearchSynonymMappingDefinition"][];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "search";
        };
        SearchIndexCreateRequest: {
            /** @description Label that identifies the collection to create an Atlas Search index in. */
            collectionName: string;
            /** @description Label that identifies the database that contains the collection to create an Atlas Search index in. */
            database: string;
            /** @description Label that identifies this index. Within each namespace, names of all indexes in the namespace must be unique. */
            name: string;
            /**
             * @description Type of the index. The default type is search.
             * @enum {string}
             */
            type?: "search" | "vectorSearch";
        };
        /**
         * Search Index Definition
         * @description The search index definition set by the user.
         */
        SearchIndexDefinition: {
            /**
             * Format: int32
             * @description Number of index partitions. Allowed values are [1, 2, 4].
             * @default 1
             */
            numPartitions: number;
        };
        /**
         * Search Index Definition Version
         * @description Object which includes the version number of the index definition and the time that the index definition was created.
         */
        SearchIndexDefinitionVersion: {
            /**
             * Format: date-time
             * @description The time at which this index definition was created. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            createdAt?: string;
            /**
             * Format: int64
             * @description The version number associated with this index definition when it was created.
             */
            version?: number;
        };
        /** Search Index Response */
        SearchIndexResponse: {
            /** @description Label that identifies the collection that contains one or more Atlas Search indexes. */
            collectionName?: string;
            /** @description Label that identifies the database that contains the collection with one or more Atlas Search indexes. */
            database?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies this Atlas Search index.
             * @example 32b6e34b3d91647abb20e7b8
             */
            indexID?: string;
            latestDefinition?: components["schemas"]["SearchIndexDefinition"];
            latestDefinitionVersion?: components["schemas"]["SearchIndexDefinitionVersion"];
            /** @description Label that identifies this index. Within each namespace, the names of all indexes must be unique. */
            name?: string;
            /** @description Flag that indicates whether the index is queryable on all hosts. */
            queryable?: boolean;
            /**
             * @description Condition of the search index when you made this request.
             *
             *     - `DELETING`: The index is being deleted.
             *     - `FAILED` The index build failed. Indexes can enter the FAILED state due to an invalid index definition.
             *     - `STALE`: The index is queryable but has stopped replicating data from the indexed collection. Searches on the index may return out-of-date data.
             *     - `PENDING`: Atlas has not yet started building the index.
             *     - `BUILDING`: Atlas is building or re-building the index after an edit.
             *     - `READY`: The index is ready and can support queries.
             * @enum {string}
             */
            status?: "DELETING" | "FAILED" | "STALE" | "PENDING" | "BUILDING" | "READY" | "DOES_NOT_EXIST";
            /** @description List of documents detailing index status on each host. */
            statusDetail?: components["schemas"]["SearchHostStatusDetail"][];
            /**
             * @description Type of the index. The default type is search.
             * @enum {string}
             */
            type?: "search" | "vectorSearch";
        };
        /**
         * Search Main Index Status Detail
         * @description Contains status information about the active index.
         */
        SearchMainIndexStatusDetail: {
            definition?: components["schemas"]["SearchIndexDefinition"];
            definitionVersion?: components["schemas"]["SearchIndexDefinitionVersion"];
            /** @description Optional message describing an error. */
            message?: string;
            /** @description Flag that indicates whether the index generation is queryable on the host. */
            queryable?: boolean;
            /**
             * @description Condition of the search index when you made this request.
             *
             *     - `DELETING`: The index is being deleted.
             *     - `FAILED` The index build failed. Indexes can enter the FAILED state due to an invalid index definition.
             *     - `STALE`: The index is queryable but has stopped replicating data from the indexed collection. Searches on the index may return out-of-date data.
             *     - `PENDING`: Atlas has not yet started building the index.
             *     - `BUILDING`: Atlas is building or re-building the index after an edit.
             *     - `READY`: The index is ready and can support queries.
             * @enum {string}
             */
            status?: "DELETING" | "FAILED" | "STALE" | "PENDING" | "BUILDING" | "READY" | "DOES_NOT_EXIST";
        };
        /**
         * Mappings
         * @description Index specifications for the collection's fields.
         */
        SearchMappings: {
            /** @description Flag that indicates whether the index uses dynamic or static mappings. Required if **mappings.fields** is omitted. */
            dynamic?: boolean;
            /** @description One or more field specifications for the Atlas Search index. Required if **mappings.dynamic** is omitted or set to **false**. */
            fields?: {
                [key: string]: components["schemas"]["Fields"];
            };
        };
        /**
         * Search Staged Index Status Detail
         * @description Contains status information about an index building in the background.
         */
        SearchStagedIndexStatusDetail: {
            definition?: components["schemas"]["SearchIndexDefinition"];
            definitionVersion?: components["schemas"]["SearchIndexDefinitionVersion"];
            /** @description Optional message describing an error. */
            message?: string;
            /** @description Flag that indicates whether the index generation is queryable on the host. */
            queryable?: boolean;
            /**
             * @description Condition of the search index when you made this request.
             *
             *     - `DELETING`: The index is being deleted.
             *     - `FAILED` The index build failed. Indexes can enter the FAILED state due to an invalid index definition.
             *     - `STALE`: The index is queryable but has stopped replicating data from the indexed collection. Searches on the index may return out-of-date data.
             *     - `PENDING`: Atlas has not yet started building the index.
             *     - `BUILDING`: Atlas is building or re-building the index after an edit.
             *     - `READY`: The index is ready and can support queries.
             * @enum {string}
             */
            status?: "DELETING" | "FAILED" | "STALE" | "PENDING" | "BUILDING" | "READY" | "DOES_NOT_EXIST";
        };
        /**
         * Synonym Mapping Definition
         * @description Synonyms used for this full text index.
         */
        SearchSynonymMappingDefinition: {
            /**
             * @description Specific pre-defined method chosen to apply to the synonyms to be searched.
             * @enum {string}
             */
            analyzer: "lucene.standard" | "lucene.simple" | "lucene.whitespace" | "lucene.keyword" | "lucene.arabic" | "lucene.armenian" | "lucene.basque" | "lucene.bengali" | "lucene.brazilian" | "lucene.bulgarian" | "lucene.catalan" | "lucene.chinese" | "lucene.cjk" | "lucene.czech" | "lucene.danish" | "lucene.dutch" | "lucene.english" | "lucene.finnish" | "lucene.french" | "lucene.galician" | "lucene.german" | "lucene.greek" | "lucene.hindi" | "lucene.hungarian" | "lucene.indonesian" | "lucene.irish" | "lucene.italian" | "lucene.japanese" | "lucene.korean" | "lucene.kuromoji" | "lucene.latvian" | "lucene.lithuanian" | "lucene.morfologik" | "lucene.nori" | "lucene.norwegian" | "lucene.persian" | "lucene.portuguese" | "lucene.romanian" | "lucene.russian" | "lucene.smartcn" | "lucene.sorani" | "lucene.spanish" | "lucene.swedish" | "lucene.thai" | "lucene.turkish" | "lucene.ukrainian";
            /** @description Label that identifies the synonym definition. Each **synonym.name** must be unique within the same index definition. */
            name: string;
            source: components["schemas"]["SynonymSource"];
        };
        /**
         * AWS
         * @description Updates to a serverless AWS tenant endpoint.
         */
        ServerlessAWSTenantEndpointUpdate: Omit<WithRequired<components["schemas"]["ServerlessTenantEndpointUpdate"], "providerName">, "providerName"> & {
            /** @description Unique string that identifies the private endpoint's network interface. */
            cloudProviderEndpointId?: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "AWS";
        };
        /**
         * AZURE
         * @description Updates to a serverless Azure tenant endpoint.
         */
        ServerlessAzureTenantEndpointUpdate: Omit<WithRequired<components["schemas"]["ServerlessTenantEndpointUpdate"], "providerName">, "providerName"> & {
            /** @description Unique string that identifies the Azure private endpoint's network interface for this private endpoint service. */
            cloudProviderEndpointId?: string;
            /** @description IPv4 address of the private endpoint in your Azure VNet that someone added to this private endpoint service. */
            privateEndpointIpAddress?: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "AZURE";
        };
        /** @description Update view for a serverless tenant endpoint. */
        ServerlessTenantEndpointUpdate: {
            /** @description Human-readable comment associated with the private endpoint. */
            comment?: string;
            /**
             * @description Human-readable label that identifies the cloud provider of the tenant endpoint.
             * @enum {string}
             */
            providerName: "AWS" | "AZURE";
        };
        /**
         * Stream Processor Alerts
         * @description Stream Processor alert notifies about activities on Stream Processor in AtlasStreams.
         */
        StreamProcessorAlertViewForNdsGroup: {
            /**
             * Format: date-time
             * @description Date and time until which this alert has been acknowledged. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter if a MongoDB User previously acknowledged this alert.
             *
             *     - To acknowledge this alert forever, set the parameter value to 100 years in the future.
             *
             *     - To unacknowledge a previously acknowledged alert, do not set this parameter value.
             */
            acknowledgedUntil?: string;
            /**
             * @description Comment that a MongoDB Cloud user submitted when acknowledging the alert.
             * @example Expiration on 3/19.  Silencing for 7days.
             */
            acknowledgementComment?: string;
            /**
             * Format: email
             * @description MongoDB Cloud username of the person who acknowledged the alert. The response returns this parameter if a MongoDB Cloud user previously acknowledged this alert.
             */
            readonly acknowledgingUsername?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies the alert configuration that sets this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly alertConfigId: string;
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud created this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly created: string;
            eventTypeName: components["schemas"]["HostEventTypeViewForNdsGroupAlertable"];
            /**
             * @description Unique 24-hexadecimal digit string that identifies the project that owns this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly groupId?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly id: string;
            /**
             * @description The name of the Stream Processing Instance to which this alert applies. The resource returns this parameter for alerts of events impacting Stream Processing Instances.
             * @example foobar
             */
            readonly instanceName?: string;
            /**
             * Format: date-time
             * @description Date and time that any notifications were last sent for this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter if MongoDB Cloud has sent notifications for this alert.
             */
            readonly lastNotified?: string;
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /**
             * @description Unique 24-hexadecimal character string that identifies the organization that owns the project to which this alert applies.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly orgId?: string;
            /**
             * @description The error message associated with the Stream Processor to which this alert applies.
             * @example MongoServerError: Failed to start stream processor: (Location77175) Could not connect to the Kafka topic with kafka error code: -195, message: Local: Broker transport failure.: (Location77175)
             */
            readonly processorErrorMsg?: string;
            /**
             * @description The name of the Stream Processor to which this alert applies. The resource returns this parameter for alerts of events impacting Stream Processors.
             * @example foobar
             */
            readonly processorName?: string;
            /**
             * @description The state of the Stream Processor to which this alert applies. The resource returns this parameter for alerts of events impacting Stream Processors.
             * @example STARTED
             */
            readonly processorState?: string;
            /**
             * Format: date-time
             * @description Date and time that this alert changed to `"status" : "CLOSED"`. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter once `"status" : "CLOSED"`.
             */
            readonly resolved?: string;
            /**
             * @description State of this alert at the time you requested its details.
             * @example OPEN
             * @enum {string}
             */
            readonly status: "CANCELLED" | "CLOSED" | "OPEN" | "TRACKING";
            /**
             * Format: date-time
             * @description Date and time when someone last updated this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly updated: string;
        };
        /** @description AWS configurations for AWS-based connection types. */
        StreamsAWSConnectionConfig: {
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /** @description Amazon Resource Name (ARN) that identifies the Amazon Web Services (AWS) Identity and Access Management (IAM) role that MongoDB Cloud assumes when it accesses resources in your AWS account. */
            roleArn?: string;
            /** @description The name of an S3 bucket used to check authorization of the passed-in IAM role ARN. */
            testBucket?: string;
        };
        /** @description The configuration for AWS Lambda connections. */
        StreamsAWSLambdaConnection: Omit<components["schemas"]["StreamsConnection"], "type"> & {
            aws?: components["schemas"]["StreamsAWSConnectionConfig"];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "AWSLambda";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "AWSLambda";
        };
        StreamsClusterConnection: Omit<components["schemas"]["StreamsConnection"], "type"> & {
            /** @description Name of the cluster configured for this connection. */
            clusterName?: string;
            dbRoleToExecute?: components["schemas"]["DBRoleToExecute"];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "Cluster";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "Cluster";
        };
        /** @description Settings that define a connection to an external data store. */
        StreamsConnection: {
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /** @description Human-readable label that identifies the stream connection. In the case of the Sample type, this is the name of the sample source. */
            name?: string;
            /**
             * @description Type of the connection.
             * @enum {string}
             */
            type?: "Kafka" | "Cluster" | "Sample" | "Https" | "AWSLambda";
        } & (components["schemas"]["StreamsSampleConnection"] | components["schemas"]["StreamsClusterConnection"] | components["schemas"]["StreamsKafkaConnection"] | components["schemas"]["StreamsHttpsConnection"] | components["schemas"]["StreamsAWSLambdaConnection"] | components["schemas"]["StreamsS3Connection"]);
        StreamsHttpsConnection: Omit<components["schemas"]["StreamsConnection"], "type"> & {
            /** @description A map of key-value pairs that will be passed as headers for the request. */
            headers?: {
                [key: string]: string;
            };
            /** @description The url to be used for the request. */
            url?: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "Https";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "Https";
        };
        /** @description User credentials required to connect to a Kafka Cluster. Includes the authentication type, as well as the parameters for that authentication mode. */
        StreamsKafkaAuthentication: {
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /** @description Style of authentication. Can be one of PLAIN, SCRAM-256, or SCRAM-512. */
            mechanism?: string;
            /**
             * Format: password
             * @description Password of the account to connect to the Kafka cluster.
             */
            password?: string;
            /** @description SSL certificate for client authentication to Kafka. */
            sslCertificate?: string;
            /** @description SSL key for client authentication to Kafka. */
            sslKey?: string;
            /** @description Password for the SSL key, if it is password protected. */
            sslKeyPassword?: string;
            /** @description Username of the account to connect to the Kafka cluster. */
            username?: string;
        };
        StreamsKafkaConnection: Omit<components["schemas"]["StreamsConnection"], "type"> & {
            authentication?: components["schemas"]["StreamsKafkaAuthentication"];
            /** @description Comma separated list of server addresses. */
            bootstrapServers?: string;
            /**
             * @description A map of Kafka key-value pairs for optional configuration. This is a flat object, and keys can have '.' characters.
             * @example {
             *       "debug": "queue, msg, protocol",
             *       "group.protocol.type": "consumer"
             *     }
             */
            config?: {
                [key: string]: string;
            };
            networking?: components["schemas"]["StreamsKafkaNetworking"];
            security?: components["schemas"]["StreamsKafkaSecurity"];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "Kafka";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "Kafka";
        };
        /** @description Networking Access Type can either be 'PUBLIC' (default) or VPC. VPC type is in public preview, please file a support ticket to enable VPC Network Access. */
        StreamsKafkaNetworking: {
            access?: components["schemas"]["StreamsKafkaNetworkingAccess"];
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
        };
        /** @description Information about the networking access. */
        StreamsKafkaNetworkingAccess: {
            /**
             * @description Reserved. Will be used by PRIVATE_LINK connection type.
             * @example 32b6e34b3d91647abb20e7b8
             */
            connectionId?: string;
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /** @description Reserved. Will be used by PRIVATE_LINK connection type. */
            name?: string;
            /** @description Reserved. Will be used by TRANSIT_GATEWAY connection type. */
            tgwId?: string;
            /**
             * Networking Access Type
             * @description Selected networking type. Either PUBLIC, VPC, PRIVATE_LINK, or TRANSIT_GATEWAY. Defaults to PUBLIC. For VPC, ensure that VPC peering exists and connectivity has been established between Atlas VPC and the VPC where Kafka cluster is hosted for the connection to function properly. TRANSIT_GATEWAY support is coming soon.
             * @enum {string}
             */
            type?: "PUBLIC" | "VPC" | "PRIVATE_LINK" | "TRANSIT_GATEWAY";
            /** @description Reserved. Will be used by TRANSIT_GATEWAY connection type. */
            vpcCIDR?: string;
        };
        /** @description Properties for the secure transport connection to Kafka. For SSL, this can include the trusted certificate to use. */
        StreamsKafkaSecurity: {
            /** @description A trusted, public x509 certificate for connecting to Kafka over SSL. */
            brokerPublicCertificate?: string;
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /** @description Describes the transport type. Can be either SASL_PLAINTEXT, SASL_SSL, or SSL. */
            protocol?: string;
        };
        /** @description The configuration for S3 connections. */
        StreamsS3Connection: Omit<components["schemas"]["StreamsConnection"], "type"> & {
            aws?: components["schemas"]["StreamsAWSConnectionConfig"];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "S3";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "S3";
        };
        StreamsSampleConnection: Omit<components["schemas"]["StreamsConnection"], "type"> & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "Sample";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "Sample";
        };
        /**
         * Synonym Mapping Status Detail
         * @description Contains the status of the index's synonym mappings on each search host. This field (and its subfields) only appear if the index has synonyms defined.
         */
        SynonymMappingStatusDetail: {
            /** @description Optional message describing an error. */
            message?: string;
            /** @description Flag that indicates whether the synonym mapping is queryable on a host. */
            queryable?: boolean;
            /**
             * @description Status that describes this index's synonym mappings. This status appears only if the index has synonyms defined.
             * @enum {string}
             */
            status?: "FAILED" | "BUILDING" | "READY";
        };
        SynonymMappingStatusDetailMap: {
            [key: string]: components["schemas"]["SynonymMappingStatusDetail"];
        };
        /** @description Data set that stores words and their applicable synonyms. */
        SynonymSource: {
            /** @description Label that identifies the MongoDB collection that stores words and their applicable synonyms. */
            collection: string;
        };
        TenantHardwareSpec: {
            /**
             * @description The true tenant instance size. This is present to support backwards compatibility for deprecated provider types and/or instance sizes.
             * @enum {string}
             */
            readonly effectiveInstanceSize?: "FLEX" | "M2" | "M5" | "M0";
            /**
             * Tenant Instance Sizes
             * @description Hardware specification for the instances in this M0/M2/M5 tier cluster.
             * @enum {string}
             */
            instanceSize?: "M0" | "M2" | "M5";
        };
        TenantHardwareSpec20240805: {
            /**
             * Format: double
             * @description Storage capacity of instance data volumes expressed in gigabytes. Increase this number to add capacity.
             *
             *      This value must be equal for all shards and node types.
             *
             *      This value is not configurable on M0/M2/M5 clusters.
             *
             *      MongoDB Cloud requires this parameter if you set **replicationSpecs**.
             *
             *      If you specify a disk size below the minimum (10 GB), this parameter defaults to the minimum disk size value.
             *
             *      Storage charge calculations depend on whether you choose the default value or a custom value.
             *
             *      The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
             */
            diskSizeGB?: number;
            /**
             * @description The true tenant instance size. This is present to support backwards compatibility for deprecated provider types and/or instance sizes.
             * @enum {string}
             */
            readonly effectiveInstanceSize?: "FLEX" | "M2" | "M5" | "M0";
            /**
             * Tenant Instance Sizes
             * @description Hardware specification for the instances in this M0/M2/M5 tier cluster.
             * @enum {string}
             */
            instanceSize?: "M0" | "M2" | "M5";
        };
        /**
         * Tenant Regional Replication Specifications
         * @description Details that explain how MongoDB Cloud replicates data in one region on the specified MongoDB database.
         */
        TenantRegionConfig: Omit<components["schemas"]["CloudRegionConfig"], "providerName"> & {
            /**
             * @description Cloud service provider on which MongoDB Cloud provisioned the multi-tenant cluster. The resource returns this parameter when **providerName** is `TENANT` and **electableSpecs.instanceSize** is `M0`, `M2` or `M5`.
             *
             *     Please note that using an instanceSize of M2 or M5 will create a Flex cluster instead. Support for the instanceSize of M2 or M5 will be discontinued in January 2026. We recommend using the createFlexCluster API for such configurations moving forward.
             * @enum {string}
             */
            backingProviderName?: "AWS" | "GCP" | "AZURE";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "TENANT";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "TENANT";
        };
        /**
         * Tenant Regional Replication Specifications
         * @description Details that explain how MongoDB Cloud replicates data in one region on the specified MongoDB database.
         */
        TenantRegionConfig20240805: Omit<components["schemas"]["CloudRegionConfig20240805"], "providerName"> & {
            /**
             * @description Cloud service provider on which MongoDB Cloud provisioned the multi-tenant cluster. The resource returns this parameter when **providerName** is `TENANT` and **electableSpecs.instanceSize** is `M0`, `M2` or `M5`.
             *
             *     Please note that  using an instanceSize of M2 or M5 will create a Flex cluster instead. Support for the instanceSize of M2 or M5 will be discontinued in January 2026. We recommend using the createFlexCluster API for such configurations moving forward.
             * @enum {string}
             */
            backingProviderName?: "AWS" | "GCP" | "AZURE";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "TENANT";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            providerName: "TENANT";
        };
        /** Text Search Host Status Detail */
        TextSearchHostStatusDetail: {
            /** @description Hostname that corresponds to the status detail. */
            hostname?: string;
            mainIndex?: components["schemas"]["TextSearchIndexStatusDetail"];
            /** @description Flag that indicates whether the index is queryable on the host. */
            queryable?: boolean;
            stagedIndex?: components["schemas"]["TextSearchIndexStatusDetail"];
            /**
             * @description Condition of the search index when you made this request.
             *
             *     - `DELETING`: The index is being deleted.
             *     - `FAILED` The index build failed. Indexes can enter the FAILED state due to an invalid index definition.
             *     - `STALE`: The index is queryable but has stopped replicating data from the indexed collection. Searches on the index may return out-of-date data.
             *     - `PENDING`: Atlas has not yet started building the index.
             *     - `BUILDING`: Atlas is building or re-building the index after an edit.
             *     - `READY`: The index is ready and can support queries.
             * @enum {string}
             */
            status?: "DELETING" | "FAILED" | "STALE" | "PENDING" | "BUILDING" | "READY" | "DOES_NOT_EXIST";
        };
        /** @description Text Search Index Create Request */
        TextSearchIndexCreateRequest: Omit<WithRequired<components["schemas"]["SearchIndexCreateRequest"], "collectionName" | "database" | "name">, "type"> & {
            definition: components["schemas"]["TextSearchIndexDefinition"];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "search";
        };
        /**
         * Text Search Index Definition
         * @description The text search index definition set by the user.
         */
        TextSearchIndexDefinition: {
            /**
             * @description Specific pre-defined method chosen to convert database field text into searchable words. This conversion reduces the text of fields into the smallest units of text. These units are called a **term** or **token**. This process, known as tokenization, involves making the following changes to the text in fields:
             *
             *     - extracting words
             *     - removing punctuation
             *     - removing accents
             *     - changing to lowercase
             *     - removing common words
             *     - reducing words to their root form (stemming)
             *     - changing words to their base form (lemmatization)
             *      MongoDB Cloud uses the process you select to build the Atlas Search index.
             * @default lucene.standard
             * @enum {string}
             */
            analyzer: "lucene.standard" | "lucene.simple" | "lucene.whitespace" | "lucene.keyword" | "lucene.arabic" | "lucene.armenian" | "lucene.basque" | "lucene.bengali" | "lucene.brazilian" | "lucene.bulgarian" | "lucene.catalan" | "lucene.chinese" | "lucene.cjk" | "lucene.czech" | "lucene.danish" | "lucene.dutch" | "lucene.english" | "lucene.finnish" | "lucene.french" | "lucene.galician" | "lucene.german" | "lucene.greek" | "lucene.hindi" | "lucene.hungarian" | "lucene.indonesian" | "lucene.irish" | "lucene.italian" | "lucene.japanese" | "lucene.korean" | "lucene.kuromoji" | "lucene.latvian" | "lucene.lithuanian" | "lucene.morfologik" | "lucene.nori" | "lucene.norwegian" | "lucene.persian" | "lucene.portuguese" | "lucene.romanian" | "lucene.russian" | "lucene.smartcn" | "lucene.sorani" | "lucene.spanish" | "lucene.swedish" | "lucene.thai" | "lucene.turkish" | "lucene.ukrainian";
            /** @description List of user-defined methods to convert database field text into searchable words. */
            analyzers?: components["schemas"]["AtlasSearchAnalyzer"][];
            mappings: components["schemas"]["SearchMappings"];
            /**
             * Format: int32
             * @description Number of index partitions. Allowed values are [1, 2, 4].
             * @default 1
             */
            numPartitions: number;
            /**
             * @description Method applied to identify words when searching this index.
             * @default lucene.standard
             * @enum {string}
             */
            searchAnalyzer: "lucene.standard" | "lucene.simple" | "lucene.whitespace" | "lucene.keyword" | "lucene.arabic" | "lucene.armenian" | "lucene.basque" | "lucene.bengali" | "lucene.brazilian" | "lucene.bulgarian" | "lucene.catalan" | "lucene.chinese" | "lucene.cjk" | "lucene.czech" | "lucene.danish" | "lucene.dutch" | "lucene.english" | "lucene.finnish" | "lucene.french" | "lucene.galician" | "lucene.german" | "lucene.greek" | "lucene.hindi" | "lucene.hungarian" | "lucene.indonesian" | "lucene.irish" | "lucene.italian" | "lucene.japanese" | "lucene.korean" | "lucene.kuromoji" | "lucene.latvian" | "lucene.lithuanian" | "lucene.morfologik" | "lucene.nori" | "lucene.norwegian" | "lucene.persian" | "lucene.portuguese" | "lucene.romanian" | "lucene.russian" | "lucene.smartcn" | "lucene.sorani" | "lucene.spanish" | "lucene.swedish" | "lucene.thai" | "lucene.turkish" | "lucene.ukrainian";
            /**
             * @description Flag that indicates whether to store all fields (true) on Atlas Search. By default, Atlas doesn't store (false) the fields on Atlas Search.  Alternatively, you can specify an object that only contains the list of fields to store (include) or not store (exclude) on Atlas Search. To learn more, see Stored Source Fields.
             * @example {
             *       "include | exclude": [
             *         "field1",
             *         "field2"
             *       ]
             *     }
             */
            storedSource?: Record<string, never>;
            /** @description Rule sets that map words to their synonyms in this index. */
            synonyms?: components["schemas"]["SearchSynonymMappingDefinition"][];
        };
        /** Text Search Index Response */
        TextSearchIndexResponse: Omit<components["schemas"]["SearchIndexResponse"], "type"> & {
            latestDefinition?: components["schemas"]["TextSearchIndexDefinition"];
            /** @description List of documents detailing index status on each host. */
            statusDetail?: components["schemas"]["TextSearchHostStatusDetail"][];
            /**
             * @description Status that describes this index's synonym mappings. This status appears only if the index has synonyms defined.
             * @enum {string}
             */
            synonymMappingStatus?: "FAILED" | "BUILDING" | "READY";
            /** @description A list of documents describing the status of the index's synonym mappings on each search host. Only appears if the index has synonyms defined. */
            synonymMappingStatusDetail?: {
                [key: string]: components["schemas"]["SynonymMappingStatusDetail"];
            }[];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "search";
        };
        /**
         * Text Search Index Status Detail
         * @description Contains status information about a text search index.
         */
        TextSearchIndexStatusDetail: {
            definition?: components["schemas"]["TextSearchIndexDefinition"];
            definitionVersion?: components["schemas"]["SearchIndexDefinitionVersion"];
            /** @description Optional message describing an error. */
            message?: string;
            /** @description Flag that indicates whether the index generation is queryable on the host. */
            queryable?: boolean;
            /**
             * @description Condition of the search index when you made this request.
             *
             *     - `DELETING`: The index is being deleted.
             *     - `FAILED` The index build failed. Indexes can enter the FAILED state due to an invalid index definition.
             *     - `STALE`: The index is queryable but has stopped replicating data from the indexed collection. Searches on the index may return out-of-date data.
             *     - `PENDING`: Atlas has not yet started building the index.
             *     - `BUILDING`: Atlas is building or re-building the index after an edit.
             *     - `READY`: The index is ready and can support queries.
             * @enum {string}
             */
            status?: "DELETING" | "FAILED" | "STALE" | "PENDING" | "BUILDING" | "READY" | "DOES_NOT_EXIST";
            /**
             * @description Status that describes this index's synonym mappings. This status appears only if the index has synonyms defined.
             * @enum {string}
             */
            synonymMappingStatus?: "FAILED" | "BUILDING" | "READY";
            /** @description List of synonym statuses by mapping. */
            synonymMappingStatusDetail?: components["schemas"]["SynonymMappingStatusDetailMap"][];
        };
        TimeMetricAlertView: {
            /**
             * Format: date-time
             * @description Date and time until which this alert has been acknowledged. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter if a MongoDB User previously acknowledged this alert.
             *
             *     - To acknowledge this alert forever, set the parameter value to 100 years in the future.
             *
             *     - To unacknowledge a previously acknowledged alert, do not set this parameter value.
             */
            acknowledgedUntil?: string;
            /**
             * @description Comment that a MongoDB Cloud user submitted when acknowledging the alert.
             * @example Expiration on 3/19.  Silencing for 7days.
             */
            acknowledgementComment?: string;
            /**
             * Format: email
             * @description MongoDB Cloud username of the person who acknowledged the alert. The response returns this parameter if a MongoDB Cloud user previously acknowledged this alert.
             */
            readonly acknowledgingUsername?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies the alert configuration that sets this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly alertConfigId: string;
            /**
             * @description Human-readable label that identifies the cluster to which this alert applies. This resource returns this parameter for alerts of events impacting backups, replica sets, or sharded clusters.
             * @example cluster1
             */
            readonly clusterName?: string;
            /**
             * Format: date-time
             * @description Date and time when MongoDB Cloud created this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly created: string;
            currentValue?: components["schemas"]["TimeMetricValueView"];
            eventTypeName: components["schemas"]["HostMetricEventTypeViewAlertable"];
            /**
             * @description Unique 24-hexadecimal digit string that identifies the project that owns this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly groupId?: string;
            /**
             * @description Hostname and port of the host to which this alert applies. The resource returns this parameter for alerts of events impacting hosts or replica sets.
             * @example cloud-test.mongodb.com:27017
             */
            readonly hostnameAndPort?: string;
            /**
             * @description Unique 24-hexadecimal digit string that identifies this alert.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly id: string;
            /**
             * Format: date-time
             * @description Date and time that any notifications were last sent for this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter if MongoDB Cloud has sent notifications for this alert.
             */
            readonly lastNotified?: string;
            /** @description List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships. */
            readonly links?: components["schemas"]["Link"][];
            /**
             * @description Name of the metric against which Atlas checks the configured `metricThreshold.threshold`.
             *
             *     To learn more about the available metrics, see <a href="https://www.mongodb.com/docs/atlas/reference/alert-host-metrics/#std-label-measurement-types" target="_blank">Host Metrics</a>.
             *
             *     **NOTE**: If you set eventTypeName to OUTSIDE_SERVERLESS_METRIC_THRESHOLD, you can specify only metrics available for serverless. To learn more, see <a href="https://dochub.mongodb.org/core/alert-config-serverless-measurements" target="_blank">Serverless Measurements</a>.
             * @example ASSERT_USER
             */
            readonly metricName?: string;
            /**
             * @description Unique 24-hexadecimal character string that identifies the organization that owns the project to which this alert applies.
             * @example 32b6e34b3d91647abb20e7b8
             */
            readonly orgId?: string;
            /**
             * @description Name of the replica set to which this alert applies. The response returns this parameter for alerts of events impacting backups, hosts, or replica sets.
             * @example event-replica-set
             */
            readonly replicaSetName?: string;
            /**
             * Format: date-time
             * @description Date and time that this alert changed to `"status" : "CLOSED"`. This parameter expresses its value in the ISO 8601 timestamp format in UTC. The resource returns this parameter once `"status" : "CLOSED"`.
             */
            readonly resolved?: string;
            /**
             * @description State of this alert at the time you requested its details.
             * @example OPEN
             * @enum {string}
             */
            readonly status: "CANCELLED" | "CLOSED" | "OPEN" | "TRACKING";
            /**
             * Format: date-time
             * @description Date and time when someone last updated this alert. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
             */
            readonly updated: string;
        };
        /**
         * Time Metric Units
         * @description Element used to express the quantity. This can be an element of time, storage capacity, and the like.
         * @default HOURS
         * @enum {string}
         */
        TimeMetricUnits: "NANOSECONDS" | "MILLISECONDS" | "MILLION_MINUTES" | "SECONDS" | "MINUTES" | "HOURS" | "DAYS";
        /**
         * Time Metric Value
         * @description Measurement of the **metricName** recorded at the time of the event.
         */
        TimeMetricValueView: {
            /**
             * Format: double
             * @description Amount of the **metricName** recorded at the time of the event. This value triggered the alert.
             */
            readonly number?: number;
            units?: components["schemas"]["TimeMetricUnits"];
        };
        /**
         * englishPossessive
         * @description Filter that removes possessives (trailing 's) from words.
         */
        TokenFilterEnglishPossessive: {
            /**
             * @description Human-readable label that identifies this token filter type.
             * @enum {string}
             */
            type: "englishPossessive";
        };
        /**
         * flattenGraph
         * @description Filter that transforms a token filter graph, such as the token filter graph that the wordDelimiterGraph token filter produces, into a flat form suitable for indexing.
         */
        TokenFilterFlattenGraph: {
            /**
             * @description Human-readable label that identifies this token filter type.
             * @enum {string}
             */
            type: "flattenGraph";
        };
        /**
         * porterStemming
         * @description Filter that uses the porter stemming algorithm to remove the common morphological and inflectional suffixes from words in English. It expects lowercase text and doesn't work as expected for uppercase text.
         */
        TokenFilterPorterStemming: {
            /**
             * @description Human-readable label that identifies this token filter type.
             * @enum {string}
             */
            type: "porterStemming";
        };
        /**
         * spanishPluralStemming
         * @description Filter that stems Spanish plural words. It expects lowercase text.
         */
        TokenFilterSpanishPluralStemming: {
            /**
             * @description Human-readable label that identifies this token filter type.
             * @enum {string}
             */
            type: "spanishPluralStemming";
        };
        /**
         * stempel
         * @description Filter that uses Lucene's default Polish stemmer table to stem words in the Polish language. It expects lowercase text.
         */
        TokenFilterStempel: {
            /**
             * @description Human-readable label that identifies this token filter type.
             * @enum {string}
             */
            type: "stempel";
        };
        /**
         * wordDelimiterGraph
         * @description Filter that splits tokens into sub-tokens based on configured rules.
         */
        TokenFilterWordDelimiterGraph: {
            /** @description Object that contains the rules that determine how to split words into sub-words. */
            delimiterOptions?: {
                /**
                 * @description Flag that indicates whether to concatenate runs.
                 * @default false
                 */
                concatenateAll: boolean;
                /**
                 * @description Flag that indicates whether to concatenate runs of sub-numbers.
                 * @default false
                 */
                concatenateNumbers: boolean;
                /**
                 * @description Flag that indicates whether to concatenate runs of sub-words.
                 * @default false
                 */
                concatenateWords: boolean;
                /**
                 * @description Flag that indicates whether to split tokens based on sub-numbers. For example, if `true`, this option splits `100-2` into `100` and `2`.
                 * @default true
                 */
                generateNumberParts: boolean;
                /**
                 * @description Flag that indicates whether to split tokens based on sub-words.
                 * @default true
                 */
                generateWordParts: boolean;
                /**
                 * @description Flag that indicates whether to skip tokens with the `keyword` attribute set to `true`.
                 * @default false
                 */
                ignoreKeywords: boolean;
                /**
                 * @description Flag that indicates whether to generate tokens of the original words.
                 * @default true
                 */
                preserveOriginal: boolean;
                /**
                 * @description Flag that indicates whether to split tokens based on letter-case transitions.
                 * @default true
                 */
                splitOnCaseChange: boolean;
                /**
                 * @description Flag that indicates whether to split tokens based on letter-number transitions.
                 * @default true
                 */
                splitOnNumerics: boolean;
                /**
                 * @description Flag that indicates whether to remove trailing possessives from each sub-word.
                 * @default true
                 */
                stemEnglishPossessive: boolean;
            };
            /** @description Object that contains options for protected words. */
            protectedWords?: {
                /**
                 * @description Flag that indicates whether to ignore letter case sensitivity for protected words.
                 * @default true
                 */
                ignoreCase: boolean;
                /** @description List that contains the tokens to protect from delimination. */
                words: string[];
            };
            /**
             * @description Human-readable label that identifies this token filter type.
             * @enum {string}
             */
            type: "wordDelimiterGraph";
        };
        /**
         * kStemming
         * @description Filter that combines algorithmic stemming with a built-in dictionary for the English language to stem words.
         */
        TokenFilterkStemming: {
            /**
             * @description Human-readable label that identifies this token filter type.
             * @enum {string}
             */
            type: "kStemming";
        };
        /**
         * Database User Scope
         * @description Range of resources available to this database user.
         */
        UserScope: {
            /** @description Human-readable label that identifies the cluster or MongoDB Atlas Data Lake that this database user can access. */
            name: string;
            /**
             * @description Category of resource that this database user can access.
             * @enum {string}
             */
            type: "CLUSTER" | "DATA_LAKE" | "STREAM";
        };
        /** Vector Search Host Status Detail */
        VectorSearchHostStatusDetail: {
            /** @description Hostname that corresponds to the status detail. */
            hostname?: string;
            mainIndex?: components["schemas"]["VectorSearchIndexStatusDetail"];
            /** @description Flag that indicates whether the index is queryable on the host. */
            queryable?: boolean;
            stagedIndex?: components["schemas"]["VectorSearchIndexStatusDetail"];
            /**
             * @description Condition of the search index when you made this request.
             *
             *     - `DELETING`: The index is being deleted.
             *     - `FAILED` The index build failed. Indexes can enter the FAILED state due to an invalid index definition.
             *     - `STALE`: The index is queryable but has stopped replicating data from the indexed collection. Searches on the index may return out-of-date data.
             *     - `PENDING`: Atlas has not yet started building the index.
             *     - `BUILDING`: Atlas is building or re-building the index after an edit.
             *     - `READY`: The index is ready and can support queries.
             * @enum {string}
             */
            status?: "DELETING" | "FAILED" | "STALE" | "PENDING" | "BUILDING" | "READY" | "DOES_NOT_EXIST";
        };
        VectorSearchIndex: Omit<WithRequired<components["schemas"]["ClusterSearchIndex"], "collectionName" | "database" | "name">, "type"> & {
            /** @description Settings that configure the fields, one per object, to index. You must define at least one "vector" type field. You can optionally define "filter" type fields also. */
            fields?: components["schemas"]["BasicDBObject"][];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "vectorSearch";
        };
        /** @description Vector Search Index Create Request */
        VectorSearchIndexCreateRequest: Omit<WithRequired<components["schemas"]["SearchIndexCreateRequest"], "collectionName" | "database" | "name">, "type"> & {
            definition: components["schemas"]["VectorSearchIndexDefinition"];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "vectorSearch";
        };
        /**
         * Vector Search Index Definition
         * @description The vector search index definition set by the user.
         */
        VectorSearchIndexDefinition: {
            /** @description Settings that configure the fields, one per object, to index. You must define at least one "vector" type field. You can optionally define "filter" type fields also. */
            fields?: components["schemas"]["BasicDBObject"][];
            /**
             * Format: int32
             * @description Number of index partitions. Allowed values are [1, 2, 4].
             * @default 1
             */
            numPartitions: number;
        };
        /** Vector Search Index Response */
        VectorSearchIndexResponse: Omit<components["schemas"]["SearchIndexResponse"], "type"> & {
            latestDefinition?: components["schemas"]["VectorSearchIndexDefinition"];
            /** @description List of documents detailing index status on each host. */
            statusDetail?: components["schemas"]["VectorSearchHostStatusDetail"][];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "vectorSearch";
        };
        /**
         * Vector Search Index Status Detail
         * @description Contains status information about a vector search index.
         */
        VectorSearchIndexStatusDetail: {
            definition?: components["schemas"]["VectorSearchIndexDefinition"];
            definitionVersion?: components["schemas"]["SearchIndexDefinitionVersion"];
            /** @description Optional message describing an error. */
            message?: string;
            /** @description Flag that indicates whether the index generation is queryable on the host. */
            queryable?: boolean;
            /**
             * @description Condition of the search index when you made this request.
             *
             *     - `DELETING`: The index is being deleted.
             *     - `FAILED` The index build failed. Indexes can enter the FAILED state due to an invalid index definition.
             *     - `STALE`: The index is queryable but has stopped replicating data from the indexed collection. Searches on the index may return out-of-date data.
             *     - `PENDING`: Atlas has not yet started building the index.
             *     - `BUILDING`: Atlas is building or re-building the index after an edit.
             *     - `READY`: The index is ready and can support queries.
             * @enum {string}
             */
            status?: "DELETING" | "FAILED" | "STALE" | "PENDING" | "BUILDING" | "READY" | "DOES_NOT_EXIST";
        };
        WeeklyScheduleView: Omit<WithRequired<components["schemas"]["OnlineArchiveSchedule"], "type">, "type"> & {
            /**
             * Format: int32
             * @description Day of the week when the scheduled archive starts. The week starts with Monday (`1`) and ends with Sunday (`7`).
             */
            dayOfWeek?: number;
            /**
             * Format: int32
             * @description Hour of the day when the scheduled window to run one online archive ends.
             */
            endHour?: number;
            /**
             * Format: int32
             * @description Minute of the hour when the scheduled window to run one online archive ends.
             */
            endMinute?: number;
            /**
             * Format: int32
             * @description Hour of the day when the when the scheduled window to run one online archive starts.
             */
            startHour?: number;
            /**
             * Format: int32
             * @description Minute of the hour when the scheduled window to run one online archive starts.
             */
            startMinute?: number;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "WEEKLY";
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "WEEKLY";
        };
        /**
         * htmlStrip
         * @description Filter that strips out HTML constructs.
         */
        charFilterhtmlStrip: {
            /** @description The HTML tags that you want to exclude from filtering. */
            ignoredTags?: string[];
            /**
             * @description Human-readable label that identifies this character filter type.
             * @enum {string}
             */
            type: "htmlStrip";
        };
        /**
         * icuNormalize
         * @description Filter that processes normalized text with the ICU Normalizer. It is based on Lucene's ICUNormalizer2CharFilter.
         */
        charFiltericuNormalize: {
            /**
             * @description Human-readable label that identifies this character filter type.
             * @enum {string}
             */
            type: "icuNormalize";
        };
        /**
         * mapping
         * @description Filter that applies normalization mappings that you specify to characters.
         */
        charFiltermapping: {
            /** @description Comma-separated list of mappings. A mapping indicates that one character or group of characters should be substituted for another, using the following format:
             *
             *     `<original> : <replacement>`. */
            mappings: {
                [key: string]: string;
            };
            /**
             * @description Human-readable label that identifies this character filter type.
             * @enum {string}
             */
            type: "mapping";
        };
        /**
         * persian
         * @description Filter that replaces instances of a zero-width non-joiner with an ordinary space. It is based on Lucene's PersianCharFilter.
         */
        charFilterpersian: {
            /**
             * @description Human-readable label that identifies this character filter type.
             * @enum {string}
             */
            type: "persian";
        };
        /**
         * asciiFolding
         * @description Filter that converts alphabetic, numeric, and symbolic Unicode characters that are not in the Basic Latin Unicode block to their ASCII equivalents, if available.
         */
        tokenFilterasciiFolding: {
            /**
             * @description Value that indicates whether to include or omit the original tokens in the output of the token filter.
             *
             *     Choose `include` if you want to support queries on both the original tokens as well as the converted forms.
             *
             *      Choose `omit` if you want to query only on the converted forms of the original tokens.
             * @default omit
             * @enum {string}
             */
            originalTokens: "omit" | "include";
            /**
             * @description Human-readable label that identifies this token filter type.
             * @enum {string}
             */
            type: "asciiFolding";
        };
        /**
         * daitchMokotoffSoundex
         * @description Filter that creates tokens for words that sound the same based on the Daitch-Mokotoff Soundex phonetic algorithm. This filter can generate multiple encodings for each input, where each encoded token is a 6 digit number.
         *
         *     **NOTE**: Don't use the **daitchMokotoffSoundex** token filter in:
         *
         *     -Synonym or autocomplete mapping definitions
         *     - Operators where **fuzzy** is enabled. Atlas Search supports the **fuzzy** option only for the **autocomplete**, **term**, and **text** operators.
         */
        tokenFilterdaitchMokotoffSoundex: {
            /**
             * @description Value that indicates whether to include or omit the original tokens in the output of the token filter.
             *
             *     Choose `include` if you want to support queries on both the original tokens as well as the converted forms.
             *
             *      Choose `omit` if you want to query only on the converted forms of the original tokens.
             * @default include
             * @enum {string}
             */
            originalTokens: "omit" | "include";
            /**
             * @description Human-readable label that identifies this token filter type.
             * @enum {string}
             */
            type: "daitchMokotoffSoundex";
        };
        /**
         * edgeGram
         * @description Filter that tokenizes input from the left side, or "edge", of a text input into n-grams of configured sizes. You can't use this token filter in synonym or autocomplete mapping definitions.
         */
        tokenFilteredgeGram: {
            /** @description Value that specifies the maximum length of generated n-grams. This value must be greater than or equal to **minGram**. */
            maxGram: number;
            /** @description Value that specifies the minimum length of generated n-grams. This value must be less than or equal to **maxGram**. */
            minGram: number;
            /**
             * @description Value that indicates whether to index tokens shorter than **minGram** or longer than **maxGram**.
             * @default omit
             * @enum {string}
             */
            termNotInBounds: "omit" | "include";
            /**
             * @description Human-readable label that identifies this token filter type.
             * @enum {string}
             */
            type: "edgeGram";
        };
        /**
         * icuFolding
         * @description Filter that applies character folding from Unicode Technical Report #30.
         */
        tokenFiltericuFolding: {
            /**
             * @description Human-readable label that identifies this token filter type.
             * @enum {string}
             */
            type: "icuFolding";
        };
        /**
         * icuNormalizer
         * @description Filter that normalizes tokens using a standard Unicode Normalization Mode.
         */
        tokenFiltericuNormalizer: {
            /**
             * @description Normalization form to apply.
             * @default nfc
             * @enum {string}
             */
            normalizationForm: "nfd" | "nfc" | "nfkd" | "nfkc";
            /**
             * @description Human-readable label that identifies this token filter type.
             * @enum {string}
             */
            type: "icuNormalizer";
        };
        /**
         * length
         * @description Filter that removes tokens that are too short or too long.
         */
        tokenFilterlength: {
            /**
             * @description Number that specifies the maximum length of a token. Value must be greater than or equal to **min**.
             * @default 255
             */
            max: number;
            /**
             * @description Number that specifies the minimum length of a token. This value must be less than or equal to **max**.
             * @default 0
             */
            min: number;
            /**
             * @description Human-readable label that identifies this token filter type.
             * @enum {string}
             */
            type: "length";
        };
        /**
         * lowercase
         * @description Filter that normalizes token text to lowercase.
         */
        tokenFilterlowercase: {
            /**
             * @description Human-readable label that identifies this token filter type.
             * @enum {string}
             */
            type: "lowercase";
        };
        /**
         * nGram
         * @description Filter that tokenizes input into n-grams of configured sizes. You can't use this token filter in synonym or autocomplete mapping definitions.
         */
        tokenFilternGram: {
            /** @description Value that specifies the maximum length of generated n-grams. This value must be greater than or equal to **minGram**. */
            maxGram: number;
            /** @description Value that specifies the minimum length of generated n-grams. This value must be less than or equal to **maxGram**. */
            minGram: number;
            /**
             * @description Value that indicates whether to index tokens shorter than **minGram** or longer than **maxGram**.
             * @default omit
             * @enum {string}
             */
            termNotInBounds: "omit" | "include";
            /**
             * @description Human-readable label that identifies this token filter type.
             * @enum {string}
             */
            type: "nGram";
        };
        /**
         * regex
         * @description Filter that applies a regular expression to each token, replacing matches with a specified string.
         */
        tokenFilterregex: {
            /**
             * @description Value that indicates whether to replace only the first matching pattern or all matching patterns.
             * @enum {string}
             */
            matches: "all" | "first";
            /** @description Regular expression pattern to apply to each token. */
            pattern: string;
            /** @description Replacement string to substitute wherever a matching pattern occurs. */
            replacement: string;
            /**
             * @description Human-readable label that identifies this token filter type.
             * @enum {string}
             */
            type: "regex";
        };
        /**
         * reverse
         * @description Filter that reverses each string token.
         */
        tokenFilterreverse: {
            /**
             * @description Human-readable label that identifies this token filter type.
             * @enum {string}
             */
            type: "reverse";
        };
        /**
         * shingle
         * @description Filter that constructs shingles (token n-grams) from a series of tokens. You can't use this token filter in synonym or autocomplete mapping definitions.
         */
        tokenFiltershingle: {
            /** @description Value that specifies the maximum number of tokens per shingle. This value must be greater than or equal to **minShingleSize**. */
            maxShingleSize: number;
            /** @description Value that specifies the minimum number of tokens per shingle. This value must be less than or equal to **maxShingleSize**. */
            minShingleSize: number;
            /**
             * @description Human-readable label that identifies this token filter type.
             * @enum {string}
             */
            type: "shingle";
        };
        /**
         * snowballStemming
         * @description Filter that stems tokens using a Snowball-generated stemmer.
         */
        tokenFiltersnowballStemming: {
            /**
             * @description Snowball-generated stemmer to use.
             * @enum {string}
             */
            stemmerName: "arabic" | "armenian" | "basque" | "catalan" | "danish" | "dutch" | "english" | "finnish" | "french" | "german" | "german2" | "hungarian" | "irish" | "italian" | "kp" | "lithuanian" | "lovins" | "norwegian" | "porter" | "portuguese" | "romanian" | "russian" | "spanish" | "swedish" | "turkish";
            /**
             * @description Human-readable label that identifies this token filter type.
             * @enum {string}
             */
            type: "snowballStemming";
        };
        /**
         * stopword
         * @description Filter that removes tokens that correspond to the specified stop words. This token filter doesn't analyze the stop words that you specify.
         */
        tokenFilterstopword: {
            /**
             * @description Flag that indicates whether to ignore the case of stop words when filtering the tokens to remove.
             * @default true
             */
            ignoreCase: boolean;
            /** @description The stop words that correspond to the tokens to remove. Value must be one or more stop words. */
            tokens: string[];
            /**
             * @description Human-readable label that identifies this token filter type.
             * @enum {string}
             */
            type: "stopword";
        };
        /**
         * trim
         * @description Filter that trims leading and trailing whitespace from tokens.
         */
        tokenFiltertrim: {
            /**
             * @description Human-readable label that identifies this token filter type.
             * @enum {string}
             */
            type: "trim";
        };
        /**
         * edgeGram
         * @description Tokenizer that splits input from the left side, or "edge", of a text input into n-grams of given sizes. You can't use the edgeGram tokenizer in synonym or autocomplete mapping definitions.
         */
        tokenizeredgeGram: {
            /** @description Characters to include in the longest token that Atlas Search creates. */
            maxGram: number;
            /** @description Characters to include in the shortest token that Atlas Search creates. */
            minGram: number;
            /**
             * @description Human-readable label that identifies this tokenizer type. (enum property replaced by openapi-typescript)
             * @enum {string}
             */
            type: "edgeGram";
        };
        /**
         * keyword
         * @description Tokenizer that combines the entire input as a single token.
         */
        tokenizerkeyword: {
            /**
             * @description Human-readable label that identifies this tokenizer type. (enum property replaced by openapi-typescript)
             * @enum {string}
             */
            type: "keyword";
        };
        /**
         * nGram
         * @description Tokenizer that splits input into text chunks, or "n-grams", of into given sizes. You can't use the nGram tokenizer in synonym or autocomplete mapping definitions.
         */
        tokenizernGram: {
            /** @description Characters to include in the longest token that Atlas Search creates. */
            maxGram: number;
            /** @description Characters to include in the shortest token that Atlas Search creates. */
            minGram: number;
            /**
             * @description Human-readable label that identifies this tokenizer type. (enum property replaced by openapi-typescript)
             * @enum {string}
             */
            type: "nGram";
        };
        /**
         * regexCaptureGroup
         * @description Tokenizer that uses a regular expression pattern to extract tokens.
         */
        tokenizerregexCaptureGroup: {
            /** @description Index of the character group within the matching expression to extract into tokens. Use `0` to extract all character groups. */
            group: number;
            /** @description Regular expression to match against. */
            pattern: string;
            /**
             * @description Human-readable label that identifies this tokenizer type. (enum property replaced by openapi-typescript)
             * @enum {string}
             */
            type: "regexCaptureGroup";
        };
        /**
         * regexSplit
         * @description Tokenizer that splits tokens using a regular-expression based delimiter.
         */
        tokenizerregexSplit: {
            /** @description Regular expression to match against. */
            pattern: string;
            /**
             * @description Human-readable label that identifies this tokenizer type. (enum property replaced by openapi-typescript)
             * @enum {string}
             */
            type: "regexSplit";
        };
        /**
         * standard
         * @description Tokenizer that splits tokens based on word break rules from the Unicode Text Segmentation algorithm.
         */
        tokenizerstandard: {
            /**
             * @description Maximum number of characters in a single token. Tokens greater than this length are split at this length into multiple tokens.
             * @default 255
             */
            maxTokenLength: number;
            /**
             * @description Human-readable label that identifies this tokenizer type. (enum property replaced by openapi-typescript)
             * @enum {string}
             */
            type: "standard";
        };
        /**
         * uaxUrlEmail
         * @description Tokenizer that creates tokens from URLs and email addresses. Although this tokenizer uses word break rules from the Unicode Text Segmentation algorithm, we recommend using it only when the indexed field value includes URLs and email addresses. For fields that don't include URLs or email addresses, use the **standard** tokenizer to create tokens based on word break rules.
         */
        tokenizeruaxUrlEmail: {
            /**
             * @description Maximum number of characters in a single token. Tokens greater than this length are split at this length into multiple tokens.
             * @default 255
             */
            maxTokenLength: number;
            /**
             * @description Human-readable label that identifies this tokenizer type. (enum property replaced by openapi-typescript)
             * @enum {string}
             */
            type: "uaxUrlEmail";
        };
        /**
         * whitespace
         * @description Tokenizer that creates tokens based on occurrences of whitespace between words.
         */
        tokenizerwhitespace: {
            /**
             * @description Maximum number of characters in a single token. Tokens greater than this length are split at this length into multiple tokens.
             * @default 255
             */
            maxTokenLength: number;
            /**
             * @description Human-readable label that identifies this tokenizer type. (enum property replaced by openapi-typescript)
             * @enum {string}
             */
            type: "whitespace";
        };
    };
    responses: {
        /** @description Bad Request. */
        badRequest: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ApiError"];
            };
        };
        /** @description Conflict. */
        conflict: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ApiError"];
            };
        };
        /** @description Forbidden. */
        forbidden: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ApiError"];
            };
        };
        /** @description Internal Server Error. */
        internalServerError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ApiError"];
            };
        };
        /** @description Not Found. */
        notFound: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ApiError"];
            };
        };
        /** @description Payment Required. */
        paymentRequired: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ApiError"];
            };
        };
        /** @description Unauthorized. */
        unauthorized: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ApiError"];
            };
        };
    };
    parameters: {
        /** @description Flag that indicates whether Application wraps the response in an `envelope` JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope=true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body. */
        envelope: boolean;
        /** @description Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.
         *
         *     **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups. */
        groupId: string;
        /** @description Flag that indicates whether the response returns the total number of items (**totalCount**) in the response. */
        includeCount: boolean;
        /** @description Number of items that the response returns per page. */
        itemsPerPage: number;
        /** @description Unique 24-hexadecimal digit string that identifies the organization that contains your projects. Use the [/orgs](#tag/Organizations/operation/listOrganizations) endpoint to retrieve all organizations to which the authenticated user has access. */
        orgId: string;
        /** @description Number of the page that displays the current set of the total objects that the response returns. */
        pageNum: number;
        /** @description Flag that indicates whether the response body should be in the prettyprint format. */
        pretty: boolean;
    };
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type AwsCloudProviderContainer = components['schemas']['AWSCloudProviderContainer'];
export type AwsCloudProviderSettings = components['schemas']['AWSCloudProviderSettings'];
export type AwsComputeAutoScaling = components['schemas']['AWSComputeAutoScaling'];
export type AwsCreateDataProcessRegionView = components['schemas']['AWSCreateDataProcessRegionView'];
export type AwsDataProcessRegionView = components['schemas']['AWSDataProcessRegionView'];
export type AwsHardwareSpec = components['schemas']['AWSHardwareSpec'];
export type AwsHardwareSpec20240805 = components['schemas']['AWSHardwareSpec20240805'];
export type AwsRegionConfig = components['schemas']['AWSRegionConfig'];
export type AwsRegionConfig20240805 = components['schemas']['AWSRegionConfig20240805'];
export type AdvancedAutoScalingSettings = components['schemas']['AdvancedAutoScalingSettings'];
export type AdvancedComputeAutoScaling = components['schemas']['AdvancedComputeAutoScaling'];
export type AlertViewForNdsGroup = components['schemas']['AlertViewForNdsGroup'];
export type ApiAtlasCloudProviderAccessFeatureUsageFeatureIdView = components['schemas']['ApiAtlasCloudProviderAccessFeatureUsageFeatureIdView'];
export type ApiAtlasClusterAdvancedConfigurationView = components['schemas']['ApiAtlasClusterAdvancedConfigurationView'];
export type ApiAtlasFtsAnalyzersViewManual = components['schemas']['ApiAtlasFTSAnalyzersViewManual'];
export type ApiAtlasFtsMappingsViewManual = components['schemas']['ApiAtlasFTSMappingsViewManual'];
export type ApiError = components['schemas']['ApiError'];
export type AppServiceAlertView = components['schemas']['AppServiceAlertView'];
export type AppServiceEventTypeViewAlertable = components['schemas']['AppServiceEventTypeViewAlertable'];
export type AtlasOrganization = components['schemas']['AtlasOrganization'];
export type AtlasSearchAnalyzer = components['schemas']['AtlasSearchAnalyzer'];
export type AzureCloudProviderContainer = components['schemas']['AzureCloudProviderContainer'];
export type AzureCloudProviderSettings = components['schemas']['AzureCloudProviderSettings'];
export type AzureComputeAutoScalingRules = components['schemas']['AzureComputeAutoScalingRules'];
export type AzureCreateDataProcessRegionView = components['schemas']['AzureCreateDataProcessRegionView'];
export type AzureDataProcessRegionView = components['schemas']['AzureDataProcessRegionView'];
export type AzureHardwareSpec = components['schemas']['AzureHardwareSpec'];
export type AzureHardwareSpec20240805 = components['schemas']['AzureHardwareSpec20240805'];
export type AzureRegionConfig = components['schemas']['AzureRegionConfig'];
export type AzureRegionConfig20240805 = components['schemas']['AzureRegionConfig20240805'];
export type BadRequestDetail = components['schemas']['BadRequestDetail'];
export type BaseCloudProviderInstanceSize = components['schemas']['BaseCloudProviderInstanceSize'];
export type BasicDbObject = components['schemas']['BasicDBObject'];
export type BiConnector = components['schemas']['BiConnector'];
export type BillingInvoice = components['schemas']['BillingInvoice'];
export type BillingInvoiceMetadata = components['schemas']['BillingInvoiceMetadata'];
export type BillingPayment = components['schemas']['BillingPayment'];
export type BillingRefund = components['schemas']['BillingRefund'];
export type CloudCluster = components['schemas']['CloudCluster'];
export type CloudDatabaseUser = components['schemas']['CloudDatabaseUser'];
export type CloudGcpProviderSettings = components['schemas']['CloudGCPProviderSettings'];
export type CloudProviderAwsAutoScaling = components['schemas']['CloudProviderAWSAutoScaling'];
export type CloudProviderAccessAwsiamRole = components['schemas']['CloudProviderAccessAWSIAMRole'];
export type CloudProviderAccessAwsiamRoleRequestUpdate = components['schemas']['CloudProviderAccessAWSIAMRoleRequestUpdate'];
export type CloudProviderAccessAzureServicePrincipal = components['schemas']['CloudProviderAccessAzureServicePrincipal'];
export type CloudProviderAccessAzureServicePrincipalRequestUpdate = components['schemas']['CloudProviderAccessAzureServicePrincipalRequestUpdate'];
export type CloudProviderAccessDataLakeFeatureUsage = components['schemas']['CloudProviderAccessDataLakeFeatureUsage'];
export type CloudProviderAccessEncryptionAtRestFeatureUsage = components['schemas']['CloudProviderAccessEncryptionAtRestFeatureUsage'];
export type CloudProviderAccessExportSnapshotFeatureUsage = components['schemas']['CloudProviderAccessExportSnapshotFeatureUsage'];
export type CloudProviderAccessFeatureUsage = components['schemas']['CloudProviderAccessFeatureUsage'];
export type CloudProviderAccessFeatureUsageDataLakeFeatureId = components['schemas']['CloudProviderAccessFeatureUsageDataLakeFeatureId'];
export type CloudProviderAccessFeatureUsageExportSnapshotFeatureId = components['schemas']['CloudProviderAccessFeatureUsageExportSnapshotFeatureId'];
export type CloudProviderAccessFeatureUsagePushBasedLogExportFeatureId = components['schemas']['CloudProviderAccessFeatureUsagePushBasedLogExportFeatureId'];
export type CloudProviderAccessGcpServiceAccount = components['schemas']['CloudProviderAccessGCPServiceAccount'];
export type CloudProviderAccessGcpServiceAccountRequestUpdate = components['schemas']['CloudProviderAccessGCPServiceAccountRequestUpdate'];
export type CloudProviderAccessPushBasedLogExportFeatureUsage = components['schemas']['CloudProviderAccessPushBasedLogExportFeatureUsage'];
export type CloudProviderAccessRole = components['schemas']['CloudProviderAccessRole'];
export type CloudProviderAccessRoleRequestUpdate = components['schemas']['CloudProviderAccessRoleRequestUpdate'];
export type CloudProviderAzureAutoScaling = components['schemas']['CloudProviderAzureAutoScaling'];
export type CloudProviderContainer = components['schemas']['CloudProviderContainer'];
export type CloudProviderGcpAutoScaling = components['schemas']['CloudProviderGCPAutoScaling'];
export type CloudRegionConfig = components['schemas']['CloudRegionConfig'];
export type CloudRegionConfig20240805 = components['schemas']['CloudRegionConfig20240805'];
export type ClusterAlertView = components['schemas']['ClusterAlertView'];
export type ClusterConnectionStrings = components['schemas']['ClusterConnectionStrings'];
export type ClusterDescription20240805 = components['schemas']['ClusterDescription20240805'];
export type ClusterDescriptionConnectionStringsPrivateEndpoint = components['schemas']['ClusterDescriptionConnectionStringsPrivateEndpoint'];
export type ClusterDescriptionConnectionStringsPrivateEndpointEndpoint = components['schemas']['ClusterDescriptionConnectionStringsPrivateEndpointEndpoint'];
export type ClusterEventTypeViewAlertable = components['schemas']['ClusterEventTypeViewAlertable'];
export type ClusterFlexProviderSettings = components['schemas']['ClusterFlexProviderSettings'];
export type ClusterFreeAutoScaling = components['schemas']['ClusterFreeAutoScaling'];
export type ClusterFreeProviderSettings = components['schemas']['ClusterFreeProviderSettings'];
export type ClusterProviderSettings = components['schemas']['ClusterProviderSettings'];
export type ClusterSearchIndex = components['schemas']['ClusterSearchIndex'];
export type ComponentLabel = components['schemas']['ComponentLabel'];
export type CreateAwsEndpointRequest = components['schemas']['CreateAWSEndpointRequest'];
export type CreateAzureEndpointRequest = components['schemas']['CreateAzureEndpointRequest'];
export type CreateDataProcessRegionView = components['schemas']['CreateDataProcessRegionView'];
export type CreateEndpointRequest = components['schemas']['CreateEndpointRequest'];
export type CreateGcpEndpointGroupRequest = components['schemas']['CreateGCPEndpointGroupRequest'];
export type CreateGcpForwardingRuleRequest = components['schemas']['CreateGCPForwardingRuleRequest'];
export type CriteriaView = components['schemas']['CriteriaView'];
export type CustomCriteriaView = components['schemas']['CustomCriteriaView'];
export type DbRoleToExecute = components['schemas']['DBRoleToExecute'];
export type DlsIngestionSink = components['schemas']['DLSIngestionSink'];
export type DailyScheduleView = components['schemas']['DailyScheduleView'];
export type DataLakeAtlasStoreInstance = components['schemas']['DataLakeAtlasStoreInstance'];
export type DataLakeAtlasStoreReadConcern = components['schemas']['DataLakeAtlasStoreReadConcern'];
export type DataLakeAtlasStoreReadPreference = components['schemas']['DataLakeAtlasStoreReadPreference'];
export type DataLakeAtlasStoreReadPreferenceTag = components['schemas']['DataLakeAtlasStoreReadPreferenceTag'];
export type DataLakeAzureBlobStore = components['schemas']['DataLakeAzureBlobStore'];
export type DataLakeDlsawsStore = components['schemas']['DataLakeDLSAWSStore'];
export type DataLakeDlsAzureStore = components['schemas']['DataLakeDLSAzureStore'];
export type DataLakeDlsgcpStore = components['schemas']['DataLakeDLSGCPStore'];
export type DataLakeGoogleCloudStorageStore = components['schemas']['DataLakeGoogleCloudStorageStore'];
export type DataLakeHttpStore = components['schemas']['DataLakeHTTPStore'];
export type DataLakePipelinesPartitionField = components['schemas']['DataLakePipelinesPartitionField'];
export type DataLakeS3StoreSettings = components['schemas']['DataLakeS3StoreSettings'];
export type DataLakeStoreSettings = components['schemas']['DataLakeStoreSettings'];
export type DataMetricAlertView = components['schemas']['DataMetricAlertView'];
export type DataMetricUnits = components['schemas']['DataMetricUnits'];
export type DataMetricValueView = components['schemas']['DataMetricValueView'];
export type DataProcessRegionView = components['schemas']['DataProcessRegionView'];
export type DatabaseUserRole = components['schemas']['DatabaseUserRole'];
export type DateCriteriaView = components['schemas']['DateCriteriaView'];
export type DedicatedHardwareSpec = components['schemas']['DedicatedHardwareSpec'];
export type DedicatedHardwareSpec20240805 = components['schemas']['DedicatedHardwareSpec20240805'];
export type DefaultAlertViewForNdsGroup = components['schemas']['DefaultAlertViewForNdsGroup'];
export type DefaultScheduleView = components['schemas']['DefaultScheduleView'];
export type DiskBackupSnapshotAwsExportBucketRequest = components['schemas']['DiskBackupSnapshotAWSExportBucketRequest'];
export type DiskBackupSnapshotAwsExportBucketResponse = components['schemas']['DiskBackupSnapshotAWSExportBucketResponse'];
export type DiskBackupSnapshotAzureExportBucketRequest = components['schemas']['DiskBackupSnapshotAzureExportBucketRequest'];
export type DiskBackupSnapshotAzureExportBucketResponse = components['schemas']['DiskBackupSnapshotAzureExportBucketResponse'];
export type DiskBackupSnapshotExportBucketRequest = components['schemas']['DiskBackupSnapshotExportBucketRequest'];
export type DiskBackupSnapshotExportBucketResponse = components['schemas']['DiskBackupSnapshotExportBucketResponse'];
export type DiskBackupSnapshotGcpExportBucketRequest = components['schemas']['DiskBackupSnapshotGCPExportBucketRequest'];
export type DiskBackupSnapshotGcpExportBucketResponse = components['schemas']['DiskBackupSnapshotGCPExportBucketResponse'];
export type DiskGbAutoScaling = components['schemas']['DiskGBAutoScaling'];
export type EmployeeAccessGrantView = components['schemas']['EmployeeAccessGrantView'];
export type FieldViolation = components['schemas']['FieldViolation'];
export type Fields = components['schemas']['Fields'];
export type FlexBackupSettings20241113 = components['schemas']['FlexBackupSettings20241113'];
export type FlexClusterDescription20241113 = components['schemas']['FlexClusterDescription20241113'];
export type FlexClusterDescriptionCreate20241113 = components['schemas']['FlexClusterDescriptionCreate20241113'];
export type FlexConnectionStrings20241113 = components['schemas']['FlexConnectionStrings20241113'];
export type FlexProviderSettings20241113 = components['schemas']['FlexProviderSettings20241113'];
export type FlexProviderSettingsCreate20241113 = components['schemas']['FlexProviderSettingsCreate20241113'];
export type FreeComputeAutoScalingRules = components['schemas']['FreeComputeAutoScalingRules'];
export type GcpCloudProviderContainer = components['schemas']['GCPCloudProviderContainer'];
export type GcpComputeAutoScaling = components['schemas']['GCPComputeAutoScaling'];
export type GcpCreateDataProcessRegionView = components['schemas']['GCPCreateDataProcessRegionView'];
export type GcpDataProcessRegionView = components['schemas']['GCPDataProcessRegionView'];
export type GcpHardwareSpec = components['schemas']['GCPHardwareSpec'];
export type GcpHardwareSpec20240805 = components['schemas']['GCPHardwareSpec20240805'];
export type GcpRegionConfig = components['schemas']['GCPRegionConfig'];
export type GcpRegionConfig20240805 = components['schemas']['GCPRegionConfig20240805'];
export type Group = components['schemas']['Group'];
export type GroupActiveUserResponse = components['schemas']['GroupActiveUserResponse'];
export type GroupPendingUserResponse = components['schemas']['GroupPendingUserResponse'];
export type GroupRoleAssignment = components['schemas']['GroupRoleAssignment'];
export type GroupUserResponse = components['schemas']['GroupUserResponse'];
export type HardwareSpec = components['schemas']['HardwareSpec'];
export type HardwareSpec20240805 = components['schemas']['HardwareSpec20240805'];
export type HostAlertViewForNdsGroup = components['schemas']['HostAlertViewForNdsGroup'];
export type HostEventTypeViewForNdsGroupAlertable = components['schemas']['HostEventTypeViewForNdsGroupAlertable'];
export type HostMetricAlert = components['schemas']['HostMetricAlert'];
export type HostMetricEventTypeViewAlertable = components['schemas']['HostMetricEventTypeViewAlertable'];
export type HostMetricValue = components['schemas']['HostMetricValue'];
export type IngestionSink = components['schemas']['IngestionSink'];
export type IngestionSource = components['schemas']['IngestionSource'];
export type InvoiceLineItem = components['schemas']['InvoiceLineItem'];
export type Link = components['schemas']['Link'];
export type MonthlyScheduleView = components['schemas']['MonthlyScheduleView'];
export type NetworkPermissionEntry = components['schemas']['NetworkPermissionEntry'];
export type NumberMetricAlertView = components['schemas']['NumberMetricAlertView'];
export type NumberMetricUnits = components['schemas']['NumberMetricUnits'];
export type NumberMetricValueView = components['schemas']['NumberMetricValueView'];
export type OnDemandCpsSnapshotSource = components['schemas']['OnDemandCpsSnapshotSource'];
export type OnlineArchiveSchedule = components['schemas']['OnlineArchiveSchedule'];
export type OrgActiveUserResponse = components['schemas']['OrgActiveUserResponse'];
export type OrgGroup = components['schemas']['OrgGroup'];
export type OrgPendingUserResponse = components['schemas']['OrgPendingUserResponse'];
export type OrgUserResponse = components['schemas']['OrgUserResponse'];
export type OrgUserRolesResponse = components['schemas']['OrgUserRolesResponse'];
export type PaginatedAlertView = components['schemas']['PaginatedAlertView'];
export type PaginatedApiAtlasDatabaseUserView = components['schemas']['PaginatedApiAtlasDatabaseUserView'];
export type PaginatedAtlasGroupView = components['schemas']['PaginatedAtlasGroupView'];
export type PaginatedClusterDescription20240805 = components['schemas']['PaginatedClusterDescription20240805'];
export type PaginatedFlexClusters20241113 = components['schemas']['PaginatedFlexClusters20241113'];
export type PaginatedNetworkAccessView = components['schemas']['PaginatedNetworkAccessView'];
export type PaginatedOrgGroupView = components['schemas']['PaginatedOrgGroupView'];
export type PaginatedOrganizationView = components['schemas']['PaginatedOrganizationView'];
export type PeriodicCpsSnapshotSource = components['schemas']['PeriodicCpsSnapshotSource'];
export type RawMetricAlertView = components['schemas']['RawMetricAlertView'];
export type RawMetricUnits = components['schemas']['RawMetricUnits'];
export type RawMetricValueView = components['schemas']['RawMetricValueView'];
export type ReplicaSetAlertViewForNdsGroup = components['schemas']['ReplicaSetAlertViewForNdsGroup'];
export type ReplicaSetEventTypeViewForNdsGroupAlertable = components['schemas']['ReplicaSetEventTypeViewForNdsGroupAlertable'];
export type ReplicationSpec20240805 = components['schemas']['ReplicationSpec20240805'];
export type ResourceTag = components['schemas']['ResourceTag'];
export type SearchHostStatusDetail = components['schemas']['SearchHostStatusDetail'];
export type SearchIndex = components['schemas']['SearchIndex'];
export type SearchIndexCreateRequest = components['schemas']['SearchIndexCreateRequest'];
export type SearchIndexDefinition = components['schemas']['SearchIndexDefinition'];
export type SearchIndexDefinitionVersion = components['schemas']['SearchIndexDefinitionVersion'];
export type SearchIndexResponse = components['schemas']['SearchIndexResponse'];
export type SearchMainIndexStatusDetail = components['schemas']['SearchMainIndexStatusDetail'];
export type SearchMappings = components['schemas']['SearchMappings'];
export type SearchStagedIndexStatusDetail = components['schemas']['SearchStagedIndexStatusDetail'];
export type SearchSynonymMappingDefinition = components['schemas']['SearchSynonymMappingDefinition'];
export type ServerlessAwsTenantEndpointUpdate = components['schemas']['ServerlessAWSTenantEndpointUpdate'];
export type ServerlessAzureTenantEndpointUpdate = components['schemas']['ServerlessAzureTenantEndpointUpdate'];
export type ServerlessTenantEndpointUpdate = components['schemas']['ServerlessTenantEndpointUpdate'];
export type StreamProcessorAlertViewForNdsGroup = components['schemas']['StreamProcessorAlertViewForNdsGroup'];
export type StreamsAwsConnectionConfig = components['schemas']['StreamsAWSConnectionConfig'];
export type StreamsAwsLambdaConnection = components['schemas']['StreamsAWSLambdaConnection'];
export type StreamsClusterConnection = components['schemas']['StreamsClusterConnection'];
export type StreamsConnection = components['schemas']['StreamsConnection'];
export type StreamsHttpsConnection = components['schemas']['StreamsHttpsConnection'];
export type StreamsKafkaAuthentication = components['schemas']['StreamsKafkaAuthentication'];
export type StreamsKafkaConnection = components['schemas']['StreamsKafkaConnection'];
export type StreamsKafkaNetworking = components['schemas']['StreamsKafkaNetworking'];
export type StreamsKafkaNetworkingAccess = components['schemas']['StreamsKafkaNetworkingAccess'];
export type StreamsKafkaSecurity = components['schemas']['StreamsKafkaSecurity'];
export type StreamsS3Connection = components['schemas']['StreamsS3Connection'];
export type StreamsSampleConnection = components['schemas']['StreamsSampleConnection'];
export type SynonymMappingStatusDetail = components['schemas']['SynonymMappingStatusDetail'];
export type SynonymMappingStatusDetailMap = components['schemas']['SynonymMappingStatusDetailMap'];
export type SynonymSource = components['schemas']['SynonymSource'];
export type TenantHardwareSpec = components['schemas']['TenantHardwareSpec'];
export type TenantHardwareSpec20240805 = components['schemas']['TenantHardwareSpec20240805'];
export type TenantRegionConfig = components['schemas']['TenantRegionConfig'];
export type TenantRegionConfig20240805 = components['schemas']['TenantRegionConfig20240805'];
export type TextSearchHostStatusDetail = components['schemas']['TextSearchHostStatusDetail'];
export type TextSearchIndexCreateRequest = components['schemas']['TextSearchIndexCreateRequest'];
export type TextSearchIndexDefinition = components['schemas']['TextSearchIndexDefinition'];
export type TextSearchIndexResponse = components['schemas']['TextSearchIndexResponse'];
export type TextSearchIndexStatusDetail = components['schemas']['TextSearchIndexStatusDetail'];
export type TimeMetricAlertView = components['schemas']['TimeMetricAlertView'];
export type TimeMetricUnits = components['schemas']['TimeMetricUnits'];
export type TimeMetricValueView = components['schemas']['TimeMetricValueView'];
export type TokenFilterEnglishPossessive = components['schemas']['TokenFilterEnglishPossessive'];
export type TokenFilterFlattenGraph = components['schemas']['TokenFilterFlattenGraph'];
export type TokenFilterPorterStemming = components['schemas']['TokenFilterPorterStemming'];
export type TokenFilterSpanishPluralStemming = components['schemas']['TokenFilterSpanishPluralStemming'];
export type TokenFilterStempel = components['schemas']['TokenFilterStempel'];
export type TokenFilterWordDelimiterGraph = components['schemas']['TokenFilterWordDelimiterGraph'];
export type TokenFilterkStemming = components['schemas']['TokenFilterkStemming'];
export type UserScope = components['schemas']['UserScope'];
export type VectorSearchHostStatusDetail = components['schemas']['VectorSearchHostStatusDetail'];
export type VectorSearchIndex = components['schemas']['VectorSearchIndex'];
export type VectorSearchIndexCreateRequest = components['schemas']['VectorSearchIndexCreateRequest'];
export type VectorSearchIndexDefinition = components['schemas']['VectorSearchIndexDefinition'];
export type VectorSearchIndexResponse = components['schemas']['VectorSearchIndexResponse'];
export type VectorSearchIndexStatusDetail = components['schemas']['VectorSearchIndexStatusDetail'];
export type WeeklyScheduleView = components['schemas']['WeeklyScheduleView'];
export type CharFilterhtmlStrip = components['schemas']['charFilterhtmlStrip'];
export type CharFiltericuNormalize = components['schemas']['charFiltericuNormalize'];
export type CharFiltermapping = components['schemas']['charFiltermapping'];
export type CharFilterpersian = components['schemas']['charFilterpersian'];
export type TokenFilterasciiFolding = components['schemas']['tokenFilterasciiFolding'];
export type TokenFilterdaitchMokotoffSoundex = components['schemas']['tokenFilterdaitchMokotoffSoundex'];
export type TokenFilteredgeGram = components['schemas']['tokenFilteredgeGram'];
export type TokenFiltericuFolding = components['schemas']['tokenFiltericuFolding'];
export type TokenFiltericuNormalizer = components['schemas']['tokenFiltericuNormalizer'];
export type TokenFilterlength = components['schemas']['tokenFilterlength'];
export type TokenFilterlowercase = components['schemas']['tokenFilterlowercase'];
export type TokenFilternGram = components['schemas']['tokenFilternGram'];
export type TokenFilterregex = components['schemas']['tokenFilterregex'];
export type TokenFilterreverse = components['schemas']['tokenFilterreverse'];
export type TokenFiltershingle = components['schemas']['tokenFiltershingle'];
export type TokenFiltersnowballStemming = components['schemas']['tokenFiltersnowballStemming'];
export type TokenFilterstopword = components['schemas']['tokenFilterstopword'];
export type TokenFiltertrim = components['schemas']['tokenFiltertrim'];
export type TokenizeredgeGram = components['schemas']['tokenizeredgeGram'];
export type Tokenizerkeyword = components['schemas']['tokenizerkeyword'];
export type TokenizernGram = components['schemas']['tokenizernGram'];
export type TokenizerregexCaptureGroup = components['schemas']['tokenizerregexCaptureGroup'];
export type TokenizerregexSplit = components['schemas']['tokenizerregexSplit'];
export type Tokenizerstandard = components['schemas']['tokenizerstandard'];
export type TokenizeruaxUrlEmail = components['schemas']['tokenizeruaxUrlEmail'];
export type Tokenizerwhitespace = components['schemas']['tokenizerwhitespace'];
export type ResponseBadRequest = components['responses']['badRequest'];
export type ResponseConflict = components['responses']['conflict'];
export type ResponseForbidden = components['responses']['forbidden'];
export type ResponseInternalServerError = components['responses']['internalServerError'];
export type ResponseNotFound = components['responses']['notFound'];
export type ResponsePaymentRequired = components['responses']['paymentRequired'];
export type ResponseUnauthorized = components['responses']['unauthorized'];
export type ParameterEnvelope = components['parameters']['envelope'];
export type ParameterGroupId = components['parameters']['groupId'];
export type ParameterIncludeCount = components['parameters']['includeCount'];
export type ParameterItemsPerPage = components['parameters']['itemsPerPage'];
export type ParameterOrgId = components['parameters']['orgId'];
export type ParameterPageNum = components['parameters']['pageNum'];
export type ParameterPretty = components['parameters']['pretty'];
export type $defs = Record<string, never>;
export interface operations {
    listClustersForAllProjects: {
        parameters: {
            query?: {
                /** @description Flag that indicates whether Application wraps the response in an `envelope` JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope=true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body. */
                envelope?: components["parameters"]["envelope"];
                /** @description Flag that indicates whether the response returns the total number of items (**totalCount**) in the response. */
                includeCount?: components["parameters"]["includeCount"];
                /** @description Number of items that the response returns per page. */
                itemsPerPage?: components["parameters"]["itemsPerPage"];
                /** @description Number of the page that displays the current set of the total objects that the response returns. */
                pageNum?: components["parameters"]["pageNum"];
                /** @description Flag that indicates whether the response body should be in the prettyprint format. */
                pretty?: components["parameters"]["pretty"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/vnd.atlas.2023-01-01+json": components["schemas"]["PaginatedOrgGroupView"];
                };
            };
            401: components["responses"]["unauthorized"];
            403: components["responses"]["forbidden"];
            500: components["responses"]["internalServerError"];
        };
    };
    listProjects: {
        parameters: {
            query?: {
                /** @description Flag that indicates whether Application wraps the response in an `envelope` JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope=true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body. */
                envelope?: components["parameters"]["envelope"];
                /** @description Flag that indicates whether the response returns the total number of items (**totalCount**) in the response. */
                includeCount?: components["parameters"]["includeCount"];
                /** @description Number of items that the response returns per page. */
                itemsPerPage?: components["parameters"]["itemsPerPage"];
                /** @description Number of the page that displays the current set of the total objects that the response returns. */
                pageNum?: components["parameters"]["pageNum"];
                /** @description Flag that indicates whether the response body should be in the prettyprint format. */
                pretty?: components["parameters"]["pretty"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/vnd.atlas.2023-01-01+json": components["schemas"]["PaginatedAtlasGroupView"];
                };
            };
            400: components["responses"]["badRequest"];
            401: components["responses"]["unauthorized"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            500: components["responses"]["internalServerError"];
        };
    };
    createProject: {
        parameters: {
            query?: {
                /** @description Flag that indicates whether Application wraps the response in an `envelope` JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope=true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body. */
                envelope?: components["parameters"]["envelope"];
                /** @description Flag that indicates whether the response body should be in the prettyprint format. */
                pretty?: components["parameters"]["pretty"];
                /** @description Unique 24-hexadecimal digit string that identifies the MongoDB Cloud user to whom to grant the Project Owner role on the specified project. If you set this parameter, it overrides the default value of the oldest Organization Owner. */
                projectOwnerId?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Creates one project. */
        requestBody: {
            content: {
                "application/vnd.atlas.2023-01-01+json": components["schemas"]["Group"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/vnd.atlas.2023-01-01+json": components["schemas"]["Group"];
                };
            };
            400: components["responses"]["badRequest"];
            401: components["responses"]["unauthorized"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            409: components["responses"]["conflict"];
            500: components["responses"]["internalServerError"];
        };
    };
    getProject: {
        parameters: {
            query?: {
                /** @description Flag that indicates whether Application wraps the response in an `envelope` JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope=true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body. */
                envelope?: components["parameters"]["envelope"];
                /** @description Flag that indicates whether the response body should be in the prettyprint format. */
                pretty?: components["parameters"]["pretty"];
            };
            header?: never;
            path: {
                /** @description Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.
                 *
                 *     **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/vnd.atlas.2023-01-01+json": components["schemas"]["Group"];
                };
            };
            400: components["responses"]["badRequest"];
            401: components["responses"]["unauthorized"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            500: components["responses"]["internalServerError"];
        };
    };
    deleteProject: {
        parameters: {
            query?: {
                /** @description Flag that indicates whether Application wraps the response in an `envelope` JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope=true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body. */
                envelope?: components["parameters"]["envelope"];
                /** @description Flag that indicates whether the response body should be in the prettyprint format. */
                pretty?: components["parameters"]["pretty"];
            };
            header?: never;
            path: {
                /** @description Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.
                 *
                 *     **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description This endpoint does not return a response body. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/vnd.atlas.2023-01-01+json": unknown;
                };
            };
            400: components["responses"]["badRequest"];
            401: components["responses"]["unauthorized"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            409: components["responses"]["conflict"];
            500: components["responses"]["internalServerError"];
        };
    };
    listProjectIpAccessLists: {
        parameters: {
            query?: {
                /** @description Flag that indicates whether Application wraps the response in an `envelope` JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope=true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body. */
                envelope?: components["parameters"]["envelope"];
                /** @description Flag that indicates whether the response returns the total number of items (**totalCount**) in the response. */
                includeCount?: components["parameters"]["includeCount"];
                /** @description Number of items that the response returns per page. */
                itemsPerPage?: components["parameters"]["itemsPerPage"];
                /** @description Number of the page that displays the current set of the total objects that the response returns. */
                pageNum?: components["parameters"]["pageNum"];
                /** @description Flag that indicates whether the response body should be in the prettyprint format. */
                pretty?: components["parameters"]["pretty"];
            };
            header?: never;
            path: {
                /** @description Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.
                 *
                 *     **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/vnd.atlas.2023-01-01+json": components["schemas"]["PaginatedNetworkAccessView"];
                };
            };
            401: components["responses"]["unauthorized"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            500: components["responses"]["internalServerError"];
        };
    };
    createProjectIpAccessList: {
        parameters: {
            query?: {
                /** @description Flag that indicates whether Application wraps the response in an `envelope` JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope=true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body. */
                envelope?: components["parameters"]["envelope"];
                /** @description Flag that indicates whether the response returns the total number of items (**totalCount**) in the response. */
                includeCount?: components["parameters"]["includeCount"];
                /** @description Number of items that the response returns per page. */
                itemsPerPage?: components["parameters"]["itemsPerPage"];
                /** @description Number of the page that displays the current set of the total objects that the response returns. */
                pageNum?: components["parameters"]["pageNum"];
                /** @description Flag that indicates whether the response body should be in the prettyprint format. */
                pretty?: components["parameters"]["pretty"];
            };
            header?: never;
            path: {
                /** @description Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.
                 *
                 *     **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        /** @description One or more access list entries to add to the specified project. */
        requestBody: {
            content: {
                "application/vnd.atlas.2023-01-01+json": components["schemas"]["NetworkPermissionEntry"][];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/vnd.atlas.2023-01-01+json": components["schemas"]["PaginatedNetworkAccessView"];
                };
            };
            400: components["responses"]["badRequest"];
            401: components["responses"]["unauthorized"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            500: components["responses"]["internalServerError"];
        };
    };
    deleteProjectIpAccessList: {
        parameters: {
            query?: {
                /** @description Flag that indicates whether Application wraps the response in an `envelope` JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope=true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body. */
                envelope?: components["parameters"]["envelope"];
                /** @description Flag that indicates whether the response body should be in the prettyprint format. */
                pretty?: components["parameters"]["pretty"];
            };
            header?: never;
            path: {
                /** @description Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.
                 *
                 *     **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups. */
                groupId: components["parameters"]["groupId"];
                /** @description Access list entry that you want to remove from the project's IP access list. This value can use one of the following: one AWS security group ID, one IP address, or one CIDR block of addresses. For CIDR blocks that use a subnet mask, replace the forward slash (`/`) with its URL-encoded value (`%2F`). When you remove an entry from the IP access list, existing connections from the removed address or addresses may remain open for a variable amount of time. The amount of time it takes MongoDB Cloud to close the connection depends upon several factors, including:
                 *
                 *     - how your application established the connection,
                 *     - how MongoDB Cloud or the driver using the address behaves, and
                 *     - which protocol (like TCP or UDP) the connection uses. */
                entryValue: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description This endpoint does not return a response body. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/vnd.atlas.2023-01-01+json": unknown;
                };
            };
            401: components["responses"]["unauthorized"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            500: components["responses"]["internalServerError"];
        };
    };
    listAlerts: {
        parameters: {
            query?: {
                /** @description Flag that indicates whether Application wraps the response in an `envelope` JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope=true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body. */
                envelope?: components["parameters"]["envelope"];
                /** @description Flag that indicates whether the response returns the total number of items (**totalCount**) in the response. */
                includeCount?: components["parameters"]["includeCount"];
                /** @description Number of items that the response returns per page. */
                itemsPerPage?: components["parameters"]["itemsPerPage"];
                /** @description Number of the page that displays the current set of the total objects that the response returns. */
                pageNum?: components["parameters"]["pageNum"];
                /** @description Flag that indicates whether the response body should be in the prettyprint format. */
                pretty?: components["parameters"]["pretty"];
                /** @description Status of the alerts to return. Omit to return all alerts in all statuses. */
                status?: "OPEN" | "TRACKING" | "CLOSED";
            };
            header?: never;
            path: {
                /** @description Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.
                 *
                 *     **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/vnd.atlas.2023-01-01+json": components["schemas"]["PaginatedAlertView"];
                };
            };
            400: components["responses"]["badRequest"];
            401: components["responses"]["unauthorized"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            500: components["responses"]["internalServerError"];
        };
    };
    listClusters: {
        parameters: {
            query?: {
                /** @description Flag that indicates whether Application wraps the response in an `envelope` JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope=true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body. */
                envelope?: components["parameters"]["envelope"];
                /** @description Flag that indicates whether the response returns the total number of items (**totalCount**) in the response. */
                includeCount?: components["parameters"]["includeCount"];
                /** @description Number of items that the response returns per page. */
                itemsPerPage?: components["parameters"]["itemsPerPage"];
                /** @description Number of the page that displays the current set of the total objects that the response returns. */
                pageNum?: components["parameters"]["pageNum"];
                /** @description Flag that indicates whether the response body should be in the prettyprint format. */
                pretty?: components["parameters"]["pretty"];
                /** @description Flag that indicates whether to return Clusters with retain backups. */
                includeDeletedWithRetainedBackups?: boolean;
            };
            header?: never;
            path: {
                /** @description Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.
                 *
                 *     **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/vnd.atlas.2024-08-05+json": components["schemas"]["PaginatedClusterDescription20240805"];
                };
            };
            401: components["responses"]["unauthorized"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            500: components["responses"]["internalServerError"];
        };
    };
    createCluster: {
        parameters: {
            query?: {
                /** @description Flag that indicates whether Application wraps the response in an `envelope` JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope=true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body. */
                envelope?: components["parameters"]["envelope"];
                /** @description Flag that indicates whether the response body should be in the prettyprint format. */
                pretty?: components["parameters"]["pretty"];
            };
            header?: never;
            path: {
                /** @description Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.
                 *
                 *     **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        /** @description Cluster to create in this project. */
        requestBody: {
            content: {
                "application/vnd.atlas.2024-10-23+json": components["schemas"]["ClusterDescription20240805"];
            };
        };
        responses: {
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/vnd.atlas.2024-10-23+json": components["schemas"]["ClusterDescription20240805"];
                };
            };
            400: components["responses"]["badRequest"];
            401: components["responses"]["unauthorized"];
            402: components["responses"]["paymentRequired"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            409: components["responses"]["conflict"];
            500: components["responses"]["internalServerError"];
        };
    };
    getCluster: {
        parameters: {
            query?: {
                /** @description Flag that indicates whether Application wraps the response in an `envelope` JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope=true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body. */
                envelope?: components["parameters"]["envelope"];
                /** @description Flag that indicates whether the response body should be in the prettyprint format. */
                pretty?: components["parameters"]["pretty"];
            };
            header?: never;
            path: {
                /** @description Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.
                 *
                 *     **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups. */
                groupId: components["parameters"]["groupId"];
                /** @description Human-readable label that identifies this cluster. */
                clusterName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/vnd.atlas.2024-08-05+json": components["schemas"]["ClusterDescription20240805"];
                };
            };
            401: components["responses"]["unauthorized"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            409: components["responses"]["conflict"];
            500: components["responses"]["internalServerError"];
        };
    };
    deleteCluster: {
        parameters: {
            query?: {
                /** @description Flag that indicates whether Application wraps the response in an `envelope` JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope=true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body. */
                envelope?: components["parameters"]["envelope"];
                /** @description Flag that indicates whether the response body should be in the prettyprint format. */
                pretty?: components["parameters"]["pretty"];
                /** @description Flag that indicates whether to retain backup snapshots for the deleted dedicated cluster. */
                retainBackups?: boolean;
            };
            header?: never;
            path: {
                /** @description Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.
                 *
                 *     **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups. */
                groupId: components["parameters"]["groupId"];
                /** @description Human-readable label that identifies the cluster. */
                clusterName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Accepted */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/vnd.atlas.2023-02-01+json": unknown;
                };
            };
            400: components["responses"]["badRequest"];
            401: components["responses"]["unauthorized"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            409: components["responses"]["conflict"];
            500: components["responses"]["internalServerError"];
        };
    };
    listDatabaseUsers: {
        parameters: {
            query?: {
                /** @description Flag that indicates whether Application wraps the response in an `envelope` JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope=true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body. */
                envelope?: components["parameters"]["envelope"];
                /** @description Flag that indicates whether the response returns the total number of items (**totalCount**) in the response. */
                includeCount?: components["parameters"]["includeCount"];
                /** @description Number of items that the response returns per page. */
                itemsPerPage?: components["parameters"]["itemsPerPage"];
                /** @description Number of the page that displays the current set of the total objects that the response returns. */
                pageNum?: components["parameters"]["pageNum"];
                /** @description Flag that indicates whether the response body should be in the prettyprint format. */
                pretty?: components["parameters"]["pretty"];
            };
            header?: never;
            path: {
                /** @description Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.
                 *
                 *     **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/vnd.atlas.2023-01-01+json": components["schemas"]["PaginatedApiAtlasDatabaseUserView"];
                };
            };
            401: components["responses"]["unauthorized"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            500: components["responses"]["internalServerError"];
        };
    };
    createDatabaseUser: {
        parameters: {
            query?: {
                /** @description Flag that indicates whether Application wraps the response in an `envelope` JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope=true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body. */
                envelope?: components["parameters"]["envelope"];
                /** @description Flag that indicates whether the response body should be in the prettyprint format. */
                pretty?: components["parameters"]["pretty"];
            };
            header?: never;
            path: {
                /** @description Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.
                 *
                 *     **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        /** @description Creates one database user in the specified project. */
        requestBody: {
            content: {
                "application/vnd.atlas.2023-01-01+json": components["schemas"]["CloudDatabaseUser"];
            };
        };
        responses: {
            /** @description OK */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/vnd.atlas.2023-01-01+json": components["schemas"]["CloudDatabaseUser"];
                };
            };
            400: components["responses"]["badRequest"];
            401: components["responses"]["unauthorized"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            409: components["responses"]["conflict"];
            500: components["responses"]["internalServerError"];
        };
    };
    deleteDatabaseUser: {
        parameters: {
            query?: {
                /** @description Flag that indicates whether Application wraps the response in an `envelope` JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope=true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body. */
                envelope?: components["parameters"]["envelope"];
                /** @description Flag that indicates whether the response body should be in the prettyprint format. */
                pretty?: components["parameters"]["pretty"];
            };
            header?: never;
            path: {
                /** @description Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.
                 *
                 *     **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups. */
                groupId: components["parameters"]["groupId"];
                /** @description The database against which the database user authenticates. Database users must provide both a username and authentication database to log into MongoDB. If the user authenticates with AWS IAM, x.509, LDAP, or OIDC Workload this value should be `$external`. If the user authenticates with SCRAM-SHA or OIDC Workforce, this value should be `admin`. */
                databaseName: string;
                /** @description Human-readable label that represents the user that authenticates to MongoDB. The format of this label depends on the method of authentication:
                 *
                 *     | Authentication Method | Parameter Needed | Parameter Value | username Format |
                 *     |---|---|---|---|
                 *     | AWS IAM | awsIAMType | ROLE | <abbr title="Amazon Resource Name">ARN</abbr> |
                 *     | AWS IAM | awsIAMType | USER | <abbr title="Amazon Resource Name">ARN</abbr> |
                 *     | x.509 | x509Type | CUSTOMER | [RFC 2253](https://tools.ietf.org/html/2253) Distinguished Name |
                 *     | x.509 | x509Type | MANAGED | [RFC 2253](https://tools.ietf.org/html/2253) Distinguished Name |
                 *     | LDAP | ldapAuthType | USER | [RFC 2253](https://tools.ietf.org/html/2253) Distinguished Name |
                 *     | LDAP | ldapAuthType | GROUP | [RFC 2253](https://tools.ietf.org/html/2253) Distinguished Name |
                 *     | OIDC Workforce | oidcAuthType | IDP_GROUP | Atlas OIDC IdP ID (found in federation settings), followed by a '/', followed by the IdP group name |
                 *     | OIDC Workload | oidcAuthType | USER | Atlas OIDC IdP ID (found in federation settings), followed by a '/', followed by the IdP user name |
                 *     | SCRAM-SHA | awsIAMType, x509Type, ldapAuthType, oidcAuthType | NONE | Alphanumeric string |
                 *      */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description This endpoint does not return a response body. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/vnd.atlas.2023-01-01+json": unknown;
                };
            };
            401: components["responses"]["unauthorized"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            500: components["responses"]["internalServerError"];
        };
    };
    listFlexClusters: {
        parameters: {
            query?: {
                /** @description Flag that indicates whether Application wraps the response in an `envelope` JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope=true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body. */
                envelope?: components["parameters"]["envelope"];
                /** @description Flag that indicates whether the response returns the total number of items (**totalCount**) in the response. */
                includeCount?: components["parameters"]["includeCount"];
                /** @description Number of items that the response returns per page. */
                itemsPerPage?: components["parameters"]["itemsPerPage"];
                /** @description Number of the page that displays the current set of the total objects that the response returns. */
                pageNum?: components["parameters"]["pageNum"];
                /** @description Flag that indicates whether the response body should be in the prettyprint format. */
                pretty?: components["parameters"]["pretty"];
            };
            header?: never;
            path: {
                /** @description Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.
                 *
                 *     **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/vnd.atlas.2024-11-13+json": components["schemas"]["PaginatedFlexClusters20241113"];
                };
            };
            401: components["responses"]["unauthorized"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            409: components["responses"]["conflict"];
            500: components["responses"]["internalServerError"];
        };
    };
    createFlexCluster: {
        parameters: {
            query?: {
                /** @description Flag that indicates whether Application wraps the response in an `envelope` JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope=true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body. */
                envelope?: components["parameters"]["envelope"];
                /** @description Flag that indicates whether the response body should be in the prettyprint format. */
                pretty?: components["parameters"]["pretty"];
            };
            header?: never;
            path: {
                /** @description Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.
                 *
                 *     **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        /** @description Create One Flex Cluster in One Project. */
        requestBody: {
            content: {
                "application/vnd.atlas.2024-11-13+json": components["schemas"]["FlexClusterDescriptionCreate20241113"];
            };
        };
        responses: {
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/vnd.atlas.2024-11-13+json": components["schemas"]["FlexClusterDescription20241113"];
                };
            };
            400: components["responses"]["badRequest"];
            401: components["responses"]["unauthorized"];
            402: components["responses"]["paymentRequired"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            409: components["responses"]["conflict"];
            500: components["responses"]["internalServerError"];
        };
    };
    getFlexCluster: {
        parameters: {
            query?: {
                /** @description Flag that indicates whether Application wraps the response in an `envelope` JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope=true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body. */
                envelope?: components["parameters"]["envelope"];
                /** @description Flag that indicates whether the response body should be in the prettyprint format. */
                pretty?: components["parameters"]["pretty"];
            };
            header?: never;
            path: {
                /** @description Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.
                 *
                 *     **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups. */
                groupId: components["parameters"]["groupId"];
                /** @description Human-readable label that identifies the flex cluster. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/vnd.atlas.2024-11-13+json": components["schemas"]["FlexClusterDescription20241113"];
                };
            };
            400: components["responses"]["badRequest"];
            401: components["responses"]["unauthorized"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            409: components["responses"]["conflict"];
            500: components["responses"]["internalServerError"];
        };
    };
    deleteFlexCluster: {
        parameters: {
            query?: {
                /** @description Flag that indicates whether Application wraps the response in an `envelope` JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope=true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body. */
                envelope?: components["parameters"]["envelope"];
                /** @description Flag that indicates whether the response body should be in the prettyprint format. */
                pretty?: components["parameters"]["pretty"];
            };
            header?: never;
            path: {
                /** @description Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.
                 *
                 *     **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups. */
                groupId: components["parameters"]["groupId"];
                /** @description Human-readable label that identifies the flex cluster. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description This endpoint does not return a response body. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/vnd.atlas.2024-11-13+json": unknown;
                };
            };
            400: components["responses"]["badRequest"];
            401: components["responses"]["unauthorized"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            409: components["responses"]["conflict"];
            500: components["responses"]["internalServerError"];
        };
    };
    listOrganizations: {
        parameters: {
            query?: {
                /** @description Flag that indicates whether Application wraps the response in an `envelope` JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope=true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body. */
                envelope?: components["parameters"]["envelope"];
                /** @description Flag that indicates whether the response returns the total number of items (**totalCount**) in the response. */
                includeCount?: components["parameters"]["includeCount"];
                /** @description Number of items that the response returns per page. */
                itemsPerPage?: components["parameters"]["itemsPerPage"];
                /** @description Number of the page that displays the current set of the total objects that the response returns. */
                pageNum?: components["parameters"]["pageNum"];
                /** @description Flag that indicates whether the response body should be in the prettyprint format. */
                pretty?: components["parameters"]["pretty"];
                /** @description Human-readable label of the organization to use to filter the returned list. Performs a case-insensitive search for an organization that starts with the specified name. */
                name?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/vnd.atlas.2023-01-01+json": components["schemas"]["PaginatedOrganizationView"];
                };
            };
            400: components["responses"]["badRequest"];
            401: components["responses"]["unauthorized"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            409: components["responses"]["conflict"];
            500: components["responses"]["internalServerError"];
        };
    };
    listOrganizationProjects: {
        parameters: {
            query?: {
                /** @description Flag that indicates whether Application wraps the response in an `envelope` JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope=true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body. */
                envelope?: components["parameters"]["envelope"];
                /** @description Flag that indicates whether the response returns the total number of items (**totalCount**) in the response. */
                includeCount?: components["parameters"]["includeCount"];
                /** @description Number of items that the response returns per page. */
                itemsPerPage?: components["parameters"]["itemsPerPage"];
                /** @description Number of the page that displays the current set of the total objects that the response returns. */
                pageNum?: components["parameters"]["pageNum"];
                /** @description Flag that indicates whether the response body should be in the prettyprint format. */
                pretty?: components["parameters"]["pretty"];
                /** @description Human-readable label of the project to use to filter the returned list. Performs a case-insensitive search for a project within the organization which is prefixed by the specified name. */
                name?: string;
            };
            header?: never;
            path: {
                /** @description Unique 24-hexadecimal digit string that identifies the organization that contains your projects. Use the [/orgs](#tag/Organizations/operation/listOrganizations) endpoint to retrieve all organizations to which the authenticated user has access. */
                orgId: components["parameters"]["orgId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/vnd.atlas.2023-01-01+json": components["schemas"]["PaginatedAtlasGroupView"];
                };
            };
            400: components["responses"]["badRequest"];
            401: components["responses"]["unauthorized"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            500: components["responses"]["internalServerError"];
        };
    };
}
type WithRequired<T, K extends keyof T> = T & {
    [P in K]-?: T[P];
};


## File: src/telemetry/constants.ts

import { packageInfo } from "../helpers/packageInfo.js";
import { type CommonStaticProperties } from "./types.js";

/**
 * Machine-specific metadata formatted for telemetry
 */
export const MACHINE_METADATA: CommonStaticProperties = {
    mcp_server_version: packageInfo.version,
    mcp_server_name: packageInfo.mcpServerName,
    platform: process.platform,
    arch: process.arch,
    os_type: process.platform,
    os_version: process.version,
} as const;


## File: src/telemetry/eventCache.ts

import { LRUCache } from "lru-cache";
import { BaseEvent } from "./types.js";

/**
 * Singleton class for in-memory telemetry event caching
 * Provides a central storage for telemetry events that couldn't be sent
 * Uses LRU cache to automatically drop oldest events when limit is exceeded
 */
export class EventCache {
    private static instance: EventCache;
    private static readonly MAX_EVENTS = 1000;

    private cache: LRUCache<number, BaseEvent>;
    private nextId = 0;

    constructor() {
        this.cache = new LRUCache({
            max: EventCache.MAX_EVENTS,
            // Using FIFO eviction strategy for events
            allowStale: false,
            updateAgeOnGet: false,
        });
    }

    /**
     * Gets the singleton instance of EventCache
     * @returns The EventCache instance
     */
    public static getInstance(): EventCache {
        if (!EventCache.instance) {
            EventCache.instance = new EventCache();
        }
        return EventCache.instance;
    }

    /**
     * Gets a copy of the currently cached events
     * @returns Array of cached BaseEvent objects
     */
    public getEvents(): BaseEvent[] {
        return Array.from(this.cache.values());
    }

    /**
     * Appends new events to the cached events
     * LRU cache automatically handles dropping oldest events when limit is exceeded
     * @param events - The events to append
     */
    public appendEvents(events: BaseEvent[]): void {
        for (const event of events) {
            this.cache.set(this.nextId++, event);
        }
    }

    /**
     * Clears all cached events
     */
    public clearEvents(): void {
        this.cache.clear();
        this.nextId = 0;
    }
}


## File: src/telemetry/telemetry.ts

import { Session } from "../session.js";
import { BaseEvent, CommonProperties } from "./types.js";
import { UserConfig } from "../config.js";
import logger, { LogId } from "../logger.js";
import { ApiClient } from "../common/atlas/apiClient.js";
import { MACHINE_METADATA } from "./constants.js";
import { EventCache } from "./eventCache.js";
import nodeMachineId from "node-machine-id";
import { getDeviceId } from "@mongodb-js/device-id";

type EventResult = {
    success: boolean;
    error?: Error;
};

export const DEVICE_ID_TIMEOUT = 3000;

export class Telemetry {
    private isBufferingEvents: boolean = true;
    /** Resolves when the device ID is retrieved or timeout occurs */
    public deviceIdPromise: Promise<string> | undefined;
    private deviceIdAbortController = new AbortController();
    private eventCache: EventCache;
    private getRawMachineId: () => Promise<string>;

    private constructor(
        private readonly session: Session,
        private readonly userConfig: UserConfig,
        private readonly commonProperties: CommonProperties,
        { eventCache, getRawMachineId }: { eventCache: EventCache; getRawMachineId: () => Promise<string> }
    ) {
        this.eventCache = eventCache;
        this.getRawMachineId = getRawMachineId;
    }

    static create(
        session: Session,
        userConfig: UserConfig,
        {
            commonProperties = { ...MACHINE_METADATA },
            eventCache = EventCache.getInstance(),
            getRawMachineId = () => nodeMachineId.machineId(true),
        }: {
            eventCache?: EventCache;
            getRawMachineId?: () => Promise<string>;
            commonProperties?: CommonProperties;
        } = {}
    ): Telemetry {
        const instance = new Telemetry(session, userConfig, commonProperties, { eventCache, getRawMachineId });

        void instance.start();
        return instance;
    }

    private async start(): Promise<void> {
        if (!this.isTelemetryEnabled()) {
            return;
        }
        this.deviceIdPromise = getDeviceId({
            getMachineId: () => this.getRawMachineId(),
            onError: (reason, error) => {
                switch (reason) {
                    case "resolutionError":
                        logger.debug(LogId.telemetryDeviceIdFailure, "telemetry", String(error));
                        break;
                    case "timeout":
                        logger.debug(LogId.telemetryDeviceIdTimeout, "telemetry", "Device ID retrieval timed out");
                        break;
                    case "abort":
                        // No need to log in the case of aborts
                        break;
                }
            },
            abortSignal: this.deviceIdAbortController.signal,
        });

        this.commonProperties.device_id = await this.deviceIdPromise;

        this.isBufferingEvents = false;
    }

    public async close(): Promise<void> {
        this.deviceIdAbortController.abort();
        this.isBufferingEvents = false;
        await this.emitEvents(this.eventCache.getEvents());
    }

    /**
     * Emits events through the telemetry pipeline
     * @param events - The events to emit
     */
    public async emitEvents(events: BaseEvent[]): Promise<void> {
        try {
            if (!this.isTelemetryEnabled()) {
                logger.info(LogId.telemetryEmitFailure, "telemetry", `Telemetry is disabled.`);
                return;
            }

            await this.emit(events);
        } catch {
            logger.debug(LogId.telemetryEmitFailure, "telemetry", `Error emitting telemetry events.`);
        }
    }

    /**
     * Gets the common properties for events
     * @returns Object containing common properties for all events
     */
    public getCommonProperties(): CommonProperties {
        return {
            ...this.commonProperties,
            mcp_client_version: this.session.agentRunner?.version,
            mcp_client_name: this.session.agentRunner?.name,
            session_id: this.session.sessionId,
            config_atlas_auth: this.session.apiClient.hasCredentials() ? "true" : "false",
            config_connection_string: this.userConfig.connectionString ? "true" : "false",
        };
    }

    /**
     * Checks if telemetry is currently enabled
     * This is a method rather than a constant to capture runtime config changes
     *
     * Follows the Console Do Not Track standard (https://consoledonottrack.com/)
     * by respecting the DO_NOT_TRACK environment variable
     */
    public isTelemetryEnabled(): boolean {
        // Check if telemetry is explicitly disabled in config
        if (this.userConfig.telemetry === "disabled") {
            return false;
        }

        const doNotTrack = "DO_NOT_TRACK" in process.env;
        return !doNotTrack;
    }

    /**
     * Attempts to emit events through authenticated and unauthenticated clients
     * Falls back to caching if both attempts fail
     */
    private async emit(events: BaseEvent[]): Promise<void> {
        if (this.isBufferingEvents) {
            this.eventCache.appendEvents(events);
            return;
        }

        const cachedEvents = this.eventCache.getEvents();
        const allEvents = [...cachedEvents, ...events];

        logger.debug(
            LogId.telemetryEmitStart,
            "telemetry",
            `Attempting to send ${allEvents.length} events (${cachedEvents.length} cached)`
        );

        const result = await this.sendEvents(this.session.apiClient, allEvents);
        if (result.success) {
            this.eventCache.clearEvents();
            logger.debug(
                LogId.telemetryEmitSuccess,
                "telemetry",
                `Sent ${allEvents.length} events successfully: ${JSON.stringify(allEvents, null, 2)}`
            );
            return;
        }

        logger.debug(
            LogId.telemetryEmitFailure,
            "telemetry",
            `Error sending event to client: ${result.error instanceof Error ? result.error.message : String(result.error)}`
        );
        this.eventCache.appendEvents(events);
    }

    /**
     * Attempts to send events through the provided API client
     */
    private async sendEvents(client: ApiClient, events: BaseEvent[]): Promise<EventResult> {
        try {
            await client.sendEvents(
                events.map((event) => ({
                    ...event,
                    properties: { ...this.getCommonProperties(), ...event.properties },
                }))
            );
            return { success: true };
        } catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error)),
            };
        }
    }
}


## File: src/telemetry/types.ts

/**
 * Result type constants for telemetry events
 */
export type TelemetryResult = "success" | "failure";
export type ServerCommand = "start" | "stop";
export type TelemetryBoolSet = "true" | "false";

/**
 * Base interface for all events
 */
export type TelemetryEvent<T> = {
    timestamp: string;
    source: "mdbmcp";
    properties: T & {
        component: string;
        duration_ms: number;
        result: TelemetryResult;
        category: string;
    };
};

export type BaseEvent = TelemetryEvent<unknown>;

/**
 * Interface for tool events
 */
export type ToolEventProperties = {
    command: string;
    error_code?: string;
    error_type?: string;
    project_id?: string;
    org_id?: string;
    cluster_name?: string;
    is_atlas?: boolean;
};

export type ToolEvent = TelemetryEvent<ToolEventProperties>;
/**
 * Interface for server events
 */
export type ServerEventProperties = {
    command: ServerCommand;
    reason?: string;
    startup_time_ms?: number;
    runtime_duration_ms?: number;
    read_only_mode?: boolean;
    disabled_tools?: string[];
};

export type ServerEvent = TelemetryEvent<ServerEventProperties>;

/**
 * Interface for static properties, they can be fetched once and reused.
 */
export type CommonStaticProperties = {
    mcp_server_version: string;
    mcp_server_name: string;
    platform: string;
    arch: string;
    os_type: string;
    os_version?: string;
};

/**
 * Common properties for all events that might change.
 */
export type CommonProperties = {
    device_id?: string;
    mcp_client_version?: string;
    mcp_client_name?: string;
    config_atlas_auth?: TelemetryBoolSet;
    config_connection_string?: TelemetryBoolSet;
    session_id?: string;
} & CommonStaticProperties;


## File: src/types/mongodb-connection-string-url.d.ts

declare module "mongodb-connection-string-url" {
    import { URL } from "whatwg-url";
    import { redactConnectionString, ConnectionStringRedactionOptions } from "./redact";
    export { redactConnectionString, ConnectionStringRedactionOptions };
    declare class CaseInsensitiveMap<K extends string = string> extends Map<K, string> {
        delete(name: K): boolean;
        get(name: K): string | undefined;
        has(name: K): boolean;
        set(name: K, value: any): this;
        _normalizeKey(name: any): K;
    }
    declare abstract class URLWithoutHost extends URL {
        abstract get host(): never;
        abstract set host(value: never);
        abstract get hostname(): never;
        abstract set hostname(value: never);
        abstract get port(): never;
        abstract set port(value: never);
        abstract get href(): string;
        abstract set href(value: string);
    }
    export interface ConnectionStringParsingOptions {
        looseValidation?: boolean;
    }
    export declare class ConnectionString extends URLWithoutHost {
        _hosts: string[];
        constructor(uri: string, options?: ConnectionStringParsingOptions);
        get host(): never;
        set host(_ignored: never);
        get hostname(): never;
        set hostname(_ignored: never);
        get port(): never;
        set port(_ignored: never);
        get href(): string;
        set href(_ignored: string);
        get isSRV(): boolean;
        get hosts(): string[];
        set hosts(list: string[]);
        toString(): string;
        clone(): ConnectionString;
        redact(options?: ConnectionStringRedactionOptions): ConnectionString;
        typedSearchParams<T extends {}>(): {
            append(name: keyof T & string, value: any): void;
            delete(name: keyof T & string): void;
            get(name: keyof T & string): string | null;
            getAll(name: keyof T & string): string[];
            has(name: keyof T & string): boolean;
            set(name: keyof T & string, value: any): void;
            keys(): IterableIterator<keyof T & string>;
            values(): IterableIterator<string>;
            entries(): IterableIterator<[keyof T & string, string]>;
            _normalizeKey(name: keyof T & string): string;
            [Symbol.iterator](): IterableIterator<[keyof T & string, string]>;
            sort(): void;
            forEach<THIS_ARG = void>(
                callback: (this: THIS_ARG, value: string, name: string, searchParams: any) => void,
                thisArg?: THIS_ARG | undefined
            ): void;
            readonly [Symbol.toStringTag]: "URLSearchParams";
        };
    }
    export declare class CommaAndColonSeparatedRecord<
        K extends {} = Record<string, unknown>,
    > extends CaseInsensitiveMap<keyof K & string> {
        constructor(from?: string | null);
        toString(): string;
    }
    export default ConnectionString;
}


## File: src/types/mongodb-redact.d.ts

declare module "mongodb-redact" {
    function redact<T>(message: T): T;
    export default redact;
}



--- End of repository dump ---
